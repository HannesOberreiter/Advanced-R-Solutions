% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{krantz}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Advanced R Solutions},
  pdfauthor={Malte Grosser, Henning Bumann \& Hadley Wickham},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% \lstset{
%   breaklines=true
% }

\usepackage{booktabs}
\usepackage{longtable}
\renewcommand{\figurename}{Fig}
\renewcommand{\tablename}{Tab}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{253,253,253}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}
\raggedbottom

% tweak deafult fonts
\usepackage{fontspec}
\usepackage{xltxtra,xunicode}
\defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
\setmonofont[Mapping=tex-ansi]{inconsolata}

% Chinese fonts
\usepackage{xeCJK}

% box drawing characters
% <https://tex.stackexchange.com/a/333210/6444>
\usepackage{newunicodechar}
\newfontfamily{\fallbackfont}{Andale-Mono}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\newunicodechar{█}{\textfallback{█}}
\newunicodechar{└}{\textfallback{└}}
\newunicodechar{─}{\textfallback{─}}
\newunicodechar{├}{\textfallback{├}}
\newunicodechar{│}{\textfallback{│}}

% Place links inline
\let\oldhref\href
\renewcommand{\href}[2]{#2 (\url{#1})}

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}

% % Colour
\renewcommand{\KeywordTok} [1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\renewcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\renewcommand{\DecValTok}  [1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\renewcommand{\BaseNTok}   [1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\renewcommand{\FloatTok}   [1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\renewcommand{\CharTok}    [1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\renewcommand{\StringTok}  [1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\renewcommand{\CommentTok} [1]{\textcolor[rgb]{0.38,0.63,0.69}{{#1}}}
\renewcommand{\OtherTok}   [1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\renewcommand{\AlertTok}   [1]{\textcolor[rgb]{1.00,0.00,0.00}{{#1}}}
\renewcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\renewcommand{\ErrorTok}   [1]{\textcolor[rgb]{1.00,0.00,0.00}{{#1}}}
\renewcommand{\NormalTok}  [1]{{#1}}

% No widow lines
\widowpenalty=10000
\clubpenalty=10000

\usepackage{makeidx}
\newcommand{\indexc}[1]{\index{#1@\texttt{#1}}}
\makeindex

\urlstyle{tt}

\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\frontmatter
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\title{Advanced R Solutions}
\author{Malte Grosser, Henning Bumann \& Hadley Wickham}
\date{(updated on 2020-12-29)}

\begin{document}
\maketitle

% you may need to leave a few empty pages before the dedication page

%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage
\thispagestyle{empty}

\begin{center}
To %Mina, the best book writing companion.

%\includegraphics[width=0.33\textwidth]{mina.jpg}

\end{center}

\setlength{\abovedisplayskip}{-5pt}
\setlength{\abovedisplayshortskip}{-5pt}

{
\setcounter{tocdepth}{1}
\tableofcontents
}
--\textgreater{}

\mainmatter

\hypertarget{preface}{%
\chapter{Preface}\label{preface}}

Welcome to Advanced R Solutions!

This book provides worked-out solutions to the exercises given in Advanced R (2nd Edition, Wickham, 2019) and reflects our efforts to understand and acquire its content.

Advanced R covers R and programming. It presents the specific characteristics of the R language to programmers and helps R users to improve their understanding of general programming concepts.

When we came across Advanced R, it gave us a more thorough understanding of the R code we worked with daily and helped us to see the underlying principles more clearly. The content helped us to get a more complete picture of R's programming landscape.

We soon re-discovered that reading about programming is not enough and that it helps greatly to open the editor and write some code along the way. The clear structure of Advanced R and the exercises given provided a great starting point for this.

We think of this book as a solutions manual, which intends to supplement and support your own study of the R language through Advanced R. We hope that it will help you to stay on track and allow you to check your understanding and progress along the way. The solutions may also give you another perspective on some of the presented material.

\hypertarget{how-this-book-came-to-be}{%
\section{How this book came to be}\label{how-this-book-came-to-be}}

The solutions in this book are written from our personal perspective and current level of understanding. We both come from mathematics and statistics backgrounds preparing us more carefully for data analysis than for programming. So, we were R users first and improved as programmers in our day jobs and through working on projects like this one.

By taking advantage of the \texttt{\{bookdown\}} package to structure our process we created this book almost as a by-product. While the initial progress was fun and motivating, providing solutions to actually all of the 284 exercises took slightly longer than originally expected (and Hadley's rewrite of Advanced R halfway in between didn't really make the journey shorter).

As the project matured, we strived to provide solutions as clean, straightforward, and expressive as possible. As well written code is often more expressive than lengthy explanations, many of the solutions are rather code-heavy. The written explanations aim to fill in context and motivation, discuss important implementation details or relate to the practical work of being an R programmer.

Hadley Wickham wrote Advanced R and created the exercises which form the substructure of this book. We took the task to solve them as correctly and idiomatically as possible. When we finished a chapter, we asked Hadley to review it. His feedback included many comments (which we then had to resolve), corrections and suggestions, as well as a few complete solutions. We repeated this process until each exercise was reviewed and approved. As a result, we feel pretty good about the quality of the solutions in the book. However, any remaining mistakes or inconsistencies are certainly on us.

\hypertarget{how-to-use-this-book}{%
\section{How to use this book}\label{how-to-use-this-book}}

Since this book builds so heavily on Advanced R, we think it should be read together with the textbook, either as a hardcopy or the online version (\url{https://adv-r.hadley.nz}). Working on an exercise first by yourself should in general give you the biggest benefit.

It may be a good idea to start with the parts of Advanced R that are most relevant to your work and interest. You can certainly read the book cover to cover, but we think that you don't have to, though it's probably a good idea to start with the foundations part.

Of the more difficult exercises in the book, only a few were completed in one go. Often we had to reread the question or look up the related content in Advanced R and started by writing a few first lines of code or consulted the documentation. Reading the source code (preferably with syntax highlighting) and searching the web were typically quite helpful.

To support your study, you may also be interested in the \href{https://GitHub.com/r4ds/bookclub-Advanced_R}{R4DS Advanced R book club}, where groups of readers regularly discuss a different chapter of Advanced R.

In case you want to do more or have a special interest in the mechanics of base R, you may be interested in checking out the first edition of Advanced R (\url{http://adv-r.had.co.nz/}). Some additional solutions related to that edition can be found at \url{https://advanced-r-solutions-ed1.netlify.app/}.

There is one recommendation from Advanced R that we'd like to echo: reading source code can be tremendously helpful in developing your programming skill! For example, you can just head to GitHub and start looking into the source code of packages you love and developers you admire. While reading, it's not necessary to understand every line of code right away. Keeping this a regular practice (for a while) will expose you to many new ideas, patterns, design choices and also expand your R vocabulary.

We don't necessarily apply many of the concepts taught in Advanced R in daily programming and that's okay! But we hope that the code we write has become more robust, expressive, and readable and it's actually quite easy to see the progress, when we take a look at the earlier drafts of our own code.

\hypertarget{acknowledgements}{%
\section{Acknowledgements}\label{acknowledgements}}

Many open source projects are the result of the work of a lot of people; so is this. We would like to explicitly mention and thank everybody who contributed solutions, raised questions, or helped to fix spelling and grammar to improve this work.

@3zhang, Jun Cai (@arashHaratian), Leon Kim (@BetweenTwoTests), @caijun, PJ (@Charles926), Safouane Chergui (@chsafouane), Corrado Lanera (@CorradoLanera), @davidblitz, Zhuoer Dong (@dongzhuoer), @Elucidase, Fabian Scheipl (@fabian-s), @its-gazza, Jorge Aranda (@jorgearanda), @lotgon, @MajoroMask, Maya Gans (@MayaGans), Øystein Sørensen (@osorensen), Peter Hurford (@peterhurford), @philyoun, Arash (@pieterjanvc), Robert Krzyzanowski (@robertzk), Tanner Stauss (@tmstauss), Anh N Tran (@trannhatanh89), Yihui Xie (@yihui).

Tobias Stalder (\href{https://twitter.com/toeb18}{\texttt{@toeb18}}) designed the beautiful cover, which visualizes the structure of Advanced R and its exercises.

Thanks to CRC Press for the interest in the project and our editors Rob Calver and Vaishali Singh for their patience and support in making this book a reality.

Thanks to our managers and companies for granting us some flexibility with our work schedules and generally supporting the completion of this project.

\hypertarget{conventions}{%
\section{Conventions}\label{conventions}}

A brief overview of conventions we followed and decisions we made.

\begin{itemize}
\tightlist
\item
  Some chapters and sections in Advanced R do not contain exercises. In our book you will see that we skipped these chapters and sections. This decision introduces some gaps in the numbering, but we feel that keeping the numbers in sync with those of Advanced R will provide the most practical value.
\item
  We strived to follow mostly the \href{https://style.tidyverse.org/}{tidyverse style guide} (using the \texttt{\{styler\}} package \citep{styler} made this a bit easier).
\item
  Each chapter of this book was rendered in a separate R session via the \texttt{\{bookdown\}} package. We configured this process to initially

  \begin{itemize}
  \tightlist
  \item
    set \texttt{\textasciigrave{}\%\textgreater{}\%\textasciigrave{}\ \textless{}-\ magrittr::\textasciigrave{}\%\textgreater{}\%\textasciigrave{}} to unlock the pipe operator without specifically loading the \texttt{\{magrittr\}} package \citep{magrittr} every time,
  \item
    set a random seed (\texttt{1014}) to improve reproducibility (similar as in Advanced R), and
  \item
    define a few \texttt{\{ggplot2\}} and \texttt{\{knitr\}} options.
  \end{itemize}

  You can check out the \href{https://GitHub.com/Tazinho/Advanced-R-Solutions/blob/main/common.R}{exact code} on GitHub.
\item
  We chose to keep the code in this book as self-contained as possible.

  \begin{itemize}
  \tightlist
  \item
    The packages used are usually loaded in the beginning of each chapter.
  \item
    We repeated all code from Advanced R that is necessary to work on an exercise but not explicitly part of the exercise. When some longer code passages (from Advanced R) were omitted this is explicitly stated in the solution.
  \end{itemize}
\item
  The printed version of the book was rendered with R version 4.0.3 (2020-10-10) and the most recent available package versions as of December 2020.
\item
  Emoji images in the printed book come from the open-licensed \href{https://github.com/twitter/twemoji}{Twitter Emoji}.
\item
  Benchmarks are computed when the book is rendered. While this improves reproducibility, the exact results will depend on the system creating the document.
\end{itemize}

\hypertarget{closing-remarks}{%
\section{Closing remarks}\label{closing-remarks}}

We are so happy to finish this exciting project, that in fact neither of us really had the time for. We probably wouldn't have made it to the finish line if we hadn't worked on it together.

Collaboration is powerful and it's fun to build and share. The various backgrounds represented in the R community generally make this exchange much more interesting and meaningful. Much of this success is possible because R is free software. At least in theory everyone can contribute, and no one can take away your freedom to do so.

The automated systems we build using these tools are not neutral and the rapid adoption of data-driven processes in business and technology does clearly affect our everyday lives and societies. It's important that everyone has a fair say in the discussions about these systems and participate in their design. Against this background we chose to donate half of our royalties from this book to \url{https://rladies.org/}, an organization empowering female R users.

Thank you for your interest in this project and we hope the solutions will be of value to you.

See you around!

Malte Grosser \href{https://twitter.com/malte_grosser}{\texttt{@malte\_grosser}}

Henning Bumann \href{https://twitter.com/henningsway}{\texttt{@henningsway}}

\hypertarget{part-foundations}{%
\part{Foundations}\label{part-foundations}}

\hypertarget{names-and-values}{%
\chapter{Names and values}\label{names-and-values}}

\hypertarget{prerequisites}{%
\section*{Prerequisites}\label{prerequisites}}


We will use the \texttt{\{lobstr\}} package to help answer questions regarding the internal representation of R objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lobstr) }
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{binding-basics}{%
\section{Binding basics}\label{binding-basics}}

\textbf{{Q1}}: Explain the relationship between \texttt{a}, \texttt{b}, \texttt{c}, and \texttt{d} in the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\NormalTok{a}
\NormalTok{c <-}\StringTok{ }\NormalTok{b}
\NormalTok{d <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{a}, \texttt{b}, and \texttt{c} point to the same object (with the same address in memory). This object has the value \texttt{1:10}. \texttt{d} points to a different object with the same value.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_of_names <-}\StringTok{ }\KeywordTok{list}\NormalTok{(a, b, c, d)}
\KeywordTok{obj_addrs}\NormalTok{(list_of_names)}
\CommentTok{#> [1] "0x196fa590" "0x196fa590" "0x196fa590" "0x197de790"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with \texttt{lobstr::obj\_addr()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean}
\NormalTok{base}\OperatorTok{::}\NormalTok{mean}
\KeywordTok{get}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\KeywordTok{evalq}\NormalTok{(mean)}
\KeywordTok{match.fun}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Yes, they point to the same object. We confirm this by inspecting the address of the underlying function object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mean_functions <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
\NormalTok{  mean,}
\NormalTok{  base}\OperatorTok{::}\NormalTok{mean,}
  \KeywordTok{get}\NormalTok{(}\StringTok{"mean"}\NormalTok{),}
  \KeywordTok{evalq}\NormalTok{(mean),}
  \KeywordTok{match.fun}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\NormalTok{)}

\KeywordTok{unique}\NormalTok{(}\KeywordTok{obj_addrs}\NormalTok{(mean_functions))}
\CommentTok{#> [1] "0x138446f0"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: By default, base R data import functions, like \texttt{read.csv()}, will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?

\textbf{{A}}: Column names are often data, and the underlying \texttt{make.names()} transformation is non-invertible, so the default behaviour corrupts data. To avoid this, set \texttt{check.names\ =\ FALSE}.

\textbf{{Q4}}: What rules does \texttt{make.names()} use to convert non-syntactic names into syntactic ones?

\textbf{{A}}: A valid name may contain letters, numbers, dots, and underscores (\texttt{"\_"} are allowed since R version 1.9.0). It must start with a letter or a dot. If it starts with a dot, it must not be followed by a number.

Three main mechanisms ensure syntactically valid names (see \texttt{?make.names}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Names that do not start with a letter or a dot will be prepended with an \texttt{"X"}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make.names}\NormalTok{(}\StringTok{""}\NormalTok{)    }\CommentTok{# prepending "x"}
\CommentTok{#> [1] "X"}
\end{Highlighting}
\end{Shaded}

  The same holds for names that begin with a dot followed by a number.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make.names}\NormalTok{(}\StringTok{".1"}\NormalTok{)  }\CommentTok{# prepending "X"}
\CommentTok{#> [1] "X.1"}
\end{Highlighting}
\end{Shaded}
\item
  Additionally, non-valid characters are replaced by a dot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make.names}\NormalTok{(}\StringTok{"@"}\NormalTok{)          }\CommentTok{# prepending "X" + "." replacement }
\CommentTok{#> [1] "X."}
\KeywordTok{make.names}\NormalTok{(}\StringTok{"  "}\NormalTok{)         }\CommentTok{# prepending "X" + ".." replacement}
\CommentTok{#> [1] "X.."}
\KeywordTok{make.names}\NormalTok{(}\StringTok{"non-valid"}\NormalTok{)  }\CommentTok{# "." replacement}
\CommentTok{#> [1] "non.valid"}
\end{Highlighting}
\end{Shaded}
\item
  Reserved R keywords (see \texttt{?reserved}) are suffixed by a dot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make.names}\NormalTok{(}\StringTok{"if"}\NormalTok{)  }\CommentTok{# "." suffix}
\CommentTok{#> [1] "if."}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

Interestingly, some of these transformations are influenced by the current locale. From \texttt{?make.names}:

\begin{quote}
The definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.
\end{quote}

\textbf{{Q5}}: I slightly simplified the rules that govern syntactic names. Why is \texttt{.123e1} not a syntactic name? Read \texttt{?make.names} for the full details.

\textbf{{A}}: \texttt{.123e1} is not a syntactic name, because it starts with one dot which is followed by a number. This makes it a double, \texttt{1.23}.

\hypertarget{copy-on-modify}{%
\section{Copy-on-modify}\label{copy-on-modify}}

\textbf{{Q1}}: Why is \texttt{tracemem(1:10)} not useful?

\textbf{{A}}: When \texttt{1:10} is called an object with an address in memory is created, but it is not bound to a name. Therefore, the object cannot be called or manipulated from R. As no copies will be made, it is not useful to track the object for copying.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_addr}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)  }\CommentTok{# the object exists, but has no name}
\CommentTok{#> [1] "0x18f3d2f8"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Explain why \texttt{tracemem()} shows two copies when you run this code. Hint: carefully look at the difference between this code and the code shown earlier in the section.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{tracemem}\NormalTok{(x)}

\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Initially the vector \texttt{x} has integer type. The replacement call assigns a double to the third element of \texttt{x}, which triggers copy-on-modify.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{tracemem}\NormalTok{(x)}
\CommentTok{#> <0x66a4a70>}

\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\DecValTok{4}
\CommentTok{#> tracemem[0x55eec7b3af38 -> 0x55eec774cc18]: }
\end{Highlighting}
\end{Shaded}

We can avoid the copy by sub-assigning an integer instead of a double:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L, 2L, 3L)}
\KeywordTok{tracemem}\NormalTok{(x)}
\CommentTok{#> <0x55eec6940ae0>}

\NormalTok{x[[}\DecValTok{3}\NormalTok{]] <-}\StringTok{ }\NormalTok{4L}
\end{Highlighting}
\end{Shaded}

Please be aware that running this code in RStudio will result in additional copies because of the reference from the environment pane.

\textbf{{Q3}}: Sketch out the relationship between the following objects:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(a, a)}
\NormalTok{c <-}\StringTok{ }\KeywordTok{list}\NormalTok{(b, a, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{a} contains a reference to an address with the value \texttt{1:10}. \texttt{b} contains a list of two references to the same address as \texttt{a}. \texttt{c} contains a list of \texttt{b} (containing two references to \texttt{a}), \texttt{a} (containing the same reference again) and a reference pointing to a different address containing the same value (\texttt{1:10}).

\begin{center}\includegraphics[width=180pt]{images/names_values/copy_on_modify_fig3} \end{center}

We can confirm these relationships by inspecting the reference tree in R.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ref}\NormalTok{(c)}
\CommentTok{#> █ [1:0x55erc93cbdd8] <list>    # c}
\CommentTok{#> ├─█ [2:0x55efcb8246e8] <list>  # - b}
\CommentTok{#> │ ├─[3:0x55eac7df4e98] <int>   # -- a}
\CommentTok{#> │ └─[3:0x55eac7df4e98]         # -- a}
\CommentTok{#> ├─[3:0x55eac7df4e98]           # - a}
\CommentTok{#> └─[4:0x55etc7aa6968] <int>     # - 1:10}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: What happens when you run this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{x[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\NormalTok{x}
\end{Highlighting}
\end{Shaded}

Draw a picture.

\textbf{{A}}: The initial reference tree of \texttt{x} shows that the name \texttt{x} binds to a list object. This object contains a reference to the integer vector \texttt{1:10}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}

\KeywordTok{ref}\NormalTok{(x)}
\CommentTok{#> █ [1:0x55853b74ff40] <list> }
\CommentTok{#> └─[2:0x534t3abffad8] <int> }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=135pt]{images/names_values/copy_on_modify_fig1} \end{center}

When \texttt{x} is assigned to an element of itself copy-on-modify takes place and the list is copied to a new address in memory.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tracemem}\NormalTok{(x)}
\NormalTok{x[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\NormalTok{x}
\CommentTok{#> tracemem[0x55853b74ff40 -> 0x5d553bacdcd8]:}
\end{Highlighting}
\end{Shaded}

The list object previously bound to \texttt{x} is now referenced in the newly created list object. It is no longer bound to a name. The integer vector is referenced twice.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ref}\NormalTok{(x)}
\CommentTok{#> █ [1:0x5d553bacdcd8] <list> }
\CommentTok{#> ├─[2:0x534t3abffad8] <int> }
\CommentTok{#> └─█ [3:0x55853b74ff40] <list> }
\CommentTok{#>   └─[2:0x534t3abffad8] }
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=150pt]{images/names_values/copy_on_modify_fig2} \end{center}

\hypertarget{object-size}{%
\section{Object size}\label{object-size}}

\textbf{{Q1}}: In the following example, why are \texttt{object.size(y)} and \texttt{obj\_size(y)} so radically different? Consult the documentation of \texttt{object.size()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\FloatTok{1e4}\NormalTok{)), }\DecValTok{100}\NormalTok{)}

\KeywordTok{object.size}\NormalTok{(y)}
\CommentTok{#> 8005648 bytes}
\KeywordTok{obj_size}\NormalTok{(y)}
\CommentTok{#> 80,896 B}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{object.size()} doesn't account for shared elements within lists. Therefore, the results differ by a factor of \textasciitilde{} 100.

\textbf{{Q2}}: Take the following list. Why is its size somewhat misleading?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(mean, sd, var)}
\KeywordTok{obj_size}\NormalTok{(funs)}
\CommentTok{#> 17,608 B}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: All three functions are built-in to R as part of the \texttt{\{base\}} and \texttt{\{stats\}} packages and hence always available. So, what does it mean to measure the size of something that's already included in R?

(There's typically a more general question about what you want to know when you ask for the size of something --- do you want to know how much data you'd need to send to communicate the object to someone else (e.g.~serialise it), or do you want to know how much memory you'd free if you deleted it?)

Let us look for how many other objects this applies as well.

The following packages are usually loaded by default.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{base_pkgs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"package:stats"}\NormalTok{, }\StringTok{"package:graphics"}\NormalTok{, }\StringTok{"package:grDevices"}\NormalTok{,}
  \StringTok{"package:utils"}\NormalTok{, }\StringTok{"package:datasets"}\NormalTok{, }\StringTok{"package:methods"}\NormalTok{,}
  \StringTok{"package:base"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To look up all functions from these packages we iterate over \texttt{base\_pkgs} and apply \texttt{ls()} and \texttt{mget()} within each iteration.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{base_objs <-}\StringTok{ }\NormalTok{base_pkgs }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{lapply}\NormalTok{(as.environment) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{lapply}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mget}\NormalTok{(}\KeywordTok{ls}\NormalTok{(x, }\DataTypeTok{all.names =} \OtherTok{TRUE}\NormalTok{), x)) }\OperatorTok{%>%}
\StringTok{  }\NormalTok{magrittr}\OperatorTok{::}\KeywordTok{set_names}\NormalTok{(base_pkgs)}
\end{Highlighting}
\end{Shaded}

This gives us more than 2700 objects which are usually available by default.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{lengths}\NormalTok{(base_objs))}
\CommentTok{#> [1] 2745}

\CommentTok{# We can also show the sizes in MB per package}
\KeywordTok{vapply}\NormalTok{(base_objs, obj_size, }\KeywordTok{double}\NormalTok{(}\DecValTok{1}\NormalTok{)) }\OperatorTok{/}\StringTok{ }\DecValTok{1024}\OperatorTok{^}\DecValTok{2}
\CommentTok{#>     package:stats  package:graphics package:grDevices }
\CommentTok{#>             11.00              3.08              1.84 }
\CommentTok{#>     package:utils  package:datasets   package:methods }
\CommentTok{#>              7.15              0.54             12.83 }
\CommentTok{#>      package:base }
\CommentTok{#>             18.91}

\CommentTok{# Check if we've over-counted}
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{obj_size}\NormalTok{(}\OperatorTok{!!!}\NormalTok{base_objs)) }\OperatorTok{/}\StringTok{ }\DecValTok{1024}\OperatorTok{^}\DecValTok{2}
\CommentTok{#> [1] 53.6}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Predict the output of the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\KeywordTok{obj_size}\NormalTok{(a)}

\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(a, a)}
\KeywordTok{obj_size}\NormalTok{(b)}
\KeywordTok{obj_size}\NormalTok{(a, b)}

\NormalTok{b[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(b)}
\KeywordTok{obj_size}\NormalTok{(a, b)}

\NormalTok{b[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(b)}
\KeywordTok{obj_size}\NormalTok{(a, b)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In R (on most platforms) a length-0
vector has 48 bytes of overhead.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{list}\NormalTok{())}
\CommentTok{#> 48 B}
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{double}\NormalTok{())}
\CommentTok{#> 48 B}
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{character}\NormalTok{())}
\CommentTok{#> 48 B}
\end{Highlighting}
\end{Shaded}

A single double takes up additional 8 bytes of memory.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{double}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> 56 B}
\KeywordTok{obj_size}\NormalTok{(}\KeywordTok{double}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\CommentTok{#> 64 B}
\end{Highlighting}
\end{Shaded}

So, a 1 million double should take up 8,000,048 bytes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e6}\NormalTok{)}
\KeywordTok{obj_size}\NormalTok{(a)}
\CommentTok{#> 8,000,048 B}
\end{Highlighting}
\end{Shaded}

(If you look carefully at the amount of memory occupied by short vectors, you will notice that the pattern is actually more complicated. This has to do with how R allocates memory and is not that important. If you want to know the full details, they're discussed in the 1st edition of Advanced R: \url{http://adv-r.had.co.nz/memory.html\#object-size}).

For \texttt{b\ \textless{}-\ list(a,\ a)} both list elements contain references to the same memory address.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\KeywordTok{list}\NormalTok{(a, a)}
\KeywordTok{ref}\NormalTok{(a, b)}
\CommentTok{#> [1:0x7ff4fd240010] <dbl> }
\CommentTok{#>  }
\CommentTok{#> o [2:0x1875ad80] <list> }
\CommentTok{#> +-[1:0x7ff4fd240010] }
\CommentTok{#> \textbackslash{}-[1:0x7ff4fd240010]}
\end{Highlighting}
\end{Shaded}

Therefore, no additional memory is required for the second list element. The list itself requires 64 bytes, 48 bytes for an empty list and 8 bytes for each element (\texttt{obj\_size(vector("list",\ 2))}). This lets us predict 8,000,048 B + 64 B = 8,000,112 B.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(b)}
\CommentTok{#> 8,000,112 B}
\end{Highlighting}
\end{Shaded}

When we modify the first element of \texttt{b{[}{[}1{]}{]}} copy-on-modify occurs. Both elements will still have the same size (8,000,040 B), but the first one gets a new address in memory. As \texttt{b}'s elements don't share references anymore, its object size adds up to the sum of the elements and the length-2 list: 8,000,048 B + 8,000,048 B + 64 B = 16,000,160 B (16 MB).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(b)}
\CommentTok{#> 16,000,160 B}
\end{Highlighting}
\end{Shaded}

The second element of \texttt{b} still references to the same address as \texttt{a}, so the combined size of \texttt{a} and \texttt{b} is the same as \texttt{b}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{obj_size}\NormalTok{(a, b) }
\CommentTok{#> 16,000,160 B}
\KeywordTok{ref}\NormalTok{(a, b)}
\CommentTok{#> [1:0x7ff4fd240010] <dbl> }
\CommentTok{#>  }
\CommentTok{#> o [2:0x24405220] <list> }
\CommentTok{#> +-[3:0x7ff4fa1c0010] <dbl> }
\CommentTok{#> \textbackslash{}-[1:0x7ff4fd240010]}
\end{Highlighting}
\end{Shaded}

When we modify the second element of \texttt{b}, this element will also point to a new memory address. This does not affect the size of the list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b[[}\DecValTok{2}\NormalTok{]][[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\DecValTok{10}
\KeywordTok{obj_size}\NormalTok{(b) }
\CommentTok{#> 16,000,160 B}
\end{Highlighting}
\end{Shaded}

However, as \texttt{b} doesn't share references with \texttt{a} anymore, the memory usage of the combined objects increases.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ref}\NormalTok{(a, b)}
\CommentTok{#> [1:0x7ff4fd240010] <dbl> }
\CommentTok{#>  }
\CommentTok{#> o [2:0x24034fb0] <list> }
\CommentTok{#> +-[3:0x7ff4fa1c0010] <dbl> }
\CommentTok{#> \textbackslash{}-[4:0x7ff4fc060010] <dbl>}
\KeywordTok{obj_size}\NormalTok{(a, b) }
\CommentTok{#> 24,000,208 B}
\end{Highlighting}
\end{Shaded}

\hypertarget{modify-in-place}{%
\section{Modify-in-place}\label{modify-in-place}}

\textbf{{Q1}}: Explain why the following code doesn't create a circular list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In this situation copy-on-modify prevents the creation of a circular list. Let us step through the details:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{()  }\CommentTok{# creates initial object}
\KeywordTok{obj_addr}\NormalTok{(x)}
\CommentTok{#> [1] "0x55862f23ab80"}

\KeywordTok{tracemem}\NormalTok{(x)}
\CommentTok{#> [1] "<0x55862f23ab80>"}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]] <-}\StringTok{ }\NormalTok{x  }\CommentTok{# Copy-on-modify triggers new copy}
\CommentTok{#> tracemem[0x55862f23ab80 -> 0x55862e8ce028]:}

\KeywordTok{obj_addr}\NormalTok{(x)       }\CommentTok{# copied object has new memory address}
\CommentTok{#> [1] "0x55862e8ce028"}
\KeywordTok{obj_addr}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])  }\CommentTok{# list element contains old memory address}
\CommentTok{#> [1] "0x55862f23ab80"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Wrap the two methods for subtracting medians into two functions, then use the \texttt{\{bench\}} package to carefully compare their speeds. How does performance change as the number of columns increase?

\textbf{{A}}: First, we define a function to create some random data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{create_random_df <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(nrow, ncol) \{}
\NormalTok{  random_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{runif}\NormalTok{(nrow }\OperatorTok{*}\StringTok{ }\NormalTok{ncol), }\DataTypeTok{nrow =}\NormalTok{ nrow)}
  \KeywordTok{as.data.frame}\NormalTok{(random_matrix)}
\NormalTok{\}}

\KeywordTok{create_random_df}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#>      V1     V2}
\CommentTok{#> 1 0.972 0.0116}
\CommentTok{#> 2 0.849 0.4339}
\end{Highlighting}
\end{Shaded}

Next, we wrap the two approaches to subtract numerical values (in our case medians) from each column of a data frame in their own function. We name these functions depending on whether the approach operates on a data frame or a list. For a fairer comparison, the second function also contains the overhead code to convert between data frame and list objects.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subtract_df <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, medians) \{}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(medians)) \{}
\NormalTok{    x[[i]] <-}\StringTok{ }\NormalTok{x[[i]] }\OperatorTok{-}\StringTok{ }\NormalTok{medians[[i]]}
\NormalTok{  \}}
\NormalTok{  x}
\NormalTok{\}}

\NormalTok{subtract_list <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, medians) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{subtract_df}\NormalTok{(x, medians)}
  \KeywordTok{list2DF}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This lets us profile the performance, via benchmarks on data frames with differing numbers of columns. Therefore, we create a small helper that creates our random data frame and its medians before it benchmarks the two approaches.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{benchmark_medians <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(ncol) \{}
\NormalTok{  df <-}\StringTok{ }\KeywordTok{create_random_df}\NormalTok{(}\DataTypeTok{nrow =} \FloatTok{1e4}\NormalTok{, }\DataTypeTok{ncol =}\NormalTok{ ncol)}
\NormalTok{  medians <-}\StringTok{ }\KeywordTok{vapply}\NormalTok{(df, median, }\KeywordTok{numeric}\NormalTok{(}\DecValTok{1}\NormalTok{), }\DataTypeTok{USE.NAMES =} \OtherTok{FALSE}\NormalTok{)}

\NormalTok{  bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
    \StringTok{"data frame"}\NormalTok{ =}\StringTok{ }\KeywordTok{subtract_df}\NormalTok{(df, medians),}
    \StringTok{"list"}\NormalTok{ =}\StringTok{ }\KeywordTok{subtract_list}\NormalTok{(df, medians),}
    \DataTypeTok{time_unit =} \StringTok{"ms"}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{benchmark_medians}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression    min median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>  <dbl>  <dbl>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 data frame 0.034  0.0415    16449.     130KB     30.6}
\CommentTok{#> 2 list       0.0572 0.0667    11526.     160KB     41.6}
\end{Highlighting}
\end{Shaded}

The \texttt{bench::press()} function allows us to run our helper across a grid of parameters. We will use it to slowly increase the number of data frame columns in our benchmark.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{results <-}\StringTok{ }\NormalTok{bench}\OperatorTok{::}\KeywordTok{press}\NormalTok{(}
  \DataTypeTok{ncol =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{250}\NormalTok{, }\DecValTok{300}\NormalTok{, }\DecValTok{400}\NormalTok{, }\DecValTok{500}\NormalTok{, }\DecValTok{750}\NormalTok{, }\DecValTok{1000}\NormalTok{),}
  \KeywordTok{benchmark_medians}\NormalTok{(ncol)}
\NormalTok{)}
\CommentTok{#> Running with:}
\CommentTok{#>     ncol}
\CommentTok{#>  1     1}
\CommentTok{#>  2    10}
\CommentTok{#>  3    50}
\CommentTok{#>  4   100}
\CommentTok{#>  5   250}
\CommentTok{#>  6   300}
\CommentTok{#>  7   400}
\CommentTok{#>  8   500}
\CommentTok{#>  9   750}
\CommentTok{#> 10  1000}
\end{Highlighting}
\end{Shaded}

Finally, we can plot and interpret our results.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}

\KeywordTok{ggplot}\NormalTok{(}
\NormalTok{  results,}
  \KeywordTok{aes}\NormalTok{(ncol, median, }\DataTypeTok{col =} \KeywordTok{attr}\NormalTok{(expression, }\StringTok{"description"}\NormalTok{))}
\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}
    \DataTypeTok{x =} \StringTok{"Number of Columns"}\NormalTok{,}
    \DataTypeTok{y =} \StringTok{"Execution Time (ms)"}\NormalTok{,}
    \DataTypeTok{colour =} \StringTok{"Data Structure"}
\NormalTok{  ) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"top"}\NormalTok{)}
\CommentTok{#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{02_Names_and_values_files/figure-latex/unnamed-chunk-44-1} \end{center}

When working directly with the data frame, the execution time grows quadratically with the number of columns in the input data. This is because (e.g.) the first column must be copied n times, the second column n-1 times, and so on. When working with a list, the execution time increases only linearly.

Obviously in the long run, linear growth creates shorter run-times, but there is some cost to this strategy --- we have to convert between data structures with \texttt{as.list()} and \texttt{list2DF()}. Even though this is fast and probably doesn't hurt much, the improved approach doesn't really pay off in this scenario until we get to a data frame that is about 300 columns wide (with the exact value depending on the characteristics of the system running the code).

\textbf{{Q3}}: What happens if you attempt to use \texttt{tracemem()} on an environment?

\textbf{{A}}: \texttt{tracemem()} cannot be used to mark and trace environments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{()}
\KeywordTok{tracemem}\NormalTok{(x)}
\CommentTok{#> Error in tracemem(x): 'tracemem' is not useful for promise and}
\CommentTok{#> environment objects}
\end{Highlighting}
\end{Shaded}

The error occurs because ``it is not useful to trace NULL, environments, promises, weak references, or external pointer objects, as these are not duplicated'' (see \texttt{?tracemem}). Environments are always modified in place.

\hypertarget{vectors}{%
\chapter{Vectors}\label{vectors}}

\stepcounter{section}

\hypertarget{atomic-vectors}{%
\section{Atomic vectors}\label{atomic-vectors}}

\textbf{{Q1}}: How do you create raw and complex scalars? (See \texttt{?raw} and \texttt{?complex}.)

\textbf{{A}}: In R scalars are represented as vectors of length one. However, there's no built-in syntax like there is for logicals, integers, doubles, and character vectors to create individual raw and complex values. Instead, you have to create them by calling a function.

For raw vectors you can use either \texttt{as.raw()} or \texttt{charToRaw()} to create them from numeric or character values.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.raw}\NormalTok{(}\DecValTok{42}\NormalTok{)}
\CommentTok{#> [1] 2a}
\KeywordTok{charToRaw}\NormalTok{(}\StringTok{"A"}\NormalTok{)}
\CommentTok{#> [1] 41}
\end{Highlighting}
\end{Shaded}

In the case of complex numbers real and imaginary parts may be provided directly to the \texttt{complex()} constructor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{complex}\NormalTok{(}\DataTypeTok{length.out =} \DecValTok{1}\NormalTok{, }\DataTypeTok{real =} \DecValTok{1}\NormalTok{, }\DataTypeTok{imaginary =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 1+1i}
\end{Highlighting}
\end{Shaded}

You can create purely imaginary numbers (e.g.) \texttt{1i}, but there is no way to create complex numbers without \texttt{+} (e.g.~\texttt{1i\ +\ 1}).

\textbf{{Q2}}: Test your knowledge of vector coercion rules by predicting the output of the following uses of \texttt{c()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)      }\CommentTok{# will be coerced to double    -> 1 0}
\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{)        }\CommentTok{# will be coerced to character -> "a" "1"}
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, 1L)      }\CommentTok{# will be coerced to integer   -> 1 1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Why is \texttt{1\ ==\ "1"} true? Why is \texttt{-1\ \textless{}\ FALSE} true? Why is \texttt{"one"\ \textless{}\ 2} false?

\textbf{{A}}: These comparisons are carried out by operator-functions (\texttt{==}, \texttt{\textless{}}), which coerce their arguments to a common type. In the examples above these types will be character, double and character: \texttt{1} will be coerced to \texttt{"1"}, \texttt{FALSE} is represented as \texttt{0} and \texttt{2} turns into \texttt{"2"} (and numbers precede letters in lexicographic order (may depend on locale)).

\textbf{{Q4}}: Why is the default missing value, \texttt{NA}, a logical vector? What's special about logical vectors? (Hint: think about \texttt{c(FALSE,\ NA\_character\_)}.)

\textbf{{A}}: The presence of missing values shouldn't affect the type of an object. Recall that there is a type-hierarchy for coercion from character → double → integer → logical. When combining \texttt{NA}s with other atomic types, the \texttt{NA}s will be coerced to integer (\texttt{NA\_integer\_}), double (\texttt{NA\_real\_}) or character (\texttt{NA\_character\_}) and not the other way round. If \texttt{NA} were a character and added to a set of other values all of these would be coerced to character as well.

\textbf{{Q5}}: Precisely what do \texttt{is.atomic()}, \texttt{is.numeric()}, and \texttt{is.vector()} test for?

\textbf{{A}}: The documentation states that:

\begin{itemize}
\tightlist
\item
  \texttt{is.atomic()} tests if an object is an atomic vector (as defined in Advanced R) or is \texttt{NULL} (!).
\item
  \texttt{is.numeric()} tests if an object has type integer or double and is not of class \texttt{factor}, \texttt{Date}, \texttt{POSIXt} or \texttt{difftime}.
\item
  \texttt{is.vector()} tests if an object is a vector (as defined in Advanced R) or an expression and has no attributes, apart from names.
\end{itemize}

Atomic vectors are defined in Advanced R as objects of type logical, integer, double, complex, character or raw. Vectors are defined as atomic vectors or lists.

\hypertarget{attributes}{%
\section{Attributes}\label{attributes}}

\textbf{{Q1}}: How is \texttt{setNames()} implemented? How is \texttt{unname()} implemented? Read the source code.

\textbf{{A}}: \texttt{setNames()} is implemented as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{setNames <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{object =}\NormalTok{ nm, nm) \{}
  \KeywordTok{names}\NormalTok{(object) <-}\StringTok{ }\NormalTok{nm}
\NormalTok{  object}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Because the data argument comes first \texttt{setNames()} also works well with the magrittr-pipe operator. When no first argument is given, the result is a named vector (this is rather untypical as required arguments usually come first):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setNames}\NormalTok{( , }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{))}
\CommentTok{#>   a   b   c }
\CommentTok{#> "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

\texttt{unname()} is implemented in the following way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unname <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(obj, }\DataTypeTok{force =} \OtherTok{FALSE}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{names}\NormalTok{(obj))) }
    \KeywordTok{names}\NormalTok{(obj) <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{dimnames}\NormalTok{(obj)) }\OperatorTok{&&}\StringTok{ }\NormalTok{(force }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\KeywordTok{is.data.frame}\NormalTok{(obj))) }
    \KeywordTok{dimnames}\NormalTok{(obj) <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{  obj}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{unname()} removes existing names (or dimnames) by setting them to \texttt{NULL}.

\textbf{{Q2}}: What does \texttt{dim()} return when applied to a 1-dimensional vector? When might you use \texttt{NROW()} or \texttt{NCOL()}?

\textbf{{A}}: From \texttt{?nrow}:

\begin{quote}
\texttt{dim()} will return \texttt{NULL} when applied to a 1d vector.
\end{quote}

One may want to use \texttt{NROW()} or \texttt{NCOL()} to handle atomic vectors, lists and NULL values in the same way as one column matrices or data frames. For these objects \texttt{nrow()} and \texttt{ncol()} return \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}

\CommentTok{# Return NULL}
\KeywordTok{nrow}\NormalTok{(x)}
\CommentTok{#> NULL}
\KeywordTok{ncol}\NormalTok{(x)}
\CommentTok{#> NULL}

\CommentTok{# Pretend it's a column vector}
\KeywordTok{NROW}\NormalTok{(x)}
\CommentTok{#> [1] 10}
\KeywordTok{NCOL}\NormalTok{(x)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: How would you describe the following three objects? What makes them different to \texttt{1:5}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{))  }\CommentTok{# 1 row,  1 column,  5 in third dim.}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{))  }\CommentTok{# 1 row,  5 columns, 1 in third dim.}
\NormalTok{x3 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{))  }\CommentTok{# 5 rows, 1 column,  1 in third dim.}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: These are all ``one dimensional''. If you imagine a 3d cube, \texttt{x1} is in the x-dimension, \texttt{x2} is in the y-dimension, and \texttt{x3} is in the z-dimension. In contrast to \texttt{1:5}, \texttt{x1}, \texttt{x2} and \texttt{x3} have a \texttt{dim} attribute.

\textbf{{Q4}}: An early draft used this code to illustrate \texttt{structure()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{comment =} \StringTok{"my attribute"}\NormalTok{)}
\CommentTok{#> [1] 1 2 3 4 5}
\end{Highlighting}
\end{Shaded}

But when you print that object you don't see the comment attribute. Why? Is the attribute missing, or is there something else special about it? (Hint: try using help.)

\textbf{{A}}: The documentation states (see \texttt{?comment}):

\begin{quote}
Contrary to other attributes, the comment is not printed (by print or print.default).
\end{quote}

Also, from \texttt{?attributes}:

\begin{quote}
Note that some attributes (namely class, comment, dim, dimnames, names, row.names and tsp) are treated specially and have restrictions on the values which can be set.
\end{quote}

We can retrieve comment attributes by calling them explicitly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{comment =} \StringTok{"my attribute"}\NormalTok{)}

\KeywordTok{attributes}\NormalTok{(foo)}
\CommentTok{#> $comment}
\CommentTok{#> [1] "my attribute"}
\KeywordTok{attr}\NormalTok{(foo, }\DataTypeTok{which =} \StringTok{"comment"}\NormalTok{)}
\CommentTok{#> [1] "my attribute"}
\end{Highlighting}
\end{Shaded}

\hypertarget{s3-atomic-vectors}{%
\section{S3 atomic vectors}\label{s3-atomic-vectors}}

\textbf{{Q1}}: What sort of object does \texttt{table()} return? What is its type? What attributes does it have? How does the dimensionality change as you tabulate more variables?

\textbf{{A}}: \texttt{table()} returns a contingency table of its input variables. It is implemented as an integer vector with class \texttt{table} and dimensions (which makes it act like an array). Its attributes are \texttt{dim} (dimensions) and \texttt{dimnames} (one name for each input column). The dimensions correspond to the number of unique values (factor levels) in each input variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{table}\NormalTok{(mtcars[}\KeywordTok{c}\NormalTok{(}\StringTok{"vs"}\NormalTok{, }\StringTok{"cyl"}\NormalTok{, }\StringTok{"am"}\NormalTok{)])}

\KeywordTok{typeof}\NormalTok{(x)}
\CommentTok{#> [1] "integer"}
\KeywordTok{attributes}\NormalTok{(x)}
\CommentTok{#> $dim}
\CommentTok{#> [1] 2 3 2}
\CommentTok{#> }
\CommentTok{#> $dimnames}
\CommentTok{#> $dimnames$vs}
\CommentTok{#> [1] "0" "1"}
\CommentTok{#> }
\CommentTok{#> $dimnames$cyl}
\CommentTok{#> [1] "4" "6" "8"}
\CommentTok{#> }
\CommentTok{#> $dimnames$am}
\CommentTok{#> [1] "0" "1"}
\CommentTok{#> }
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "table"}

\CommentTok{# Subset x like it's an array}
\NormalTok{x[ , , }\DecValTok{1}\NormalTok{]}
\CommentTok{#>    cyl}
\CommentTok{#> vs   4  6  8}
\CommentTok{#>   0  0  0 12}
\CommentTok{#>   1  3  4  0}
\NormalTok{x[ , , }\DecValTok{2}\NormalTok{]}
\CommentTok{#>    cyl}
\CommentTok{#> vs  4 6 8}
\CommentTok{#>   0 1 3 2}
\CommentTok{#>   1 7 0 0}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What happens to a factor when you modify its levels?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters)}
\KeywordTok{levels}\NormalTok{(f1) <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{levels}\NormalTok{(f1))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The underlying integer values stay the same, but the levels are changed, making it look like the data has changed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters)}
\NormalTok{f1}
\CommentTok{#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z}
\CommentTok{#> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z}
\KeywordTok{as.integer}\NormalTok{(f1)}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21}
\CommentTok{#> [22] 22 23 24 25 26}

\KeywordTok{levels}\NormalTok{(f1) <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{levels}\NormalTok{(f1))}
\NormalTok{f1}
\CommentTok{#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a}
\CommentTok{#> Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a}
\KeywordTok{as.integer}\NormalTok{(f1)}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21}
\CommentTok{#> [22] 22 23 24 25 26}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: What does this code do? How do \texttt{f2} and \texttt{f3} differ from \texttt{f1}?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{factor}\NormalTok{(letters))}

\NormalTok{f3 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters, }\DataTypeTok{levels =} \KeywordTok{rev}\NormalTok{(letters))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: For \texttt{f2} and \texttt{f3} either the order of the factor elements \emph{or} its levels are being reversed. For \texttt{f1} both transformations are occurring.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Reverse element order (only)}
\NormalTok{(f2 <-}\StringTok{ }\KeywordTok{rev}\NormalTok{(}\KeywordTok{factor}\NormalTok{(letters)))}
\CommentTok{#>  [1] z y x w v u t s r q p o n m l k j i h g f e d c b a}
\CommentTok{#> Levels: a b c d e f g h i j k l m n o p q r s t u v w x y z}
\KeywordTok{as.integer}\NormalTok{(f2)}
\CommentTok{#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6}
\CommentTok{#> [22]  5  4  3  2  1}

\CommentTok{# Reverse factor level order (only)}
\NormalTok{(f3 <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(letters, }\DataTypeTok{levels =} \KeywordTok{rev}\NormalTok{(letters)))}
\CommentTok{#>  [1] a b c d e f g h i j k l m n o p q r s t u v w x y z}
\CommentTok{#> Levels: z y x w v u t s r q p o n m l k j i h g f e d c b a}
\KeywordTok{as.integer}\NormalTok{(f3)}
\CommentTok{#>  [1] 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6}
\CommentTok{#> [22]  5  4  3  2  1}
\end{Highlighting}
\end{Shaded}

\hypertarget{lists}{%
\section{Lists}\label{lists}}

\textbf{{Q1}}: List all the ways that a list differs from an atomic vector.

\textbf{{A}}: To summarise:

\begin{itemize}
\item
  Atomic vectors are always homogeneous (all elements must be of the same type). Lists may be heterogeneous (the elements can be of different types) as described in the \href{https://adv-r.hadley.nz/vectors-chap.html\#introduction}{introduction of the vectors chapter}.
\item
  Atomic vectors point to one address in memory, while lists contain a separate reference for each element. (This was described in the list sections of the \href{https://adv-r.hadley.nz/vectors-chap.html\#lists}{vectors} and the \href{https://adv-r.hadley.nz/names-values.html\#list-references}{names and values} chapters.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1:0x19f05710] <int>}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{#> o [1:0x18681b08] <list> }
\CommentTok{#> +-[2:0x15fba2a8] <int> }
\CommentTok{#> \textbackslash{}-[3:0x1970d260] <dbl>}
\end{Highlighting}
\end{Shaded}
\item
  Subsetting with out-of-bounds and \texttt{NA} values leads to different output. E.g. \texttt{{[}} returns \texttt{NA} for atomics and \texttt{NULL} for lists. (This is described in more detail within the \href{https://adv-r.hadley.nz/subsetting.html}{subsetting chapter}.)

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Subsetting atomic vectors}
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)[}\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] NA}
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)[}\OtherTok{NA}\NormalTok{]}
\CommentTok{#> [1] NA NA}

\CommentTok{# Subsetting lists}
\KeywordTok{as.list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)[}\DecValTok{3}\NormalTok{]}
\CommentTok{#> [[1]]}
\CommentTok{#> NULL}
\KeywordTok{as.list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{)[}\OtherTok{NA}\NormalTok{]}
\CommentTok{#> [[1]]}
\CommentTok{#> NULL}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}
\end{itemize}

\textbf{{Q2}}: Why do you need to use \texttt{unlist()} to convert a list to an atomic vector? Why doesn't \texttt{as.vector()} work?

\textbf{{A}}: A list is already a vector, though not an atomic one!

Note that \texttt{as.vector()} and \texttt{is.vector()} use different definitions of
``vector''!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.vector}\NormalTok{(}\KeywordTok{as.vector}\NormalTok{(mtcars))}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Compare and contrast \texttt{c()} and \texttt{unlist()} when combining a date and date-time into a single vector.

\textbf{{A}}: Date and date-time objects are both built upon doubles. While dates store the number of days since the reference date 1970-01-01 (also known as ``the Epoch'') in days, date-time-objects (POSIXct) store the time difference to this date in seconds.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date    <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"1970-01-02"}\NormalTok{)}
\NormalTok{dttm_ct <-}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"1970-01-01 01:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"UTC"}\NormalTok{)}

\CommentTok{# Internal representations}
\KeywordTok{unclass}\NormalTok{(date)}
\CommentTok{#> [1] 1}
\KeywordTok{unclass}\NormalTok{(dttm_ct)}
\CommentTok{#> [1] 3600}
\CommentTok{#> attr(,"tzone")}
\CommentTok{#> [1] "UTC"}
\end{Highlighting}
\end{Shaded}

As the \texttt{c()} generic only dispatches on its first argument, combining date and date-time objects via \texttt{c()} could lead to surprising results in older R versions (pre R 4.0.0):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Output in R 3.6.2}
\KeywordTok{c}\NormalTok{(date, dttm_ct)  }\CommentTok{# equal to c.Date(date, dttm_ct) }
\CommentTok{#> [1] "1970-01-02" "1979-11-10"}
\KeywordTok{c}\NormalTok{(dttm_ct, date)  }\CommentTok{# equal to c.POSIXct(date, dttm_ct)}
\CommentTok{#> [1] "1970-01-01 02:00:00 CET" "1970-01-01 01:00:01 CET"}
\end{Highlighting}
\end{Shaded}

In the first statement above \texttt{c.Date()} is executed, which incorrectly treats the underlying double of \texttt{dttm\_ct} (3600) as days instead of seconds. Conversely, when \texttt{c.POSIXct()} is called on a date, one day is counted as one second only.

We can highlight these mechanics by the following code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Output in R 3.6.2}
\KeywordTok{unclass}\NormalTok{(}\KeywordTok{c}\NormalTok{(date, dttm_ct))  }\CommentTok{# internal representation}
\CommentTok{#> [1] 1 3600}
\NormalTok{date }\OperatorTok{+}\StringTok{ }\DecValTok{3599}
\CommentTok{#> "1979-11-10"}
\end{Highlighting}
\end{Shaded}

As of R 4.0.0 these issues have been resolved and both methods now convert their input first into \texttt{POSIXct} and \texttt{Date} respectively.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(dttm_ct, date)}
\CommentTok{#> [1] "1970-01-01 02:00:00 CET" "1970-01-02 01:00:00 CET"}
\KeywordTok{unclass}\NormalTok{(}\KeywordTok{c}\NormalTok{(dttm_ct, date))}
\CommentTok{#> [1]  3600 86400}

\KeywordTok{c}\NormalTok{(date, dttm_ct)}
\CommentTok{#> [1] "1970-01-02" "1970-01-01"}
\KeywordTok{unclass}\NormalTok{(}\KeywordTok{c}\NormalTok{(date, dttm_ct))}
\CommentTok{#> [1] 1 0}
\end{Highlighting}
\end{Shaded}

However, as \texttt{c()} strips the time zone (and other attributes) of \texttt{POSIXct} objects, some caution is still recommended.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(dttm_ct <-}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"1970-01-01 01:00"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"HST"}\NormalTok{))}
\CommentTok{#> [1] "1970-01-01 01:00:00 HST"}
\KeywordTok{attributes}\NormalTok{(}\KeywordTok{c}\NormalTok{(dttm_ct))}
\CommentTok{#> $class}
\CommentTok{#> [1] "POSIXct" "POSIXt"}
\end{Highlighting}
\end{Shaded}

A package that deals with these kind of problems in more depth and provides a structural solution for them is the \href{https://github.com/r-lib/vctrs}{\texttt{\{vctrs\}} package} which is also used throughout the tidyverse.

Let's look at \texttt{unlist()}, which operates on list input.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Attributes are stripped}
\KeywordTok{unlist}\NormalTok{(}\KeywordTok{list}\NormalTok{(date, dttm_ct))  }
\CommentTok{#> [1]     1 39600}
\end{Highlighting}
\end{Shaded}

We see again that dates and date-times are internally stored as doubles. Unfortunately, this is all we are left with, when unlist strips the attributes of the list.

To summarise: \texttt{c()} coerces types and strips time zones. Errors may have occurred in older R versions because of inappropriate method dispatch/immature methods. \texttt{unlist()} strips attributes.

\hypertarget{data-frames-and-tibbles}{%
\section{Data frames and tibbles}\label{data-frames-and-tibbles}}

\textbf{{Q1}}: Can you have a data frame with zero rows? What about zero columns?

\textbf{{A}}: Yes, you can create these data frames easily; either during creation or via subsetting. Even both dimensions can be zero.

Create a 0-row, 0-column, or an empty data frame directly:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{integer}\NormalTok{(), }\DataTypeTok{b =} \KeywordTok{logical}\NormalTok{())}
\CommentTok{#> [1] a b}
\CommentTok{#> <0 rows> (or 0-length row.names)}

\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{row.names =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)  }\CommentTok{# or data.frame()[1:3, ]}
\CommentTok{#> data frame with 0 columns and 3 rows}

\KeywordTok{data.frame}\NormalTok{()}
\CommentTok{#> data frame with 0 columns and 0 rows}
\end{Highlighting}
\end{Shaded}

Create similar data frames via subsetting the respective dimension with either \texttt{0}, \texttt{NULL}, \texttt{FALSE} or a valid 0-length atomic (\texttt{logical(0)}, \texttt{character(0)}, \texttt{integer(0)}, \texttt{double(0)}). Negative integer sequences would also work. The following example uses a zero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\DecValTok{0}\NormalTok{, ]}
\CommentTok{#>  [1] mpg  cyl  disp hp   drat wt   qsec vs   am   gear carb}
\CommentTok{#> <0 rows> (or 0-length row.names)}

\NormalTok{mtcars[ , }\DecValTok{0}\NormalTok{]  }\CommentTok{# or mtcars[0]}
\CommentTok{#> data frame with 0 columns and 32 rows}

\NormalTok{mtcars[}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{]}
\CommentTok{#> data frame with 0 columns and 0 rows}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What happens if you attempt to set rownames that are not unique?

\textbf{{A}}: Matrices can have duplicated row names, so this does not cause problems.

Data frames, however, require unique rownames and you get different results depending on how you attempt to set them. If you set them directly or via \texttt{row.names()}, you
get an error:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{row.names =} \KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{, }\StringTok{"y"}\NormalTok{))}
\CommentTok{#> Error in data.frame(row.names = c("x", "y", "y")): duplicate}
\CommentTok{#> row.names: y}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{row.names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{, }\StringTok{"y"}\NormalTok{)}
\CommentTok{#> Warning: non-unique value when setting 'row.names': 'y'}
\CommentTok{#> Error in `.rowNamesDF<-`(x, value = value): duplicate 'row.names'}
\CommentTok{#> are not allowed}
\end{Highlighting}
\end{Shaded}

If you use subsetting, \texttt{{[}} automatically deduplicates:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{row.names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{, }\StringTok{"z"}\NormalTok{)}
\NormalTok{df[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\CommentTok{#>     x}
\CommentTok{#> x   1}
\CommentTok{#> x.1 1}
\CommentTok{#> x.2 1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: If \texttt{df} is a data frame, what can you say about \texttt{t(df)}, and \texttt{t(t(df))}? Perform some experiments, making sure to try different column types.

\textbf{{A}}: Both of \texttt{t(df)} and \texttt{t(t(df))} will return matrices:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\KeywordTok{is.matrix}\NormalTok{(df)}
\CommentTok{#> [1] FALSE}
\KeywordTok{is.matrix}\NormalTok{(}\KeywordTok{t}\NormalTok{(df))}
\CommentTok{#> [1] TRUE}
\KeywordTok{is.matrix}\NormalTok{(}\KeywordTok{t}\NormalTok{(}\KeywordTok{t}\NormalTok{(df)))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

The dimensions will respect the typical transposition rules:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dim}\NormalTok{(df)}
\CommentTok{#> [1] 3 2}
\KeywordTok{dim}\NormalTok{(}\KeywordTok{t}\NormalTok{(df))}
\CommentTok{#> [1] 2 3}
\KeywordTok{dim}\NormalTok{(}\KeywordTok{t}\NormalTok{(}\KeywordTok{t}\NormalTok{(df)))}
\CommentTok{#> [1] 3 2}
\end{Highlighting}
\end{Shaded}

Because the output is a matrix, every column is coerced to the same type. (It is implemented within \texttt{t.data.frame()} via \texttt{as.matrix()} which is described below).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}
\CommentTok{#>   x y}
\CommentTok{#> 1 1 a}
\CommentTok{#> 2 2 b}
\CommentTok{#> 3 3 c}
\KeywordTok{t}\NormalTok{(df)}
\CommentTok{#>   [,1] [,2] [,3]}
\CommentTok{#> x "1"  "2"  "3" }
\CommentTok{#> y "a"  "b"  "c"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: What does \texttt{as.matrix()} do when applied to a data frame with columns of different types? How does it differ from \texttt{data.matrix()}?

\textbf{{A}}: The type of the result of \texttt{as.matrix} depends on the types of the input columns (see \texttt{?as.matrix}):

\begin{quote}
The method for data frames will return a character matrix if there is only atomic columns and any non-(numeric/logical/complex) column, applying as.vector to factors and format to other non-character columns. Otherwise the usual coercion hierarchy (logical \textless{} integer \textless{} double \textless{} complex) will be used, e.g., all-logical data frames will be coerced to a logical matrix, mixed logical-integer will give a integer matrix, etc.
\end{quote}

On the other hand, \texttt{data.matrix} will always return a numeric matrix (see \texttt{?data.matrix()}).

\begin{quote}
Return the matrix obtained by converting all the variables in a data frame to numeric mode and then binding them together as the columns of a matrix. Factors and ordered factors are replaced by their internal codes. {[}\ldots{]} Character columns are first converted to factors and then to integers.
\end{quote}

We can illustrate and compare the mechanics of these functions using a concrete example. \texttt{as.matrix()} makes it possible to retrieve most of the original information from the data frame but leaves us with characters. To retrieve all information from \texttt{data.matrix()}'s output, we would need a lookup table for each column.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df_coltypes <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{),}
  \DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{),}
  \DataTypeTok{c =} \KeywordTok{c}\NormalTok{(1L, 0L),}
  \DataTypeTok{d =} \KeywordTok{c}\NormalTok{(}\FloatTok{1.5}\NormalTok{, }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{e =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"f1"}\NormalTok{, }\StringTok{"f2"}\NormalTok{))}
\NormalTok{)}

\KeywordTok{as.matrix}\NormalTok{(df_coltypes)}
\CommentTok{#>      a   b       c   d     e   }
\CommentTok{#> [1,] "a" "TRUE"  "1" "1.5" "f1"}
\CommentTok{#> [2,] "b" "FALSE" "0" "2.0" "f2"}
\KeywordTok{data.matrix}\NormalTok{(df_coltypes)}
\CommentTok{#>      a b c   d e}
\CommentTok{#> [1,] 1 1 1 1.5 1}
\CommentTok{#> [2,] 2 0 0 2.0 2}
\end{Highlighting}
\end{Shaded}

\hypertarget{subsetting}{%
\chapter{Subsetting}\label{subsetting}}

\stepcounter{section}

\hypertarget{selecting-multiple-elements}{%
\section{Selecting multiple elements}\label{selecting-multiple-elements}}

\textbf{{Q1}}: Fix each of the following common data frame subsetting errors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl =}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\CommentTok{# use `==`              (instead of `=`)}

\NormalTok{mtcars[}\OperatorTok{-}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, ]}
\CommentTok{# use `-(1:4)`          (instead of `-1:4`)}

\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{<=}\StringTok{ }\DecValTok{5}\NormalTok{]}
\CommentTok{# `,` is missing}

\NormalTok{mtcars[mtcars}\OperatorTok{$}\NormalTok{cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4} \OperatorTok{|}\StringTok{ }\DecValTok{6}\NormalTok{, ]}
\CommentTok{# use `mtcars$cyl == 6` (instead of `6`)}
\CommentTok{#  or `%in% c(4, 6)`    (instead of `== 4 | 6`)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Why does the following code yield five missing values? (Hint: why is it different from \texttt{x{[}NA\_real\_{]}}?)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\NormalTok{x[}\OtherTok{NA}\NormalTok{]}
\CommentTok{#> [1] NA NA NA NA NA}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In contrast to \texttt{NA\_real}, \texttt{NA} has logical type and logical vectors are recycled to the same length as the vector being subset, i.e.~\texttt{x{[}NA{]}} is recycled to \texttt{x{[}NA,\ NA,\ NA,\ NA,\ NA{]}}.

\textbf{{Q3}}: What does \texttt{upper.tri()} return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{outer}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{FUN =} \StringTok{"*"}\NormalTok{)}
\NormalTok{x[}\KeywordTok{upper.tri}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{upper.tri(x)} returns a logical matrix, which contains \texttt{TRUE} values above the diagonal and \texttt{FALSE} values everywhere else. In \texttt{upper.tri()} the positions for \texttt{TRUE} and \texttt{FALSE} values are determined by comparing \texttt{x}'s row and column indices via \texttt{.row(dim(x))\ \textless{}\ .col(dim(x))}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}
\CommentTok{#>      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{#> [1,]    1    2    3    4    5}
\CommentTok{#> [2,]    2    4    6    8   10}
\CommentTok{#> [3,]    3    6    9   12   15}
\CommentTok{#> [4,]    4    8   12   16   20}
\CommentTok{#> [5,]    5   10   15   20   25}
\KeywordTok{upper.tri}\NormalTok{(x)}
\CommentTok{#>       [,1]  [,2]  [,3]  [,4]  [,5]}
\CommentTok{#> [1,] FALSE  TRUE  TRUE  TRUE  TRUE}
\CommentTok{#> [2,] FALSE FALSE  TRUE  TRUE  TRUE}
\CommentTok{#> [3,] FALSE FALSE FALSE  TRUE  TRUE}
\CommentTok{#> [4,] FALSE FALSE FALSE FALSE  TRUE}
\CommentTok{#> [5,] FALSE FALSE FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

When subsetting with logical matrices, all elements that correspond to \texttt{TRUE} will be selected. Matrices extend vectors with a dimension attribute, so the vector forms of subsetting can be used (including logical subsetting). We should take care, that the dimensions of the subsetting matrix match the object of interest --- otherwise unintended selections due to vector recycling may occur. Please also note, that this form of subsetting returns a vector instead of a matrix, as the subsetting alters the dimensions of the object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[}\KeywordTok{upper.tri}\NormalTok{(x)]}
\CommentTok{#>  [1]  2  3  6  4  8 12  5 10 15 20}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Why does \texttt{mtcars{[}1:20{]}} return an error? How does it differ from the similar \texttt{mtcars{[}1:20,\ {]}}?

\textbf{{A}}: When subsetting a data frame with a single vector, it behaves the same way as subsetting a list of columns. So, \texttt{mtcars{[}1:20{]}} would return a data frame containing the first 20 columns of the dataset. However, as \texttt{mtcars} has only 11 columns, the index will be out of bounds and an error is thrown. \texttt{mtcars{[}1:20,\ {]}} is subsetted with two vectors, so 2d subsetting kicks in, and the first index refers to rows.

\textbf{{Q5}}: Implement your own function that extracts the diagonal entries from a matrix (it should behave like \texttt{diag(x)} where \texttt{x} is a matrix).

\textbf{{A}}: The elements in the diagonal of a matrix have the same row- and column indices. This characteristic can be used to create a suitable numeric matrix used for subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{diag2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{min}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(x), }\KeywordTok{ncol}\NormalTok{(x))}
\NormalTok{  idx <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(}\KeywordTok{seq_len}\NormalTok{(n), }\KeywordTok{seq_len}\NormalTok{(n))}

\NormalTok{  x[idx]}
\NormalTok{\}}

\CommentTok{# Let's check if it works}
\NormalTok{(x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{30}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\CommentTok{#>      [,1] [,2] [,3] [,4] [,5] [,6]}
\CommentTok{#> [1,]    1    6   11   16   21   26}
\CommentTok{#> [2,]    2    7   12   17   22   27}
\CommentTok{#> [3,]    3    8   13   18   23   28}
\CommentTok{#> [4,]    4    9   14   19   24   29}
\CommentTok{#> [5,]    5   10   15   20   25   30}

\KeywordTok{diag}\NormalTok{(x)}
\CommentTok{#> [1]  1  7 13 19 25}
\KeywordTok{diag2}\NormalTok{(x)}
\CommentTok{#> [1]  1  7 13 19 25}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: What does \texttt{df{[}is.na(df){]}\ \textless{}-\ 0} do? How does it work?

\textbf{{A}}: This expression replaces the \texttt{NA}s in \texttt{df} with \texttt{0}. Here \texttt{is.na(df)} returns a logical matrix that encodes the position of the missing values in \texttt{df}. Subsetting and assignment are then combined to replace only the missing values.

\hypertarget{selecting-a-single-element}{%
\section{Selecting a single element}\label{selecting-a-single-element}}

\textbf{{Q1}}: Brainstorm as many ways as possible to extract the third value from the \texttt{cyl} variable in the \texttt{mtcars} dataset.

\textbf{{A}}: Base R already provides an abundance of possibilities:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Select column first}
\NormalTok{mtcars}\OperatorTok{$}\NormalTok{cyl[[}\DecValTok{3}\NormalTok{]]}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[ , }\StringTok{"cyl"}\NormalTok{][[}\DecValTok{3}\NormalTok{]]}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[[}\StringTok{"cyl"}\NormalTok{]][[}\DecValTok{3}\NormalTok{]]}
\CommentTok{#> [1] 4}
\KeywordTok{with}\NormalTok{(mtcars, cyl[[}\DecValTok{3}\NormalTok{]])}
\CommentTok{#> [1] 4}

\CommentTok{# Select row first}
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, ]}\OperatorTok{$}\NormalTok{cyl}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, }\StringTok{"cyl"}\NormalTok{]}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, ][ , }\StringTok{"cyl"}\NormalTok{]}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, ][[}\StringTok{"cyl"}\NormalTok{]]}
\CommentTok{#> [1] 4}

\CommentTok{# Select simultaneously}
\NormalTok{mtcars[}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{]}
\CommentTok{#> [1] 4}
\NormalTok{mtcars[[}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]]}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Given a linear model, e.g.~\texttt{mod\ \textless{}-\ lm(mpg\ \textasciitilde{}\ wt,\ data\ =\ mtcars)}, extract the residual degrees of freedom. Extract the R squared from the model summary (\texttt{summary(mod)}).

\textbf{{A}}: \texttt{mod} is of type list, which opens up several possibilities. We us \texttt{\$} or \texttt{{[}{[}} to extract a single element:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =}\NormalTok{ mtcars)}

\NormalTok{mod}\OperatorTok{$}\NormalTok{df.residual}
\CommentTok{#> [1] 30}
\NormalTok{mod[[}\StringTok{"df.residual"}\NormalTok{]]}
\CommentTok{#> [1] 30}
\end{Highlighting}
\end{Shaded}

The same also applies to \texttt{summary(mod)}, so we could use e.g.:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(mod)}\OperatorTok{$}\NormalTok{r.squared}
\CommentTok{#> [1] 0.753}
\end{Highlighting}
\end{Shaded}

(Tip: The \href{https://github.com/tidymodels/broom}{\texttt{\{broom\}} package} provides a very useful approach to work with models in a tidy way.)

\stepcounter{section}

\hypertarget{applications}{%
\section{Applications}\label{applications}}

\textbf{{Q1}}: How would you randomly permute the columns of a data frame? (This is an important technique in random forests.) Can you simultaneously permute the rows and columns in one step?

\textbf{{A}}: This can be achieved by combining \texttt{{[}} and \texttt{sample()}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Permute columns}
\NormalTok{mtcars[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{ncol}\NormalTok{(mtcars))]}

\CommentTok{# Permute columns and rows in one step}
\NormalTok{mtcars[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(mtcars)), }\KeywordTok{sample}\NormalTok{(}\KeywordTok{ncol}\NormalTok{(mtcars))]}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: How would you select a random sample of \texttt{m} rows from a data frame? What if the sample had to be contiguous (i.e., with an initial row, a final row, and every row in between)?

\textbf{{A}}: Selecting \texttt{m} random rows from a data frame can be achieved through subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\DecValTok{10}
\NormalTok{mtcars[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(mtcars), m), ]}
\end{Highlighting}
\end{Shaded}

Holding successive lines together as a blocked sample requires only a certain amount of caution in order to obtain the correct start and end index.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{start <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(mtcars) }\OperatorTok{-}\StringTok{ }\NormalTok{m }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\NormalTok{end <-}\StringTok{ }\NormalTok{start }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\NormalTok{mtcars[start}\OperatorTok{:}\NormalTok{end, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: How could you put the columns in a data frame in alphabetical order?

\textbf{{A}}: We combine \texttt{{[}} with \texttt{order()} or \texttt{sort()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[}\KeywordTok{order}\NormalTok{(}\KeywordTok{names}\NormalTok{(mtcars))]}
\NormalTok{mtcars[}\KeywordTok{sort}\NormalTok{(}\KeywordTok{names}\NormalTok{(mtcars))]}
\end{Highlighting}
\end{Shaded}

\hypertarget{control-flow}{%
\chapter{Control flow}\label{control-flow}}

\stepcounter{section}

\hypertarget{choices}{%
\section{Choices}\label{choices}}

\textbf{{Q1}}: What type of vector does each of the following calls to \texttt{ifelse()} return?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\KeywordTok{ifelse}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\KeywordTok{ifelse}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Read the documentation and write down the rules in your own words.

\textbf{{A}}: The arguments of \texttt{ifelse()} are named \texttt{test}, \texttt{yes} and \texttt{no}. In general, \texttt{ifelse()} returns the entry for \texttt{yes} when \texttt{test} is \texttt{TRUE}, the entry for \texttt{no} when \texttt{test} is \texttt{FALSE} and \texttt{NA} when \texttt{test} is \texttt{NA}. Therefore, the expressions above return vectors of type \texttt{double} (\texttt{1}), \texttt{character} (\texttt{"no"}) and \texttt{logical} (\texttt{NA}).

To be a little more precise, we will cite the part of the documentation on the return value of \texttt{ifelse()}:

\begin{quote}
A vector of the same length and attributes (including dimensions and ``class'') as test and data values from the values of yes or no. The mode of the answer will be coerced from logical to accommodate first any values taken from yes and then any values taken from no.
\end{quote}

This is surprising because it uses the type of \texttt{test}. In practice this means, that \texttt{test} is first converted to logical and if the result is neither \texttt{TRUE} nor \texttt{FALSE}, simply \texttt{as.logical(test)} is returned.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{logical}\NormalTok{(), }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\CommentTok{#> logical(0)}
\KeywordTok{ifelse}\NormalTok{(}\OtherTok{NaN}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\CommentTok{#> [1] NA}
\KeywordTok{ifelse}\NormalTok{(}\OtherTok{NA_character_}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\CommentTok{#> [1] NA}
\KeywordTok{ifelse}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\CommentTok{#> [1] NA}
\KeywordTok{ifelse}\NormalTok{(}\StringTok{"true"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\StringTok{"no"}\NormalTok{)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Why does the following code work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x)) }\StringTok{"not empty"} \ControlFlowTok{else} \StringTok{"empty"}
\CommentTok{#> [1] "not empty"}

\NormalTok{x <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{()}
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x)) }\StringTok{"not empty"} \ControlFlowTok{else} \StringTok{"empty"}
\CommentTok{#> [1] "empty"}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{if()} expects a logical condition, but also accepts a numeric vector where \texttt{0} is treated as \texttt{FALSE} and all other numbers are treated as \texttt{TRUE}. Numerical missing values (including \texttt{NaN}) lead to an error in the same way that a logical missing, \texttt{NA}, does.

\hypertarget{loops}{%
\section{Loops}\label{loops}}

\textbf{{Q1}}: Why does this code succeed without errors or warnings?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{()}
\NormalTok{out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\NormalTok{  out[i] <-}\StringTok{ }\NormalTok{x[i] }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\NormalTok{out}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: This loop is a delicate issue, and we have to consider a few points to explain why it is evaluated without raising any errors or warnings.

The beginning of this code smell is the statement \texttt{1:length(x)} which creates the index of the for loop. As \texttt{x} has length 0 \texttt{1:length(x)} counts down from 1 to 0. This issue is typically avoided via usage of \texttt{seq\_along(x)} or similar helpers which would just generate \texttt{integer(0)} in this case.

As we use \texttt{{[}\textless{}-} and \texttt{{[}} for indexing 0-length vectors at their first and zeroth position, we need to be aware of their subsetting behaviour for out-of-bounds and zero indices.

During the first iteration \texttt{x{[}1{]}} will generate an \texttt{NA} (out-of-bounds indexing for atomics). The resulting \texttt{NA} (from squaring) will be assigned to the empty length-1 list \texttt{out{[}1{]}} (out-of-bounds indexing for lists).

In the next iteration, \texttt{x{[}0{]}} will return \texttt{numeric(0)} (zero indexing for atomics). Again, squaring doesn't change the value and \texttt{numeric(0)} is assigned to \texttt{out{[}0{]}} (zero indexing for lists). Assigning a 0-length vector to a 0-length subset works but doesn't change the object.

Overall, the code works, because each step includes valid R operations (even though the result may not be what the user intended).

\textbf{{Q2}}: When the following code is evaluated, what can you say about the vector being iterated?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\ControlFlowTok{for}\NormalTok{ (x }\ControlFlowTok{in}\NormalTok{ xs) \{}
\NormalTok{  xs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(xs, x }\OperatorTok{*}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\NormalTok{xs}
\CommentTok{#> [1] 1 2 3 2 4 6}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In this loop \texttt{x} takes on the values of the initial \texttt{xs} (\texttt{1}, \texttt{2} and \texttt{3}), indicating that it is evaluated just once in the beginning of the loop, not after each iteration. (Otherwise, we would run into an infinite loop.)

\textbf{{Q3}}: What does the following code tell you about when the index is updated?

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{) \{}
\NormalTok{  i <-}\StringTok{ }\NormalTok{i }\OperatorTok{*}\StringTok{ }\DecValTok{2}
  \KeywordTok{print}\NormalTok{(i) }
\NormalTok{\}}
\CommentTok{#> [1] 2}
\CommentTok{#> [1] 4}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In a for loop the index is updated in the beginning of each iteration. Therefore, reassigning the index symbol during one iteration doesn't affect the following iterations. (Again, we would otherwise run into an infinite loop.)

\hypertarget{functions}{%
\chapter{Functions}\label{functions}}

\stepcounter{section}

\hypertarget{function-fundamentals}{%
\section{Function fundamentals}\label{function-fundamentals}}

\textbf{{Q1}}: Given a name, like \texttt{"mean"}, \texttt{match.fun()} lets you find a function. Given a function, can you find its name? Why doesn't that make sense in R?

\textbf{{A}}: In R there is no one-to-one mapping between functions and names. A name always points to a single object, but an object may have zero, one or many names.

Let's look at an example:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sd}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\CommentTok{#> function(x) sd(x) / mean(x)}

\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{(}\KeywordTok{max}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\KeywordTok{min}\NormalTok{(x))}
\NormalTok{f2 <-}\StringTok{ }\NormalTok{f1}
\NormalTok{f3 <-}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

While the function in the first line is not bound to a name multiple names (\texttt{f1}, \texttt{f2} and \texttt{f3}) point to the second function. So, the main point is that the relation between name and object is only clearly defined in one direction.

Besides that, there are obviously ways to search for function names. However, to be sure to find the right one(s), you should not only compare the code (body) but also the arguments (formals) and the creation environment. As \texttt{formals()}, \texttt{body()} and \texttt{environment()} all return \texttt{NULL} for primitive functions, the easiest way to check if two functions are exactly equal is just to use \texttt{identical()}.

\textbf{{Q2}}: It's possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{3}\NormalTok{()}
\CommentTok{#> function(x) 3()}
\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{3}\NormalTok{)()}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The second approach is correct.

The anonymous function \texttt{function(x)\ 3} is surrounded by a pair of parentheses before it is called by \texttt{()}. These extra parentheses separate the function call from the anonymous function's body. Without them a function with the invalid body \texttt{3()} is returned, which throws an error when we call it. This is easier to see if we name the function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\DecValTok{3}\NormalTok{()}
\NormalTok{f}
\CommentTok{#> function(x) 3()}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> Error in f(): attempt to apply non-function}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: A good rule of thumb is that an anonymous function should fit on one line and shouldn't need to use \texttt{\{\}}. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

\textbf{{A}}: The use of anonymous functions allows concise and elegant code in certain situations. However, they miss a descriptive name and when re-reading the code, it can take a while to figure out what they do. That's why it's helpful to give long and complex functions a descriptive name. It may be worthwhile to take a look at your own projects or other people's code to reflect on this part of your coding style.

\textbf{{Q4}}: What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

\textbf{{A}}: Use \texttt{is.function()} to test if an object is a function. Consider using \texttt{is.primitive()} to test specifically for primitive functions.

\textbf{{Q5}}: This code makes a list of all functions in the \texttt{\{base\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objs <-}\StringTok{ }\KeywordTok{mget}\NormalTok{(}\KeywordTok{ls}\NormalTok{(}\StringTok{"package:base"}\NormalTok{, }\DataTypeTok{all =} \OtherTok{TRUE}\NormalTok{), }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{funs <-}\StringTok{ }\KeywordTok{Filter}\NormalTok{(is.function, objs)}
\end{Highlighting}
\end{Shaded}

Use it to answer the following questions:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\item
  Which base function has the most arguments?
\item
  How many base functions have no arguments? What's special about those functions?
\item
  How could you adapt the code to find all primitive functions?
\end{enumerate}

\textbf{{A}}: Let's look at each sub-question separately:

\begin{enumerate}
\def\labelenumi{\alph{enumi}.}
\item
  To find the function with the most arguments, we first compute the length of \texttt{formals()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}

\NormalTok{n_args <-}\StringTok{ }\NormalTok{funs }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(formals) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{map_int}\NormalTok{(length)}
\end{Highlighting}
\end{Shaded}

  Then we sort \texttt{n\_args} in decreasing order and look at its first entries.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n_args }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{sort}\NormalTok{(}\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\CommentTok{#>             scan   format.default           source          formatC }
\CommentTok{#>               22               16               16               15 }
\CommentTok{#>          library merge.data.frame }
\CommentTok{#>               13               13}
\end{Highlighting}
\end{Shaded}
\item
  We can further use \texttt{n\_args} to find the number of functions with no arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(n_args }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#> [1] 250}
\end{Highlighting}
\end{Shaded}

  However, this over counts because \texttt{formals()} returns \texttt{NULL} for primitive functions, and \texttt{length(NULL)} is 0. To fix this, we can first remove the primitive functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n_args2 <-}\StringTok{ }\NormalTok{funs }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{discard}\NormalTok{(is.primitive) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(formals) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{map_int}\NormalTok{(length)}

\KeywordTok{sum}\NormalTok{(n_args2 }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#> [1] 49}
\end{Highlighting}
\end{Shaded}

  Indeed, most of the functions with no arguments are actually primitive functions.
\item
  To find all primitive functions, we can change the predicate in \texttt{Filter()} from \texttt{is.function()} to \texttt{is.primitive()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs <-}\StringTok{ }\KeywordTok{Filter}\NormalTok{(is.primitive, objs)}
\KeywordTok{length}\NormalTok{(funs)}
\CommentTok{#> [1] 201}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\textbf{{Q6}}: What are the three important components of a function?

\textbf{{A}}: These components are the function's \texttt{body()}, \texttt{formals()} and \texttt{environment()}. However, as mentioned in Advanced R:

\begin{quote}
There is one exception to the rule that functions have three components. Primitive functions, like \texttt{sum()}, call C code directly with \texttt{.Primitive()} and contain no R code. Therefore, their \texttt{formals()}, \texttt{body()}, and \texttt{environment()} are all \texttt{NULL}.
\end{quote}

\textbf{{Q7}}: When does printing a function not show what environment it was created in?

\textbf{{A}}: Primitive functions and functions created in the global environment do not print their environment.

\stepcounter{section}

\hypertarget{lexical-scoping}{%
\section{Lexical Scoping}\label{lexical-scoping}}

\textbf{{Q1}}: What does the following code return? Why? Describe how each of the three \texttt{c}'s is interpreted.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\DecValTok{10}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{c =}\NormalTok{ c)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: This code returns a named numeric vector of length one --- with one element of the value \texttt{10} and the name \texttt{"c"}. The first \texttt{c} represents the \texttt{c()} function, the second \texttt{c} is interpreted as a (quoted) name and the third \texttt{c} as a value.

\textbf{{Q2}}: What are the four principles that govern how R looks for values?

\textbf{{A}}: R's \href{https://adv-r.hadley.nz/functions.html\#lexical-scoping}{lexical scoping} rules are based on these four principles:

\begin{itemize}
\tightlist
\item
  \href{https://adv-r.hadley.nz/functions.html\#name-masking}{Name masking}
\item
  \href{https://adv-r.hadley.nz/functions.html\#functions-versus-variables}{Functions vs.~variables}
\item
  \href{https://adv-r.hadley.nz/functions.html\#fresh-start}{A fresh start}
\item
  \href{https://adv-r.hadley.nz/functions.html\#dynamic-lookup}{Dynamic lookup}
\end{itemize}

\textbf{{Q3}}: What does the following function return? Make a prediction before running the code yourself.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{    f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{      x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{    \}}
    \KeywordTok{f}\NormalTok{() }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  \}}
  \KeywordTok{f}\NormalTok{(x) }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Within this nested function two more functions also named \texttt{f} are defined and called. Because the functions are each executed in their own environment R will look up and use the functions defined last in these environments. The innermost \texttt{f()} is called last, though it is the first function to return a value. Therefore, the order of the calculation passes ``from the inside to the outside'' and the function returns \texttt{((10\ \^{}\ 2)\ +\ 1)\ *\ 2}, i.e.~202.

\hypertarget{lazy-evaluation}{%
\section{Lazy evaluation}\label{lazy-evaluation}}

\textbf{{Q1}}: What important property of \texttt{\&\&} makes \texttt{x\_ok()} work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_ok <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{&&}\StringTok{ }\NormalTok{x }\OperatorTok{>}\StringTok{ }\DecValTok{0}
\NormalTok{\}}

\KeywordTok{x_ok}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

What is different with this code? Why is this behaviour undesirable here?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_ok <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \OperatorTok{!}\KeywordTok{is.null}\NormalTok{(x) }\OperatorTok{&}\StringTok{ }\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{&}\StringTok{ }\NormalTok{x }\OperatorTok{>}\StringTok{ }\DecValTok{0}
\NormalTok{\}}

\KeywordTok{x_ok}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\CommentTok{#> logical(0)}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{x_ok}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] FALSE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In summary: \texttt{\&\&} short-circuits which means that if the left-hand side is \texttt{FALSE} it doesn't evaluate the right-hand side (because it doesn't matter). Similarly, if the left-hand side of \texttt{\textbar{}\textbar{}} is \texttt{TRUE} it doesn't evaluate the right-hand side.

We expect \texttt{x\_ok()} to validate its input via certain criteria: it must not be \texttt{NULL}, have length \texttt{1} and be greater than \texttt{0}. Meaningful outcomes for this assertion will be \texttt{TRUE}, \texttt{FALSE} or \texttt{NA}. The desired behaviour is reached by combining the assertions through \texttt{\&\&} instead of \texttt{\&}.

\texttt{\&\&} does not perform elementwise comparisons, instead it uses the first element of each value only. It also uses lazy evaluation, in the sense that evaluation ``proceeds only until the result is determined'' (from \texttt{?Logic}). This means that the RHS of \texttt{\&\&} won't be evaluated if the LHS already determines the outcome of the comparison (e.g.~evaluate to \texttt{FALSE}). This behaviour is also known as ``short-circuiting''.
For some situations (\texttt{x\ =\ 1}) both operators will lead to the same result. But this is not always the case. For \texttt{x\ =\ NULL}, the \texttt{\&\&}-operator will stop after the \texttt{!is.null} statement and return the result. The following conditions won't even be evaluated! (If the other conditions are also evaluated (by the use of \texttt{\&}), the outcome would change. \texttt{NULL\ \textgreater{}\ 0} returns \texttt{logical(0)}, which is not helpful in this case.)

We can also see the difference in behaviour, when we set \texttt{x\ =\ 1:3}. The \texttt{\&\&}-operator returns the result from \texttt{length(x)\ ==\ 1}, which is \texttt{FALSE}. Using \texttt{\&} as the logical operator leads to the (vectorised) \texttt{x\ \textgreater{}\ 0} condition being evaluated and also returned.

\textbf{{Q2}}: What does this function return? Why? Which principle does it illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ z) \{}
\NormalTok{  z <-}\StringTok{ }\DecValTok{100}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The function returns 100. The default argument (\texttt{x\ =\ z}) gets lazily evaluated within the function environment when \texttt{x} gets accessed. At this time \texttt{z} has already been bound to the value \texttt{100}. The illustrated principle here is \emph{lazy evaluation}.

\textbf{{Q3}}: What does this function return? Why? Which principle does it illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{10}
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ \{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{()}
\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The function returns \texttt{c(2,\ 1)} which is due to \emph{name masking}. When \texttt{x} is accessed within \texttt{c()}, the promise \texttt{x\ =\ \{y\ \textless{}-\ 1;\ 2\}} is evaluated inside \texttt{f1()}'s environment. \texttt{y} gets bound to the value \texttt{1} and the return value of \texttt{\{()} (\texttt{2}) gets assigned to \texttt{x}. When \texttt{y} gets accessed next within \texttt{c()}, it has already the value \texttt{1} and R doesn't need to look it up any further. Therefore, the promise \texttt{y\ =\ 0} won't be evaluated. Also, as \texttt{y} is assigned within \texttt{f1()}'s environment, the value of the global variable \texttt{y} is left untouched.

\textbf{{Q4}}: In \texttt{hist()}, the default value of \texttt{xlim} is \texttt{range(breaks)}, the default value for \texttt{breaks} is \texttt{"Sturges"}, and

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{range}\NormalTok{(}\StringTok{"Sturges"}\NormalTok{)}
\CommentTok{#> [1] "Sturges" "Sturges"}
\end{Highlighting}
\end{Shaded}

Explain how \texttt{hist()} works to get a correct \texttt{xlim} value.

\textbf{{A}}: The \texttt{xlim} argument of \texttt{hist()} defines the range of the histogram's x-axis. In order to provide a valid axis \texttt{xlim} must contain a numeric vector of exactly two unique values. Consequently, for the default \texttt{xlim\ =\ range(breaks)}), \texttt{breaks} must evaluate to a vector with at least two unique values.

During execution \texttt{hist()} overwrites the \texttt{breaks} argument. The \texttt{breaks} argument is quite flexible and allows the users to provide the breakpoints directly or compute them in several ways. Therefore, the specific behaviour depends highly on the input. But \texttt{hist} ensures that \texttt{breaks} evaluates to a numeric vector containing at least two unique elements before \texttt{xlim} is computed.

\textbf{{Q5}}: Explain why this function works. Why is it confusing?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_time <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{stop}\NormalTok{(}\StringTok{"Error!"}\NormalTok{)) \{}
\NormalTok{  stop <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{Sys.time}\NormalTok{()}
  \KeywordTok{print}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{show_time}\NormalTok{()}
\CommentTok{#> [1] "2020-12-17 13:38:07 CET"}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Before \texttt{show\_time()} accesses \texttt{x} (default \texttt{stop("Error")}), the \texttt{stop()} function is masked by \texttt{function(...)\ Sys.time()}. As default arguments are evaluated in the function environment, \texttt{print(x)} will be evaluated as \texttt{print(Sys.time())}.

This function is confusing because its behaviour changes when \texttt{x}'s value is supplied directly. Now the value from the calling environment will be used and the overwriting of \texttt{stop()} won't affect \texttt{x} anymore.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{show_time}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{stop}\NormalTok{(}\StringTok{"Error!"}\NormalTok{))}
\CommentTok{#> Error in print(x): Error!}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: How many arguments are required when calling \texttt{library()}?

\textbf{{A}}: \texttt{library()} doesn't require any arguments. When called without arguments \texttt{library()} invisibly returns a list of class \texttt{libraryIQR}, which contains a results matrix with one row and three columns per installed package. These columns contain entries for the name of the package (``Package''), the path to the package (``LibPath'') and the title of the package (``Title''). \texttt{library()} also has its own print method (\texttt{print.libraryIQR()}), which displays this information conveniently in its own window.

This behaviour is also documented under the details section of its help page (\texttt{?library}):

\begin{quote}
If library is called with no package or help argument, it lists all available packages in the libraries specified by lib.loc, and returns the corresponding information in an object of class ``libraryIQR''. (The structure of this class may change in future versions.) Use .packages(all = TRUE) to obtain just the names of all available packages, and installed.packages() for even more information.
\end{quote}

Because the \texttt{package} and \texttt{help} argument from \texttt{library()} do not show a default value, it's easy to overlook the possibility to call \texttt{library()} without these arguments. (Instead of providing \texttt{NULL}s as default values \texttt{library()} uses \texttt{missing()} to check if these arguments were provided.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{formals}\NormalTok{(library))}
\CommentTok{#> Dotted pair list of 13}
\CommentTok{#>  $ package        : symbol }
\CommentTok{#>  $ help           : symbol }
\CommentTok{#>  $ pos            : num 2}
\CommentTok{#>  $ lib.loc        : NULL}
\CommentTok{#>  $ character.only : logi FALSE}
\CommentTok{#>  $ logical.return : logi FALSE}
\CommentTok{#>  $ warn.conflicts : symbol }
\CommentTok{#>  $ quietly        : logi FALSE}
\CommentTok{#>  $ verbose        : language getOption("verbose")}
\CommentTok{#>  $ mask.ok        : symbol }
\CommentTok{#>  $ exclude        : symbol }
\CommentTok{#>  $ include.only   : symbol }
\CommentTok{#>  $ attach.required: language missing(include.only)}
\end{Highlighting}
\end{Shaded}

\hypertarget{dot-dot-dot}{%
\section{\texorpdfstring{\texttt{...} (dot-dot-dot)}{... (dot-dot-dot)}}\label{dot-dot-dot}}

\textbf{{Q1}}: Explain the following results:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 6}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 1}

\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{na.omit =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 7}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{na.omit =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let's inspect the arguments and their order for both functions. For \texttt{sum()} these are \texttt{...} and \texttt{na.rm}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(sum)}
\CommentTok{#> function (..., na.rm = FALSE)}
\end{Highlighting}
\end{Shaded}

For the \texttt{...} argument \texttt{sum()} expects numeric, complex, or logical vector input (see \texttt{?sum}). Unfortunately, when \texttt{...} is used, misspelled arguments (!) like \texttt{na.omit} won't raise an error (in case of no further input checks). So instead, \texttt{na.omit} is treated as a logical and becomes part of the \texttt{...} argument. It will be coerced to \texttt{1} and be part of the sum. All other arguments are left unchanged. Therefore \texttt{sum(1,\ 2,\ 3)} returns \texttt{6} and \texttt{sum(1,\ 2,\ 3,\ na.omit\ =\ TRUE)} returns \texttt{7}.

In contrast, the generic function \texttt{mean()} expects \texttt{x}, \texttt{trim}, \texttt{na.rm} and \texttt{...} for its default method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(mean.default)}
\CommentTok{#> function (x, trim = 0, na.rm = FALSE, ...)}
\end{Highlighting}
\end{Shaded}

As \texttt{na.omit} is not one of \texttt{mean()}'s named arguments (\texttt{x}; and no candidate for partial matching), \texttt{na.omit} again becomes part of the \texttt{...} argument. However, in contrast to \texttt{sum()} the elements of \texttt{...} are not ``part'' of the mean. The other supplied arguments are matched by their order, i.e.~\texttt{x\ =\ 1}, \texttt{trim\ =\ 2} and \texttt{na.rm\ =\ 3}. As \texttt{x} is of length 1 and not \texttt{NA}, the settings of \texttt{trim} and \texttt{na.rm} do not affect the calculation of the mean. Both calls (\texttt{mean(1,\ 2,\ 3)} and \texttt{mean(1,\ 2,\ 3,\ na.omit\ =\ TRUE)}) return \texttt{1}.

\textbf{{Q2}}: Explain how to find the documentation for the named arguments in the following function call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{20}\NormalTok{, }\DataTypeTok{xlab =} \StringTok{"x"}\NormalTok{, }\DataTypeTok{col.lab =} \StringTok{"blue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{06_Functions_files/figure-latex/unnamed-chunk-24-1} \end{center}

\textbf{{A}}: First we type \texttt{?plot} in the console and check the ``Usage'' section which contains:

\begin{verbatim}
plot(x, y, ...)
\end{verbatim}

The arguments we want to learn more about (\texttt{col}, \texttt{pch}, \texttt{xlab}, \texttt{col.lab}) are part of the \texttt{...} argument. There we can find information for the \texttt{xlab} argument and a recommendation to visit \texttt{?par} for the other arguments. Under \texttt{?par} we type ``col'' into the search bar, which leads us to the section ``Color Specification''. We also search for the \texttt{pch} argument, which leads to the recommendation to check \texttt{?points}. Finally, \texttt{col.lab} is also directly documented within \texttt{?par}.

\textbf{{Q3}}: Why does \texttt{plot(1:10,\ col\ =\ "red")} only colour the points, not the axes or labels? Read the source code of \texttt{plot.default()} to find out.

\textbf{{A}}: To learn about the internals of \texttt{plot.default()} we add \texttt{browser()} to the first line of the code and interactively run \texttt{plot(1:10,\ col\ =\ "red")}. This way we can see how the plot is build and learn where the axes are added.

This leads us to the function call

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{localTitle}\NormalTok{(}\DataTypeTok{main =}\NormalTok{ main, }\DataTypeTok{sub =}\NormalTok{ sub, }\DataTypeTok{xlab =}\NormalTok{ xlab, }\DataTypeTok{ylab =}\NormalTok{ ylab, ...)}
\end{Highlighting}
\end{Shaded}

The \texttt{localTitle()} function was defined in the first lines of \texttt{plot.default()} as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{localTitle <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(..., col, bg, pch, cex, lty, lwd) }\KeywordTok{title}\NormalTok{(...)}
\end{Highlighting}
\end{Shaded}

The call to \texttt{localTitle()} passes the \texttt{col} parameter as part of \texttt{...} argument to \texttt{title()}. \texttt{?title} tells us that the \texttt{title()} function specifies four parts of the plot: Main (title of the plot), sub (sub-title of the plot) and both axis labels. Therefore, it would introduce ambiguity inside \texttt{title()} to use \texttt{col} directly. Instead, one has the option to supply \texttt{col} via the \texttt{...} argument, via \texttt{col.lab} or as part of \texttt{xlab} in the form \texttt{xlab\ =\ list(c("index"),\ col\ =\ "red")} (similar for \texttt{ylab}).

\hypertarget{exiting-a-function}{%
\section{Exiting a function}\label{exiting-a-function}}

\textbf{{Q1}}: What does \texttt{load()} return? Why don't you normally see these values?

\textbf{{A}}: \texttt{load()} loads objects saved to disk in \texttt{.Rdata} files by \texttt{save()}. When run successfully, \texttt{load()} invisibly returns a character vector containing the names of the newly loaded objects. To print these names to the console, one can set the argument \texttt{verbose} to \texttt{TRUE} or surround the call in parentheses to trigger R's auto-printing mechanism.

\textbf{{Q2}}: What does \texttt{write.table()} return? What would be more useful?

\textbf{{A}}: \texttt{write.table()} writes an object, usually a data frame or a matrix, to disk. The function invisibly returns \texttt{NULL}. It would be more useful if \texttt{write.table()} would (invisibly) return the input data, \texttt{x}. This would allow to save intermediate results and directly take on further processing steps without breaking the flow of the code (i.e.~breaking it into different lines). One package which uses this pattern is the \texttt{\{readr\}} package, which is part of the \href{https://www.tidyverse.org/}{tidyverse}-ecosystem.

\textbf{{Q3}}: How does the \texttt{chdir} parameter of \texttt{source()} compare to \texttt{with\_dir()}? Why might you prefer one to the other?

\textbf{{A}}: The \texttt{with\_dir()} approach was given in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with_dir <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(dir, code) \{}
\NormalTok{  old <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old))}
  
  \KeywordTok{force}\NormalTok{(code)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{with\_dir()} takes a path for a working directory (\texttt{dir}) as its first argument. This is the directory where the provided code (\texttt{code}) should be executed. Therefore, the current working directory is changed in \texttt{with\_dir()} via \texttt{setwd()}. Then, \texttt{on.exit()} ensures that the modification of the working directory is reset to the initial value when the function exits. By passing the path explicitly, the user has full control over the directory to execute the code in.

In \texttt{source()} the code is passed via the \texttt{file} argument (a path to a file). The \texttt{chdir} argument specifies if the working directory should be changed to the directory containing the file. The default for \texttt{chdir} is \texttt{FALSE}, so you don't have to provide a value. However, as you can only provide \texttt{TRUE} or \texttt{FALSE}, you are also less flexible in choosing the working directory for the code execution.

\textbf{{Q4}}: Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).

\textbf{{A}}: To control the graphics device we use \texttt{pdf()} and \texttt{dev.off()}. To ensure a clean termination \texttt{on.exit()} is used.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plot_pdf <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{pdf}\NormalTok{(}\StringTok{"test.pdf"}\NormalTok{)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{dev.off}\NormalTok{(), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  code}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: We can use \texttt{on.exit()} to implement a simple version of \texttt{capture.output()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture.output2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{file.remove}\NormalTok{(temp), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{TRUE}\NormalTok{)}
  
  \KeywordTok{sink}\NormalTok{(temp)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{sink}\NormalTok{(), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{after =} \OtherTok{TRUE}\NormalTok{)}
  
  \KeywordTok{force}\NormalTok{(code)}
  \KeywordTok{readLines}\NormalTok{(temp)}
\NormalTok{\}}
\KeywordTok{capture.output2}\NormalTok{(}\KeywordTok{cat}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\CommentTok{#> Warning in file.remove(temp): cannot remove file 'C:}
\CommentTok{#> \textbackslash{}Users\textbackslash{}MALTEG~1\textbackslash{}AppData\textbackslash{}Local\textbackslash{}Temp\textbackslash{}RtmpOG0mYg\textbackslash{}file3ab86a7754ff',}
\CommentTok{#> reason 'Permission denied'}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

Compare \texttt{capture.output()} to \texttt{capture.output2()}. How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas to be easier to understand?

\textbf{{A}}: Using \texttt{body(capture.output)} we inspect the source code of the original \texttt{capture.output()} function: The implementation for \texttt{capture.output()} is a quite a bit longer (39 lines vs.~7 lines).

\texttt{capture\_output()} strives to ``write output as far as possible to a file'', which is why an error handling is needed. This is achieved by first quoting the expressions (via \texttt{substitute()}) and then evaluating them step-by-step (via \texttt{lapply()} and a variant of \texttt{eval()}), which makes the function more robust. In \texttt{capture\_output2()} the code is simply forced, and the output is caught via \texttt{sink()} in a temporary file. An additional feature of \texttt{capture\_output()} is that one can also capture messages by setting \texttt{type\ =\ "message"}. As this is internally forwarded to \texttt{sink()}, this behaviour (and also \texttt{sink()}'s \texttt{split} argument) could be easily introduced within \texttt{capture\_output2()} as well.

\hypertarget{function-forms}{%
\section{Function forms}\label{function-forms}}

\textbf{{Q1}}: Rewrite the following code snippets into prefix form:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}

\DecValTok{1} \OperatorTok{+}\StringTok{ }\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{)}

\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{<=}\StringTok{ }\DecValTok{5}\NormalTok{) x[[}\DecValTok{5}\NormalTok{]] }\ControlFlowTok{else}\NormalTok{ x[[n]]}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let's rewrite the expressions to match the exact syntax from the code above. Because prefix functions already define the execution order, we may omit the parentheses in the second expression.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\DecValTok{3}\NormalTok{)}

\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)))}
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}

\StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{(}\StringTok{`}\DataTypeTok{<=}\StringTok{`}\NormalTok{(}\KeywordTok{length}\NormalTok{(x), }\DecValTok{5}\NormalTok{), }\StringTok{`}\DataTypeTok{[[}\StringTok{`}\NormalTok{(x, }\DecValTok{5}\NormalTok{), }\StringTok{`}\DataTypeTok{[[}\StringTok{`}\NormalTok{(x, n))}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Clarify the following list of odd function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\KeywordTok{cor}\NormalTok{(}\DataTypeTok{m =} \StringTok{"k"}\NormalTok{, }\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{u =} \StringTok{"p"}\NormalTok{, }\DataTypeTok{x =}\NormalTok{ x)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: None of these functions provides a \texttt{...} argument. Therefore, the function arguments are first matched exactly, then via partial matching and finally by position. This leads us to the following explicit function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{size =} \DecValTok{20}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{20}\NormalTok{, }\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1}\NormalTok{)}
\KeywordTok{cor}\NormalTok{(x, y, }\DataTypeTok{use =} \StringTok{"pairwise.complete.obs"}\NormalTok{, }\DataTypeTok{method =} \StringTok{"kendall"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Explain why the following code fails:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{modify}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{) <-}\StringTok{ }\DecValTok{10}
\CommentTok{#> Error: target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: First, let's define \texttt{x} and recall the definition of \texttt{modify()} from Advanced R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}

\StringTok{`}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, position, value) \{}
\NormalTok{  x[position] <-}\StringTok{ }\NormalTok{value}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

R internally transforms the code, and the transformed code reproduces the error above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{) <-}\StringTok{ `}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error in get("x") <- `modify<-`(get("x"), 1, 10) : }
\CommentTok{#>   target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}

The error occurs during the assignment because no corresponding replacement function, i.e.~\texttt{get\textless{}-}, exists for \texttt{get()}. To confirm this, we reproduce the error via the following simplified example.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{) <-}\StringTok{ }\DecValTok{2}
\CommentTok{#> Error in get("x") <- 2 :}
\CommentTok{#>   target of assignment expands to non-language object}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Create a replacement function that modifies a random location in a vector.

\textbf{{A}}: Lets define \texttt{random\textless{}-} like this:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{random<-}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, value) \{}
\NormalTok{  idx <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{length}\NormalTok{(x), }\DecValTok{1}\NormalTok{)}
\NormalTok{  x[idx] <-}\StringTok{ }\NormalTok{value}
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Write your own version of \texttt{+} that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\CommentTok{#> [1] 3}

\StringTok{"a"} \OperatorTok{+}\StringTok{ "b"}
\CommentTok{#> [1] "ab"}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: To achieve this behaviour, we need to override the \texttt{+} operator. We need to take care to not use the \texttt{+} operator itself inside of the function definition, as this would lead to an undesired infinite recursion. We also add \texttt{b\ =\ 0L} as a default value to keep the behaviour of \texttt{+} as a unary operator, i.e.~to keep \texttt{+\ 1} working and not throwing an error.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, }\DataTypeTok{b =}\NormalTok{ 0L) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.character}\NormalTok{(a) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is.character}\NormalTok{(b)) \{}
    \KeywordTok{paste0}\NormalTok{(a, b)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    base}\OperatorTok{::}\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(a, b)}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# Test}
\OperatorTok{+}\StringTok{ }\DecValTok{1}
\CommentTok{#> [1] 1}
\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\CommentTok{#> [1] 3}
\StringTok{"a"} \OperatorTok{+}\StringTok{ "b"}
\CommentTok{#> [1] "ab"}

\CommentTok{# Return back to the original `+` operator}
\KeywordTok{rm}\NormalTok{(}\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: Create a list of all the replacement functions found in the \texttt{\{base\}} package. Which ones are primitive functions? (Hint use \texttt{apropos()})

\textbf{{A}}: The hint suggests to look for functions with a specific naming pattern: Replacement functions conventionally end on ``\textless-''. We can search for these objects by supplying the regular expression \texttt{"\textless{}-\$"} to \texttt{apropos()}. \texttt{apropos()} also allows to return the position on the search path (\texttt{search()}) for each of its matches via setting \texttt{where\ =\ TRUE}. Finally, we can set \texttt{mode\ =\ function} to narrow down our search to relevant objects only. This gives us the following statement to begin with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{repls <-}\StringTok{ }\KeywordTok{apropos}\NormalTok{(}\StringTok{"<-"}\NormalTok{, }\DataTypeTok{where =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{mode =} \StringTok{"function"}\NormalTok{)}
\KeywordTok{head}\NormalTok{(repls, }\DecValTok{30}\NormalTok{)}
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>                  "$<-"       "$<-.data.frame"        ".rowNamesDF<-" }
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>                  "@<-"                 "[[<-"      "[[<-.data.frame" }
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>          "[[<-.factor" "[[<-.numeric_version"         "[[<-.POSIXlt" }
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>                  "[<-"       "[<-.data.frame"             "[<-.Date" }
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>           "[<-.factor"  "[<-.numeric_version"          "[<-.POSIXct" }
\CommentTok{#>                     12                     12                     12 }
\CommentTok{#>          "[<-.POSIXlt"                   "<-"                  "<<-" }
\CommentTok{#>                     10                     12                     12 }
\CommentTok{#>                 "as<-"               "attr<-"         "attributes<-" }
\CommentTok{#>                     10                     12                     12 }
\CommentTok{#>               "body<-"               "body<-"              "class<-" }
\CommentTok{#>                     10                     12                     12 }
\CommentTok{#>             "coerce<-"           "colnames<-"            "comment<-" }
\CommentTok{#>                      5                     12                     12 }
\CommentTok{#>          "contrasts<-"               "diag<-"                "dim<-"}
\end{Highlighting}
\end{Shaded}

To restrict \texttt{repl} to names of replacement functions from the \texttt{\{base\}} package, we select only matches containing the relevant position on the search path.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{repls_base <-}\StringTok{ }\NormalTok{repls[}\KeywordTok{names}\NormalTok{(repls) }\OperatorTok{==}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{search}\NormalTok{())]}
\NormalTok{repls_base}
\CommentTok{#>                        12                        12 }
\CommentTok{#>                     "$<-"          "$<-.data.frame" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>           ".rowNamesDF<-"                     "@<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                    "[[<-"         "[[<-.data.frame" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>             "[[<-.factor"    "[[<-.numeric_version" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>            "[[<-.POSIXlt"                     "[<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>          "[<-.data.frame"                "[<-.Date" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>              "[<-.factor"     "[<-.numeric_version" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>             "[<-.POSIXct"             "[<-.POSIXlt" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                      "<-"                     "<<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                  "attr<-"            "attributes<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                  "body<-"                 "class<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>              "colnames<-"               "comment<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                  "diag<-"                   "dim<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>              "dimnames<-"   "dimnames<-.data.frame" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>              "Encoding<-"           "environment<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>               "formals<-"                 "is.na<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>         "is.na<-.default"          "is.na<-.factor" }
\CommentTok{#>                        12                        12 }
\CommentTok{#> "is.na<-.numeric_version"                "length<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>           "length<-.Date"       "length<-.difftime" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>         "length<-.factor"        "length<-.POSIXct" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>        "length<-.POSIXlt"                "levels<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>         "levels<-.factor"                  "mode<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>        "mostattributes<-"                 "names<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>         "names<-.POSIXlt"              "oldClass<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>            "parent.env<-"            "regmatches<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>             "row.names<-"  "row.names<-.data.frame" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>     "row.names<-.default"              "rownames<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                 "split<-"      "split<-.data.frame" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>         "split<-.default"          "storage.mode<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                "substr<-"             "substring<-" }
\CommentTok{#>                        12                        12 }
\CommentTok{#>                 "units<-"        "units<-.difftime"}
\end{Highlighting}
\end{Shaded}

To find out which of these functions are primitives, we first search for these functions via \texttt{mget()} and then subset the result using \texttt{Filter()} and \texttt{is.primitive()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{repls_base_prim <-}\StringTok{ }\KeywordTok{mget}\NormalTok{(repls_base, }\DataTypeTok{envir =} \KeywordTok{baseenv}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{Filter}\NormalTok{(is.primitive, .) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{names}\NormalTok{()}

\NormalTok{repls_base_prim}
\CommentTok{#>  [1] "$<-"            "@<-"            "[[<-"          }
\CommentTok{#>  [4] "[<-"            "<-"             "<<-"           }
\CommentTok{#>  [7] "attr<-"         "attributes<-"   "class<-"       }
\CommentTok{#> [10] "dim<-"          "dimnames<-"     "environment<-" }
\CommentTok{#> [13] "length<-"       "levels<-"       "names<-"       }
\CommentTok{#> [16] "oldClass<-"     "storage.mode<-"}
\end{Highlighting}
\end{Shaded}

Overall the \texttt{\{base\}} package contains 62 replacement functions of which 17 are primitive functions.

\textbf{{Q7}}: What are valid names for user-created infix functions?

\textbf{{A}}: Let's cite from the section on \href{https://adv-r.hadley.nz/functions.html\#function-forms}{function forms} from Advanced R:

\begin{quote}
\ldots{} names of infix functions are more flexible than regular R functions: they can contain any sequence of characters except ``\%''.
\end{quote}

\textbf{{Q8}}: Create an infix \texttt{xor()} operator.

\textbf{{A}}: We could create an infix \texttt{\%xor\%} like this:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%xor%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{xor}\NormalTok{(a, b)}
\NormalTok{\}}
\OtherTok{TRUE} \OperatorTok{%xor%}\StringTok{ }\OtherTok{TRUE}
\CommentTok{#> [1] FALSE}
\OtherTok{FALSE} \OperatorTok{%xor%}\StringTok{ }\OtherTok{TRUE}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q9}}: Create infix versions of the set functions \texttt{intersect()}, \texttt{union()}, and \texttt{setdiff()}. You might call them \texttt{\%n\%}, \texttt{\%u\%}, and \texttt{\%/\%} to match conventions from mathematics.

\textbf{{A}}: These infix operators could be defined in the following way. (\texttt{\%/\%} is chosen instead of \texttt{\%\textbackslash{}\%}, because \texttt{\textbackslash{}} serves as an escape character.)

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%n%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{intersect}\NormalTok{(a, b)}
\NormalTok{\}}

\StringTok{`}\DataTypeTok{%u%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{union}\NormalTok{(a, b)}
\NormalTok{\}}

\StringTok{`}\DataTypeTok{%/%}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{setdiff}\NormalTok{(a, b)}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"d"}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{)}

\NormalTok{x }\OperatorTok{%u%}\StringTok{ }\NormalTok{y}
\CommentTok{#> [1] "a" "b" "d" "c"}
\NormalTok{x }\OperatorTok{%n%}\StringTok{ }\NormalTok{y}
\CommentTok{#> [1] "a" "d"}
\NormalTok{x }\OperatorTok{%/%}\StringTok{ }\NormalTok{y}
\CommentTok{#> [1] "b"}
\end{Highlighting}
\end{Shaded}

\hypertarget{environments}{%
\chapter{Environments}\label{environments}}

\hypertarget{prerequisites-1}{%
\section*{Prerequisites}\label{prerequisites-1}}


Just like in Advanced R, we mainly use the \texttt{\{rlang\}} package to work with environments in this chapter.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{environment-basics}{%
\section{Environment basics}\label{environment-basics}}

\textbf{{Q1}}: List three ways in which an environment differs from a list.

\textbf{{A}}: The most important differences between environments and lists are:

\begin{itemize}
\tightlist
\item
  environments have reference semantics (i.e.~they don't copy-on-modify)
\item
  environments have parents
\item
  the contents of an environment must have unique names
\item
  the contents of an environment are not ordered
\item
  (environments can only be compared via \texttt{identical()}; not with \texttt{==})
\item
  (environments can contain themselves)
\end{itemize}

\textbf{{Q2}}: Create an environment as illustrated by this picture.

\begin{center}\includegraphics[width=200pt]{images/environments/recursive-1} \end{center}

\textbf{{A}}: Let's create an environment, that contains itself.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1 <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}
\NormalTok{e1}\OperatorTok{$}\NormalTok{loop <-}\StringTok{ }\NormalTok{e1}

\CommentTok{# Print the environment}
\KeywordTok{env_print}\NormalTok{(e1)}
\CommentTok{#> <environment: 00000000188D1C10>}
\CommentTok{#> parent: <environment: global>}
\CommentTok{#> bindings:}
\CommentTok{#>  * loop: <env>}

\CommentTok{# Verify that it contains itself}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(e1)}
\CommentTok{#> o [1:0x188d1c10] <env> }
\CommentTok{#> \textbackslash{}-loop = [1:0x188d1c10]}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Create a pair of environments as illustrated by this picture.

\begin{center}\includegraphics[width=200pt]{images/environments/recursive-2} \end{center}

\textbf{{A}}: These two environments contain each other:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e1 <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}
\NormalTok{e2 <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}

\NormalTok{e1}\OperatorTok{$}\NormalTok{loop   <-}\StringTok{ }\NormalTok{e2}
\NormalTok{e2}\OperatorTok{$}\NormalTok{dedoop <-}\StringTok{ }\NormalTok{e1}

\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(e1)}
\CommentTok{#> o [1:0x15e03fd8] <env> }
\CommentTok{#> \textbackslash{}-loop = o [2:0x15b6d840] <env> }
\CommentTok{#>          \textbackslash{}-dedoop = [1:0x15e03fd8]}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ref}\NormalTok{(e2)}
\CommentTok{#> o [1:0x15b6d840] <env> }
\CommentTok{#> \textbackslash{}-dedoop = o [2:0x15e03fd8] <env> }
\CommentTok{#>            \textbackslash{}-loop = [1:0x15b6d840]}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Explain why \texttt{e{[}{[}1{]}{]}} and \texttt{e{[}c("a",\ "b"){]}} don't make sense when \texttt{e} is an environment.

\textbf{{A}}: The first option doesn't make sense, because elements of an environment are not ordered. The second option would return two objects at the same time. What data structure would they be contained inside?

\textbf{{Q5}}: Create a version of \texttt{env\_poke()} that will only bind new names, never re-bind old names. Some programming languages only do this, and are known as \href{http://en.wikipedia.org/wiki/Assignment_(computer_science)\#Single_assignment}{single assignment languages}.

\textbf{{A}}: As described in Advanced R \texttt{rlang::env\_poke()} takes a name (as string) and a value to assign (or reassign) a binding in an environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{e3 <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{()}

\KeywordTok{env_poke}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{e3}\OperatorTok{$}\NormalTok{a}
\CommentTok{#> [1] 100}
\KeywordTok{env_poke}\NormalTok{(e3, }\StringTok{"a"}\NormalTok{, }\DecValTok{200}\NormalTok{)}
\NormalTok{e3}\OperatorTok{$}\NormalTok{a}
\CommentTok{#> [1] 200}
\end{Highlighting}
\end{Shaded}

So, we want \texttt{env\_poke2()} to test, if the supplied name is already present in the given environment. This can be checked via \texttt{env\_has()}. If this is the case, an (informative) error is thrown.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{env_poke2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(env, name, value) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
    \KeywordTok{abort}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, name, }\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{ is already assigned to a value."}\NormalTok{))}
\NormalTok{  \}}

  \KeywordTok{env_poke}\NormalTok{(env, name, value)}
  \KeywordTok{invisible}\NormalTok{(env)}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{env_poke2}\NormalTok{(e3, }\StringTok{"b"}\NormalTok{, }\DecValTok{100}\NormalTok{)}
\NormalTok{e3}\OperatorTok{$}\NormalTok{b}
\CommentTok{#> [1] 100}
\KeywordTok{env_poke2}\NormalTok{(e3, }\StringTok{"b"}\NormalTok{, }\DecValTok{200}\NormalTok{)}
\CommentTok{#> Error: "b" is already assigned to a value.}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: What does this function do? How does it differ from \texttt{\textless{}\textless{}-} and why might you prefer it?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rebind <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, value, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't find `"}\NormalTok{, name, }\StringTok{"`"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
    \KeywordTok{env_poke}\NormalTok{(env, name, value)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{rebind}\NormalTok{(name, value, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{  \}}
\NormalTok{\}}
\KeywordTok{rebind}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error: Can't find `a`}
\NormalTok{a <-}\StringTok{ }\DecValTok{5}
\KeywordTok{rebind}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{a}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The primary difference between \texttt{rebind()} and \texttt{\textless{}\textless{}-} is that \texttt{rebind()} will only carry out an assignment when it finds an existing binding; unlike \texttt{\textless{}\textless{}-} it will never create a new one in the global environment. This behaviour of \texttt{\textless{}\textless{}-} is usually undesirable because global variables introduce non-obvious dependencies between functions.

\hypertarget{recursing-over-environments}{%
\section{Recursing over environments}\label{recursing-over-environments}}

\textbf{{Q1}}: Modify \texttt{where()} to return \emph{all} environments that contain a binding for \texttt{name}. Carefully think through what type of object the function will need to return.

\textbf{{A}}: \texttt{where()} searches (recursively) for a given name within a given environment and its ancestors. If \texttt{where()} finds the name in one of these environments, it returns the environment's name. Otherwise, it throws an error.

The definition of \texttt{where()} was given in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{where <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \CommentTok{# Base case}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't find `"}\NormalTok{, name, }\StringTok{"`."}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
    \CommentTok{# Success case}
\NormalTok{    env}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{# Recursive case}
    \KeywordTok{where}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our modified version of \texttt{where()} will always recurse until it reaches the empty environment. No matter if it has already found the name or not. Along the way, it will check each environment for the given \texttt{name}. Finally, it will return a list of environments where the binding was found; if no binding was found, the list will be empty.

Please also note how the list is initialised via the default argument, when the function is called for the first time. This is a bit confusing, which is why it's common to wrap a recursive function inside another, more user friendly, function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{where2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{(), }\DataTypeTok{results =} \KeywordTok{list}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{empty_env}\NormalTok{())) \{}
    \CommentTok{# Base case}
\NormalTok{    results}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{# Recursive case}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
\NormalTok{      results <-}\StringTok{ }\KeywordTok{c}\NormalTok{(results, env)}
\NormalTok{    \}}
    \KeywordTok{where2}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env), results)}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# Test}
\NormalTok{e1a <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\KeywordTok{empty_env}\NormalTok{(), }\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\NormalTok{e1b <-}\StringTok{ }\KeywordTok{env}\NormalTok{(e1a, }\DataTypeTok{b =} \DecValTok{10}\NormalTok{, }\DataTypeTok{c =} \DecValTok{11}\NormalTok{)}
\NormalTok{e1c <-}\StringTok{ }\KeywordTok{env}\NormalTok{(e1b, }\DataTypeTok{a =} \DecValTok{12}\NormalTok{, }\DataTypeTok{d =} \DecValTok{13}\NormalTok{)}

\KeywordTok{where2}\NormalTok{(}\StringTok{"a"}\NormalTok{, e1c)}
\CommentTok{#> [[1]]}
\CommentTok{#> <environment: 0x0000000018bdca30>}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> <environment: 0x0000000018ad3408>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Write a function called \texttt{fget()} that finds only function objects. It should have two arguments, \texttt{name} and \texttt{env}, and should obey the regular scoping rules for functions: if there's an object with a matching name that's not a function, look in the parent. For an added challenge, also add an \texttt{inherits} argument which controls whether the function recurses up the parents or only looks in one environment.

\textbf{{A}}: We follow a similar approach to the previous exercise. This time we additionally check if the found object is a function and implement and argument to turn off the recursion, if desired.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fget <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{(), }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{) \{}
  \CommentTok{# Base case}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
\NormalTok{    obj <-}\StringTok{ }\KeywordTok{env_get}\NormalTok{(env, name)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.function}\NormalTok{(obj)) \{}
      \KeywordTok{return}\NormalTok{(obj)}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{emptyenv}\NormalTok{()) }\OperatorTok{||}\StringTok{ }\OperatorTok{!}\NormalTok{inherits) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Could not find a function called }\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, name, }\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{."}\NormalTok{,}
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}

  \CommentTok{# Recursive Case}
  \KeywordTok{fget}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{\}}

\CommentTok{# Test}
\NormalTok{mean <-}\StringTok{ }\DecValTok{10}
\KeywordTok{fget}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> function (x, ...) }
\CommentTok{#> UseMethod("mean")}
\CommentTok{#> <bytecode: 0x00000000138445b8>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\hypertarget{special-environments}{%
\section{Special environments}\label{special-environments}}

\textbf{{Q1}}: How is \texttt{search\_envs()} different to \texttt{env\_parents(global\_env())}?

\textbf{{A}}: \texttt{search\_envs()} returns all the environments on the search path, which is ``a chain of environments containing exported functions of attached packages'' (from \texttt{?search\_envs}). Every time you attach a new package, this search path will grow. The search path ends with the base-environment. The global environment is included, because functions present in the global environment will always be part of the search path.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{search_envs}\NormalTok{()}
\CommentTok{#>  [[1]] $ <env: global>}
\CommentTok{#>  [[2]] $ <env: package:rlang>}
\CommentTok{#>  [[3]] $ <env: package:palmerpenguins>}
\CommentTok{#>  [[4]] $ <env: package:magrittr>}
\CommentTok{#>  [[5]] $ <env: package:stats>}
\CommentTok{#>  [[6]] $ <env: package:graphics>}
\CommentTok{#>  [[7]] $ <env: package:grDevices>}
\CommentTok{#>  [[8]] $ <env: package:utils>}
\CommentTok{#>  [[9]] $ <env: package:datasets>}
\CommentTok{#> [[10]] $ <env: package:methods>}
\CommentTok{#> [[11]] $ <env: Autoloads>}
\CommentTok{#> [[12]] $ <env: package:base>}
\end{Highlighting}
\end{Shaded}

\texttt{env\_parents(global\_env())} will list all the ancestors of the global environment, therefore the global environment itself is not included. This also includes the ``ultimate ancestor'', the empty environment. This environment is not considered part of the search path because it contains no objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_parents}\NormalTok{(}\KeywordTok{global_env}\NormalTok{())}
\CommentTok{#>  [[1]] $ <env: package:rlang>}
\CommentTok{#>  [[2]] $ <env: package:palmerpenguins>}
\CommentTok{#>  [[3]] $ <env: package:magrittr>}
\CommentTok{#>  [[4]] $ <env: package:stats>}
\CommentTok{#>  [[5]] $ <env: package:graphics>}
\CommentTok{#>  [[6]] $ <env: package:grDevices>}
\CommentTok{#>  [[7]] $ <env: package:utils>}
\CommentTok{#>  [[8]] $ <env: package:datasets>}
\CommentTok{#>  [[9]] $ <env: package:methods>}
\CommentTok{#> [[10]] $ <env: Autoloads>}
\CommentTok{#> [[11]] $ <env: package:base>}
\CommentTok{#> [[12]] $ <env: empty>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Draw a diagram that shows the enclosing environments of this function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1) \{}
\NormalTok{  f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x2) \{}
\NormalTok{    f3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x3) \{}
\NormalTok{      x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2 }\OperatorTok{+}\StringTok{ }\NormalTok{x3}
\NormalTok{    \}}
    \KeywordTok{f3}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\NormalTok{  \}}
  \KeywordTok{f2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: This exercise urges us to think carefully about the function environment at creation time.

When \texttt{f1} is defined it binds its parent environment, which is the global environment. But \texttt{f2} will only be created at runtime of \texttt{f1} and will therefore bind \texttt{f1}'s execution environment. The value \texttt{1} will also bind to the name \texttt{x1} at execution time. The same holds true for \texttt{x2}, \texttt{f3} and \texttt{x3}.

The following diagram visualizes the relations between the function environments.

\begin{center}\includegraphics[width=350pt]{images/environments/function_environments_corrected} \end{center}

We can also inspect the binding of the environments, adding print statements to the function definition. Please note that these print statements will be evaluated at execution time. Therefore, the execution of \texttt{f1(1)} will print different results each time we run it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1) \{}
\NormalTok{  f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x2) \{}
\NormalTok{    f3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x3) \{}
\NormalTok{      x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2 }\OperatorTok{+}\StringTok{ }\NormalTok{x3}
      \KeywordTok{print}\NormalTok{(}\StringTok{"f3"}\NormalTok{)}
      \KeywordTok{print}\NormalTok{(}\KeywordTok{env_print}\NormalTok{())}
\NormalTok{    \}}
    \KeywordTok{f3}\NormalTok{(}\DecValTok{3}\NormalTok{)}
    \KeywordTok{print}\NormalTok{(}\StringTok{"f2"}\NormalTok{)}
    \KeywordTok{print}\NormalTok{(}\KeywordTok{env_print}\NormalTok{())}
\NormalTok{  \}}
  \KeywordTok{f2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(}\StringTok{"f1"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{env_print}\NormalTok{())}
\NormalTok{\}}

\KeywordTok{f1}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] "f3"}
\CommentTok{#> <environment: 00000000192C2C70>}
\CommentTok{#> parent: <environment: 00000000192C2E30>}
\CommentTok{#> bindings:}
\CommentTok{#>  * x3: <dbl>}
\CommentTok{#> <environment: 0x00000000192c2c70>}
\CommentTok{#> [1] "f2"}
\CommentTok{#> <environment: 00000000192C2E30>}
\CommentTok{#> parent: <environment: 00000000192C2FF0>}
\CommentTok{#> bindings:}
\CommentTok{#>  * f3: <fn>}
\CommentTok{#>  * x2: <dbl>}
\CommentTok{#> <environment: 0x00000000192c2e30>}
\CommentTok{#> [1] "f1"}
\CommentTok{#> <environment: 00000000192C2FF0>}
\CommentTok{#> parent: <environment: global>}
\CommentTok{#> bindings:}
\CommentTok{#>  * f2: <fn>}
\CommentTok{#>  * x1: <dbl>}
\CommentTok{#> <environment: 0x00000000192c2ff0>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Write an enhanced version of \texttt{str()} that provides more information about functions. Show where the function was found and what environment it was defined in.

\textbf{{A}}: To solve this problem, we need to write a function that takes the name of a function and looks for that function returning both the function and the environment that it was found in.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fget2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \CommentTok{# Base case}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{env_has}\NormalTok{(env, name)) \{}
\NormalTok{    obj <-}\StringTok{ }\KeywordTok{env_get}\NormalTok{(env, name)}

    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.function}\NormalTok{(obj)) \{}
      \KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{fun =}\NormalTok{ obj, }\DataTypeTok{env =}\NormalTok{ env))}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{identical}\NormalTok{(env, }\KeywordTok{emptyenv}\NormalTok{())) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Could not find a function called }\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, name, }\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{,}
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}

  \CommentTok{# Recursive Case}
  \KeywordTok{fget2}\NormalTok{(name, }\KeywordTok{env_parent}\NormalTok{(env))}
\NormalTok{\}}

\NormalTok{fstr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(fun_name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.character}\NormalTok{(fun_name) }\OperatorTok{&&}\StringTok{ }\KeywordTok{length}\NormalTok{(fun_name) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"`fun_name` must be a string."}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  \}}
\NormalTok{  fun_env <-}\StringTok{ }\KeywordTok{fget2}\NormalTok{(fun_name, env)}

  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{where =}\NormalTok{ fun_env}\OperatorTok{$}\NormalTok{env,}
    \DataTypeTok{enclosing =} \KeywordTok{fn_env}\NormalTok{(fun_env}\OperatorTok{$}\NormalTok{fun)}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{fstr}\NormalTok{(}\StringTok{"mean"}\NormalTok{)}
\CommentTok{#> $where}
\CommentTok{#> <environment: base>}
\CommentTok{#> }
\CommentTok{#> $enclosing}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

Once you have learned about tidy evaluation, you could rewrite \texttt{fstr()} to use \texttt{enquo()} so that you'd call it more like \texttt{str()}, i.e.~\texttt{fstr(sum)}.

\hypertarget{call-stacks}{%
\section{Call stacks}\label{call-stacks}}

\textbf{{Q1}}: Write a function that lists all the variables defined in the environment in which it was called. It should return the same results as \texttt{ls()}.

\textbf{{A}}: We can implement this dynamic scoping behaviour, by explicitly referencing the caller environment. Please note, that this approach returns also variables starting with a dot, an option that \texttt{ls()} usually requires.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ls2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
  \KeywordTok{sort}\NormalTok{(}\KeywordTok{env_names}\NormalTok{(env))}
\NormalTok{\}}

\CommentTok{# Test in global environment}
\KeywordTok{ls}\NormalTok{(}\DataTypeTok{all.names =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#>  [1] "%>%"          ".Random.seed" "a"            "e1"          }
\CommentTok{#>  [5] "e1a"          "e1b"          "e1c"          "e2"          }
\CommentTok{#>  [9] "e3"           "env_poke2"    "error_wrap"   "f1"          }
\CommentTok{#> [13] "fget"         "fget2"        "fstr"         "ls2"         }
\CommentTok{#> [17] "mean"         "rebind"       "where"        "where2"}
\KeywordTok{ls2}\NormalTok{()}
\CommentTok{#>  [1] "%>%"          ".Random.seed" "a"            "e1"          }
\CommentTok{#>  [5] "e1a"          "e1b"          "e1c"          "e2"          }
\CommentTok{#>  [9] "e3"           "env_poke2"    "error_wrap"   "f1"          }
\CommentTok{#> [13] "fget"         "fget2"        "fstr"         "ls2"         }
\CommentTok{#> [17] "mean"         "rebind"       "where"        "where2"}

\CommentTok{# Test in "sandbox" environment}
\NormalTok{e1 <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\KeywordTok{ls}\NormalTok{(e1)}
\CommentTok{#> [1] "a" "b"}
\KeywordTok{ls2}\NormalTok{(e1)}
\CommentTok{#> [1] "a" "b"}
\end{Highlighting}
\end{Shaded}

\hypertarget{conditions}{%
\chapter{Conditions}\label{conditions}}

\hypertarget{prerequisites-2}{%
\section*{Prerequisites}\label{prerequisites-2}}


Like in the environments chapter we use functions from the \texttt{\{rlang\}} package here.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{signalling-conditions}{%
\section{Signalling conditions}\label{signalling-conditions}}

\textbf{{Q1}}: Write a wrapper around \texttt{file.remove()} that throws an error if the file to be deleted does not exist.

\textbf{{A}}: We prefer the following solution for its clarity and simplicity:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{file_remove_strict <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{file.exists}\NormalTok{(path)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't delete the file }\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, path, }
         \StringTok{"}\CharTok{\textbackslash{}"}\StringTok{ because it doesn't exist."}\NormalTok{,}
         \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}
  \KeywordTok{file.remove}\NormalTok{(path)}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{saveRDS}\NormalTok{(mtcars, }\StringTok{"mtcars.rds"}\NormalTok{)}
\KeywordTok{file_remove_strict}\NormalTok{(}\StringTok{"mtcars.rds"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{file_remove_strict}\NormalTok{(}\StringTok{"mtcars.rds"}\NormalTok{)}
\CommentTok{#> Error: Can't delete the file "mtcars.rds" because it doesn't exist.}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What does the \texttt{appendLF} argument to \texttt{message()} do? How is it related to \texttt{cat()}?

\textbf{{A}}: The \texttt{appendLF} argument automatically appends a new line to the message. Let's illustrate this behaviour with a small example function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{multiline_msg <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{appendLF =} \OtherTok{TRUE}\NormalTok{) \{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"first"}\NormalTok{, }\DataTypeTok{appendLF =}\NormalTok{ appendLF)}
  \KeywordTok{message}\NormalTok{(}\StringTok{"second"}\NormalTok{, }\DataTypeTok{appendLF =}\NormalTok{ appendLF)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"third"}\NormalTok{)}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"fourth"}\NormalTok{)}
\NormalTok{\}}

\KeywordTok{multiline_msg}\NormalTok{(}\DataTypeTok{appendLF =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> first}
\CommentTok{#> second}
\CommentTok{#> thirdfourth}
\KeywordTok{multiline_msg}\NormalTok{(}\DataTypeTok{appendLF =} \OtherTok{FALSE}\NormalTok{)}
\CommentTok{#> firstsecondthirdfourth}
\end{Highlighting}
\end{Shaded}

Comparable behaviour regarding line breaks for \texttt{cat()} can be achieved via setting its \texttt{sep} argument to \texttt{"\textbackslash{}n"}.

\stepcounter{section}

\hypertarget{handling-conditions}{%
\section{Handling conditions}\label{handling-conditions}}

\textbf{{Q1}}: What extra information does the condition generated by \texttt{abort()} contain compared to the condition generated by \texttt{stop()}, i.e.~what's the difference between these two objects? Read the help for \texttt{?abort} to learn more.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"An error"}\NormalTok{))}
\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{abort}\NormalTok{(}\StringTok{"An error"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In contrast to \texttt{stop()}, which contains the call, \texttt{abort()} stores the whole backtrace generated by \texttt{rlang::trace\_back()}. This is a lot of extra data!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"An error"}\NormalTok{)))}
\CommentTok{#> List of 2}
\CommentTok{#>  $ message: chr "An error"}
\CommentTok{#>  $ call   : language force(expr)}
\CommentTok{#>  - attr(*, "class")= chr [1:3] "simpleError" "error" "condition"}

\KeywordTok{str}\NormalTok{(}\KeywordTok{catch_cnd}\NormalTok{(}\KeywordTok{abort}\NormalTok{(}\StringTok{"An error"}\NormalTok{)))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ message: chr "An error"}
\CommentTok{#>  $ trace  :List of 3}
\CommentTok{#>   ..$ calls  :List of 8}
\CommentTok{#>   .. ..$ : language utils::str(catch_cnd(abort("An error")))}
\CommentTok{#>   .. ..$ : language rlang::catch_cnd(abort("An error"))}
\CommentTok{#>   .. ..$ : language rlang::eval_bare(rlang::expr(tryCatch(!!!handle..}
\CommentTok{#>   .. ..$ : language base::tryCatch(condition = function (x)  x, \{ ...}
\CommentTok{#>   .. ..$ : language base:::tryCatchList(expr, classes, parentenv, h..}
\CommentTok{#>   .. ..$ : language base:::tryCatchOne(expr, names, parentenv, hand..}
\CommentTok{#>   .. ..$ : language base:::doTryCatch(return(expr), name, parentenv..}
\CommentTok{#>   .. ..$ : language base::force(expr)}
\CommentTok{#>   ..$ parents: int [1:8] 0 0 2 2 4 5 6 2}
\CommentTok{#>   ..$ indices: int [1:8] 26 27 28 29 30 31 32 33}
\CommentTok{#>   ..- attr(*, "class")= chr "rlang_trace"}
\CommentTok{#>   ..- attr(*, "version")= int 1}
\CommentTok{#>  $ parent : NULL}
\CommentTok{#>  - attr(*, "class")= chr [1:3] "rlang_error" "error" "condition"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Predict the results of evaluating the following code

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_condition <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"error"}\NormalTok{,}
    \DataTypeTok{warning =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"warning"}\NormalTok{,}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\StringTok{"message"}\NormalTok{,}
\NormalTok{    \{}
\NormalTok{      code}
      \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}


\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"!"}\NormalTok{))}
\KeywordTok{show_condition}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{))}
\KeywordTok{show_condition}\NormalTok{(\{}
  \DecValTok{10}
  \KeywordTok{message}\NormalTok{(}\StringTok{"?"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The first three examples are straightforward:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"!"}\NormalTok{))      }\CommentTok{# stop raises an error}
\CommentTok{#> [1] "error"}
\KeywordTok{show_condition}\NormalTok{(}\DecValTok{10}\NormalTok{)             }\CommentTok{# no condition is signalled}
\CommentTok{#> NULL}
\KeywordTok{show_condition}\NormalTok{(}\KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{))  }\CommentTok{# warning raises a warning}
\CommentTok{#> [1] "warning"}
\end{Highlighting}
\end{Shaded}

The last example is the most interesting and makes us aware of the exiting qualities of \texttt{tryCatch()}, it will terminate the evaluation of the code as soon as it is called.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{show_condition}\NormalTok{(\{}
  \DecValTok{10}
  \KeywordTok{message}\NormalTok{(}\StringTok{"?"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [1] "message"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Explain the results of running this code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{withCallingHandlers}\NormalTok{(  }\CommentTok{# (1)}
  \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"b"}\NormalTok{),}
  \KeywordTok{withCallingHandlers}\NormalTok{(  }\CommentTok{# (2)}
    \DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{message}\NormalTok{(}\StringTok{"a"}\NormalTok{),}
    \KeywordTok{message}\NormalTok{(}\StringTok{"c"}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> b}
\CommentTok{#> a}
\CommentTok{#> b}
\CommentTok{#> c}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: It's a little tricky to untangle the flow here:

First, \texttt{message("c")} is run, and it's caught by (1). It then calls \texttt{message("a")}, which is caught by (2), which calls \texttt{message("b")}. \texttt{message("b")} isn't caught by anything, so we see a \texttt{b} on the console, followed by \texttt{a}. But why do we get another \texttt{b} before we see \texttt{c}? That's because we haven't handled the message, so it bubbles up to the outer calling handler.

\textbf{{Q4}}: Read the source code for \texttt{catch\_cnd()} and explain how it works. At the time Advanced R was written, the source for \texttt{catch\_cnd()} was a little simpler:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnd <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{condition =} \ControlFlowTok{function}\NormalTok{(cnd) cnd,}
\NormalTok{    \{}
      \KeywordTok{force}\NormalTok{(expr)}
      \KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{catch\_cnd()} is a simple wrapper around \texttt{tryCatch()}. If a condition is signalled, it's caught and returned. If no condition is signalled, execution proceeds sequentially and the function returns \texttt{NULL}.

The current version of \texttt{catch\_cnd()} is a little more complex because it allows you to specify which classes of condition you want to capture. This requires some manual code generation because the interface of \texttt{tryCatch()} provides condition classes as argument names.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rlang}\OperatorTok{::}\NormalTok{catch_cnd}
\CommentTok{#> function (expr, classes = "condition") }
\CommentTok{#> \{}
\CommentTok{#>     stopifnot(is_character(classes))}
\CommentTok{#>     handlers <- rep_named(classes, list(identity))}
\CommentTok{#>     eval_bare(rlang::expr(tryCatch(!!!handlers, \{}
\CommentTok{#>         force(expr)}
\CommentTok{#>         return(NULL)}
\CommentTok{#>     \})))}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x00000000193777a0>}
\CommentTok{#> <environment: namespace:rlang>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: How could you rewrite \texttt{show\_condition()} to use a single handler?

\textbf{{A}}: \texttt{show\_condition()} was defined in one of the previous questions. Let's use the \texttt{condition} argument of \texttt{tryCatch()} as shown in \texttt{rlang::catch\_cond()} above for our re-implementation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{show_condition2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{condition =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(cnd, }\StringTok{"error"}\NormalTok{))   }\KeywordTok{return}\NormalTok{(}\StringTok{"error"}\NormalTok{)}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(cnd, }\StringTok{"warning"}\NormalTok{)) }\KeywordTok{return}\NormalTok{(}\StringTok{"warning"}\NormalTok{)}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{inherits}\NormalTok{(cnd, }\StringTok{"message"}\NormalTok{)) }\KeywordTok{return}\NormalTok{(}\StringTok{"message"}\NormalTok{)}
\NormalTok{    \},}
\NormalTok{    \{}
\NormalTok{      code}
      \OtherTok{NULL}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{show_condition2}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"!"}\NormalTok{))}
\CommentTok{#> [1] "error"}
\KeywordTok{show_condition2}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> NULL}
\KeywordTok{show_condition2}\NormalTok{(}\KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{))}
\CommentTok{#> [1] "warning"}
\KeywordTok{show_condition2}\NormalTok{(\{}
  \DecValTok{10}
  \KeywordTok{message}\NormalTok{(}\StringTok{"?"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"?!"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [1] "message"}
\end{Highlighting}
\end{Shaded}

\texttt{tryCatch()} executes the code and captures any condition raised. The function provided as the \texttt{condition} handles this condition. In this case it dispatches on the class of the condition.

\hypertarget{custom-conditions}{%
\section{Custom conditions}\label{custom-conditions}}

\textbf{{Q1}}: Inside a package, it's occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with \texttt{requireNamespace("pkg",\ quietly\ =\ FALSE))} and if not, throws a custom condition that includes the package name in the metadata.

\textbf{{A}}: We use \texttt{rlang::abort()} to supply error metadata:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{check_installed <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(package) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{requireNamespace}\NormalTok{(package, }\DataTypeTok{quietly =} \OtherTok{FALSE}\NormalTok{)) \{}
    \KeywordTok{abort}\NormalTok{(}
      \StringTok{"error_pkg_not_found"}\NormalTok{,}
      \DataTypeTok{message =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"package '"}\NormalTok{, package, }\StringTok{"' not installed."}\NormalTok{),}
      \DataTypeTok{package =}\NormalTok{ package}
\NormalTok{    )}
\NormalTok{  \}}

  \OtherTok{TRUE}
\NormalTok{\}}

\KeywordTok{check_installed}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{check_installed}\NormalTok{(}\StringTok{"ggplot3"}\NormalTok{)}
\CommentTok{#> Loading required namespace: ggplot3}
\CommentTok{#> Error: package 'ggplot3' not installed.}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

\textbf{{A}}: Instead of returning an error it might be preferable to throw a customised condition and place a standardised error message inside the metadata. Then the downstream package could check for the class of the condition, rather than inspecting the message.

\hypertarget{applications-1}{%
\section{Applications}\label{applications-1}}

\textbf{{Q1}}: Create \texttt{suppressConditions()} that works like \texttt{suppressMessages()} and \texttt{suppressWarnings()} but suppresses everything. Think carefully about how you should handle errors.

\textbf{{A}}: In general, we would like to catch errors, since they contain important information for debugging. To suppress the error message and hide the returned error object from the console, we handle errors within a \texttt{tryCatch()} and return the error object invisibly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suppressErrors <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) }\KeywordTok{invisible}\NormalTok{(cnd),}
    \DataTypeTok{interrupt =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Terminated by the user."}\NormalTok{,}
        \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{      )}
\NormalTok{    \},}
\NormalTok{    expr}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

After we defined the error handling, we can just combine it with the other handlers to create \texttt{suppressConditions()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suppressConditions <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \KeywordTok{suppressErrors}\NormalTok{(}\KeywordTok{suppressWarnings}\NormalTok{(}\KeywordTok{suppressMessages}\NormalTok{(expr)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To test the new function, we apply it to a set of conditions and inspect the returned error object.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The messages/warnings/conditions are suppressed successfully}
\NormalTok{error_obj <-}\StringTok{ }\KeywordTok{suppressConditions}\NormalTok{(\{}
  \KeywordTok{message}\NormalTok{(}\StringTok{"message"}\NormalTok{)}
  \KeywordTok{warning}\NormalTok{(}\StringTok{"warning"}\NormalTok{)}
  \KeywordTok{abort}\NormalTok{(}\StringTok{"error"}\NormalTok{)}
\NormalTok{\})}

\NormalTok{error_obj}
\CommentTok{#> <error/rlang_error>}
\CommentTok{#> error}
\CommentTok{#> Backtrace:}
\CommentTok{#>   1. global::suppressConditions(...)}
\CommentTok{#>  12. base::suppressMessages(expr)}
\CommentTok{#>  13. base::withCallingHandlers(...)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Compare the following two implementations of \texttt{message2error()}. What is the main advantage of \texttt{withCallingHandlers()} in this scenario? (Hint: look carefully at the traceback.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(e))}
\NormalTok{\}}
\NormalTok{message2error <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(e))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Both functions differ in the way conditions are handled. \texttt{withCallingHandlers()} creates a \emph{calling handler}, which is executed from within the signalling function. This makes it possible to record a detailed call stack, which helps us identify the signalling condition.

\texttt{tryCatch()} defines an \emph{exiting handler}, which means that the signalling function is terminated as soon as a condition is raised. It also returns control to the context where \texttt{tryCatch()} was called.

In this example the use of \texttt{withCallingHandlers()} returns more information than the use of \texttt{tryCatch()}. This allows us to determine the exact call that raised the condition.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message2error1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{withCallingHandlers}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) }\KeywordTok{stop}\NormalTok{(}\StringTok{"error"}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{message2error1}\NormalTok{(\{}\DecValTok{1}\NormalTok{;  }\KeywordTok{message}\NormalTok{(}\StringTok{"hidden error"}\NormalTok{); }\OtherTok{NULL}\NormalTok{\})}
\CommentTok{#> Error in (function (e) : error}
\KeywordTok{traceback}\NormalTok{()}
\CommentTok{#> 9: stop("error") at #2}
\CommentTok{#> 8: (function (e) }
\CommentTok{#>    stop("error"))(list(message = "hidden error\textbackslash{}n",}
\CommentTok{#>      call = message("hidden error")))}
\CommentTok{#> 7: signalCondition(cond)}
\CommentTok{#> 6: doWithOneRestart(return(expr), restart)}
\CommentTok{#> 5: withOneRestart(expr, restarts[[1L]])}
\CommentTok{#> 4: withRestarts(\{}
\CommentTok{#>        signalCondition(cond)}
\CommentTok{#>        defaultHandler(cond)}
\CommentTok{#>    \}, muffleMessage = function() NULL)}
\CommentTok{#> 3: message("hidden error") at #1}
\CommentTok{#> 2: withCallingHandlers(code,}
\CommentTok{#>      message = function(e) stop("error")) at #2}
\CommentTok{#> 1: message2error1(\{}
\CommentTok{#>        1}
\CommentTok{#>        message("hidden error")}
\CommentTok{#>        NULL}
\CommentTok{#>    \})}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{message2error2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
  \KeywordTok{tryCatch}\NormalTok{(code, }\DataTypeTok{message =} \ControlFlowTok{function}\NormalTok{(e) (}\KeywordTok{stop}\NormalTok{(}\StringTok{"error"}\NormalTok{)))}
\NormalTok{\}}

\KeywordTok{message2error2}\NormalTok{(\{}\DecValTok{1}\NormalTok{; }\KeywordTok{stop}\NormalTok{(}\StringTok{"hidden error"}\NormalTok{); }\OtherTok{NULL}\NormalTok{\})}
\CommentTok{#> Error in value[[3L]](cond) : error}
\KeywordTok{traceback}\NormalTok{()}
\CommentTok{#> 6: stop("error") at #2}
\CommentTok{#> 5: value[[3L]](cond)}
\CommentTok{#> 4: tryCatchOne(expr, names, parentenv, handlers[[1L]])}
\CommentTok{#> 3: tryCatchList(expr, classes, parentenv, handlers)}
\CommentTok{#> 2: tryCatch(code, message = function(e) (stop("error"))) at #2}
\CommentTok{#> 1: message2error2(\{}
\CommentTok{#>        1}
\CommentTok{#>        message("hidden error")}
\CommentTok{#>        NULL}
\CommentTok{#>    \})}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: How would you modify the \texttt{catch\_cnds()} definition if you wanted to recreate the original intermingling of warnings and messages?

\textbf{{A}}: To preserve the original order, we have to capture everything into a single list. This makes using this function slightly harder since the caller is responsible for handling the different condition classes.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{catch_cnds <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  conds <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
\NormalTok{  add_cond <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{    conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
    \KeywordTok{cnd_muffle}\NormalTok{(cnd)}
\NormalTok{  \}}

  \KeywordTok{tryCatch}\NormalTok{(}
    \DataTypeTok{error =} \ControlFlowTok{function}\NormalTok{(cnd) \{}
\NormalTok{      conds <<-}\StringTok{ }\KeywordTok{append}\NormalTok{(conds, }\KeywordTok{list}\NormalTok{(cnd))}
\NormalTok{    \},}
    \KeywordTok{withCallingHandlers}\NormalTok{(}
      \DataTypeTok{message =}\NormalTok{ add_cond,}
      \DataTypeTok{warning =}\NormalTok{ add_cond,}
\NormalTok{      expr}
\NormalTok{    )}
\NormalTok{  )}

\NormalTok{  conds}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{catch_cnds}\NormalTok{(\{}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"message a"}\NormalTok{)}
  \KeywordTok{warn}\NormalTok{(}\StringTok{"warning b"}\NormalTok{)}
  \KeywordTok{inform}\NormalTok{(}\StringTok{"message c"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> [[1]]}
\CommentTok{#> <message: message a}
\CommentTok{#> >}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> <warning: warning b>}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> <message: message c}
\CommentTok{#> >}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Why is catching interrupts dangerous? Run this code to find out.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bottles_of_beer <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{i =} \DecValTok{99}\NormalTok{) \{}
  \KeywordTok{message}\NormalTok{(}
    \StringTok{"There are "}\NormalTok{, i,}
    \StringTok{" bottles of beer on the wall, "}\NormalTok{, i,}
    \StringTok{" bottles of beer."}
\NormalTok{  )}
  \ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{tryCatch}\NormalTok{(}
      \KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{),}
      \DataTypeTok{interrupt =} \ControlFlowTok{function}\NormalTok{(err) \{}
\NormalTok{        i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{-}\StringTok{ }\DecValTok{1}
        \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
          \KeywordTok{message}\NormalTok{(}
            \StringTok{"Take one down, pass it around, "}\NormalTok{, i,}
            \StringTok{" bottle"}\NormalTok{, }\ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{) }\StringTok{"s"}\NormalTok{, }\StringTok{" of beer on the wall."}
\NormalTok{          )}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    )}
\NormalTok{  \}}
  \KeywordTok{message}\NormalTok{(}
    \StringTok{"No more bottles of beer on the wall, "}\NormalTok{,}
    \StringTok{"no more bottles of beer."}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: When running the \texttt{bottles\_of\_beer()} function in your console, the output should look somehow like the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bottles_of_beer}\NormalTok{()}
\CommentTok{#> There are 99 bottles of beer on the wall, 99 bottles of beer.}
\CommentTok{#> Take one down, pass it around, 98 bottles of beer on the wall.}
\CommentTok{#> Take one down, pass it around, 97 bottles of beer on the wall.}
\CommentTok{#> Take one down, pass it around, 96 bottles of beer on the wall.}
\CommentTok{#> Take one down, pass it around, 95 bottles of beer on the wall.}
\CommentTok{#> }
\end{Highlighting}
\end{Shaded}

At this point you'll probably recognise how hard it is to get the number of bottles down from \texttt{99} to \texttt{0}. There's no way to break out of the function because we're capturing the interrupt that you'd usually use!

\hypertarget{part-functional-programming}{%
\part{Functional programming}\label{part-functional-programming}}

\hypertarget{functionals}{%
\chapter{Functionals}\label{functionals}}

\hypertarget{prerequisites-3}{%
\section*{Prerequisites}\label{prerequisites-3}}


For the functional programming part of the book, we will mainly use functions from the \texttt{\{purrr\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{my-first-functional-map}{%
\section{\texorpdfstring{My first functional: \texttt{map()}}{My first functional: map()}}\label{my-first-functional-map}}

\textbf{{Q1}}: Use \texttt{as\_mapper()} to explore how \texttt{\{purrr\}} generates anonymous functions for the integer, character, and list helpers. What helper allows you to extract attributes? Read the documentation to find out.

\textbf{{A}}: \texttt{map()} offers multiple ways (functions, formulas, and extractor functions) to specify its function argument (\texttt{.f}). Initially, the various inputs have to be transformed into a valid function, which is then applied. The creation of this valid function is the job of \texttt{as\_mapper()} and it is called every time \texttt{map()} is used.

Given character, numeric or list input \texttt{as\_mapper()} will create an extractor function. Characters select by name, while numeric input selects by positions and a list allows a mix of these two approaches. This extractor interface can be very useful, when working with nested data.

The extractor function is implemented as a call to \texttt{purrr::pluck()}, which accepts a list of accessors (accessors ``access'' some part of your data object).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_mapper}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))  }\CommentTok{# equivalent to function(x) x[[1]][[2]]}
\CommentTok{#> function (x, ...) }
\CommentTok{#> pluck(x, 1, 2, .default = NULL)}
\CommentTok{#> <environment: 0x00000000156ec898>}
\KeywordTok{as_mapper}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))  }\CommentTok{# equivalent to function(x) x[["a"]][["b]]}
\CommentTok{#> function (x, ...) }
\CommentTok{#> pluck(x, "a", "b", .default = NULL)}
\CommentTok{#> <environment: 0x0000000015667988>}
\KeywordTok{as_mapper}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{"b"}\NormalTok{))  }\CommentTok{# equivalent to function(x) x[[1]][["b]]}
\CommentTok{#> function (x, ...) }
\CommentTok{#> pluck(x, 1, "b", .default = NULL)}
\CommentTok{#> <environment: 0x0000000015605f70>}
\end{Highlighting}
\end{Shaded}

Besides mixing positions and names, it is also possible to pass along an accessor function. This is basically an anonymous function, that gets information about some aspect of the input data. You are free to define your own accessor functions.

If you need to access certain attributes, the helper \texttt{attr\_getter(y)} is already predefined and will create the appropriate accessor function for you.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Define custom accessor function}
\NormalTok{get_class <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{attr}\NormalTok{(x, }\StringTok{"class"}\NormalTok{)}
\KeywordTok{pluck}\NormalTok{(mtcars, get_class)}
\CommentTok{#> [1] "data.frame"}

\CommentTok{# Use attr_getter() as a helper}
\KeywordTok{pluck}\NormalTok{(mtcars, }\KeywordTok{attr_getter}\NormalTok{(}\StringTok{"class"}\NormalTok{))}
\CommentTok{#> [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: \texttt{map(1:3,\ \textasciitilde{}\ runif(2))} is a useful pattern for generating random numbers, but \texttt{map(1:3,\ runif(2))} is not. Why not? Can you explain why it returns the result that it does?

\textbf{{A}}: The first pattern creates multiple random numbers, because \texttt{\textasciitilde{}\ runif(2)} successfully uses the formula interface. Internally \texttt{map()} applies \texttt{as\_mapper()} to this formula, which converts \texttt{\textasciitilde{}\ runif(2)} into an anonymous function. Afterwards \texttt{runif(2)} is applied three times (one time during each iteration), leading to three different pairs of random numbers.

In the second pattern \texttt{runif(2)} is evaluated once, then the results are passed to \texttt{map()}. Consequently \texttt{as\_mapper()} creates an extractor function based on the return values from \texttt{runif(2)} (via \texttt{pluck()}). This leads to three \texttt{NULL}s (\texttt{pluck()}'s \texttt{.default} return), because no values corresponding to the index can be found.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as_mapper}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\CommentTok{#> <lambda>}
\CommentTok{#> function (..., .x = ..1, .y = ..2, . = ..1) }
\CommentTok{#> runif(2)}
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "rlang_lambda_function" "function"}
\KeywordTok{as_mapper}\NormalTok{(}\KeywordTok{runif}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\CommentTok{#> function (x, ...) }
\CommentTok{#> pluck(x, 0.0807501375675201, 0.834333037259057, .default = NULL)}
\CommentTok{#> <environment: 0x0000000019027228>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Use the appropriate \texttt{map()} function to:

\begin{enumerate}
\def\labelenumi{\alph{enumi})}
\item
  Compute the standard deviation of every column in a numeric data frame.
\item
  Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you'll need to do it in two steps.)
\item
  Compute the number of levels for every factor in a data frame.
\end{enumerate}

\textbf{{A}}: To solve this exercise we take advantage of calling the type stable variants of \texttt{map()}, which give us more concise output, and use \texttt{map\_lgl()} to select the columns of the data frame (later you'll learn about \texttt{keep()}, which simplifies this pattern a little).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_dbl}\NormalTok{(mtcars, sd)}
\CommentTok{#>     mpg     cyl    disp      hp    drat      wt    qsec      vs }
\CommentTok{#>   6.027   1.786 123.939  68.563   0.535   0.978   1.787   0.504 }
\CommentTok{#>      am    gear    carb }
\CommentTok{#>   0.499   0.738   1.615}

\NormalTok{penguins <-}\StringTok{ }\NormalTok{palmerpenguins}\OperatorTok{::}\NormalTok{penguins}

\NormalTok{penguins_numeric <-}\StringTok{ }\KeywordTok{map_lgl}\NormalTok{(penguins, is.numeric)}
\KeywordTok{map_dbl}\NormalTok{(penguins[penguins_numeric], sd, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#>    bill_length_mm     bill_depth_mm flipper_length_mm }
\CommentTok{#>             5.460             1.975            14.062 }
\CommentTok{#>       body_mass_g              year }
\CommentTok{#>           801.955             0.818}

\NormalTok{penguins_factor <-}\StringTok{ }\KeywordTok{map_lgl}\NormalTok{(penguins, is.factor)}
\KeywordTok{map_int}\NormalTok{(penguins[penguins_factor], }\OperatorTok{~}\StringTok{ }\KeywordTok{length}\NormalTok{(}\KeywordTok{levels}\NormalTok{(.x)))}
\CommentTok{#> species  island     sex }
\CommentTok{#>       3       3       2}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: The following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trials <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{100}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{t.test}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{10}\NormalTok{), }\KeywordTok{rpois}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{7}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: There are many ways to visualise this data. However, since there are only 100 data points, we choose a dot plot to visualise the distribution. (Unfortunately, \texttt{\{ggplot2\}}s \texttt{geom\_dotplot()} doesn't compute proper counts as it was created to visualise distribution densities instead of frequencies, so a histogram would be a suitable alternative).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}

\NormalTok{df_trials <-}\StringTok{ }\NormalTok{tibble}\OperatorTok{::}\KeywordTok{tibble}\NormalTok{(}\DataTypeTok{p_value =} \KeywordTok{map_dbl}\NormalTok{(trials, }\StringTok{"p.value"}\NormalTok{))}

\NormalTok{df_trials }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ p_value, }\DataTypeTok{fill =}\NormalTok{ p_value }\OperatorTok{<}\StringTok{ }\FloatTok{0.05}\NormalTok{)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_dotplot}\NormalTok{(}\DataTypeTok{binwidth =} \FloatTok{.01}\NormalTok{) }\OperatorTok{+}\StringTok{  }\CommentTok{# geom_histogram() as alternative}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}
    \DataTypeTok{axis.text.y =} \KeywordTok{element_blank}\NormalTok{(),}
    \DataTypeTok{axis.ticks.y =} \KeywordTok{element_blank}\NormalTok{(),}
    \DataTypeTok{legend.position =} \StringTok{"top"}
\NormalTok{  )}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{09_Functionals_files/figure-latex/unnamed-chunk-7-1} \end{center}

\textbf{{Q5}}: The following code uses a map nested inside another map to apply a function to every element of a nested list. Why does it fail, and what do you need to do to make it work?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{9}\NormalTok{)),}
  \KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DecValTok{7}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{6}\NormalTok{))}
\NormalTok{)}

\NormalTok{triple <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{map}\NormalTok{(x, map, }\DataTypeTok{.f =}\NormalTok{ triple)}
\CommentTok{#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...)}
\CommentTok{#> \{}
\CommentTok{#> .f <- as_mapper(.f, ...)}
\CommentTok{#> .Call(map_impl, environment(), ".x", ".f", "list")}
\CommentTok{#> \})}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: This function call fails, because \texttt{triple()} is specified as the \texttt{.f} argument and consequently belongs to the outer \texttt{map()}. The unnamed argument \texttt{map} is treated as an argument of \texttt{triple()}, which causes the error.

There are a number of ways we could resolve the problem. However, there is not much to choose between them for this simple example, although it is good to know your options for more complicated cases.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Don't name the argument}
\KeywordTok{map}\NormalTok{(x, map, triple)}

\CommentTok{# Use magrittr-style anonymous function}
\KeywordTok{map}\NormalTok{(x, . }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(triple))}

\CommentTok{# Use purrr-style anonymous function}
\KeywordTok{map}\NormalTok{(x, }\OperatorTok{~}\StringTok{ }\KeywordTok{map}\NormalTok{(.x, triple))}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: Use \texttt{map()} to fit linear models to the \texttt{mtcars} dataset using the formulas stored in this list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{formulas <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp,}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp),}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp }\OperatorTok{+}\StringTok{ }\NormalTok{wt,}
\NormalTok{  mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp) }\OperatorTok{+}\StringTok{ }\NormalTok{wt}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The data (\texttt{mtcars}) is constant for all these models and so we iterate over the \texttt{formulas} provided. As the formula is the first argument of \texttt{lm()}, we don't need to specify it explicitly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{models <-}\StringTok{ }\KeywordTok{map}\NormalTok{(formulas, lm, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q7}}: Fit the model \texttt{mpg\ \textasciitilde{}\ disp} to each of the bootstrap replicates of \texttt{mtcars} in the list below, then extract the \(R^2\) of the model fit (Hint: you can compute the \(R^2\) with \texttt{summary()})

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootstrap <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df) \{}
\NormalTok{  df[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(df), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}

\NormalTok{bootstraps <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\OperatorTok{~}\StringTok{ }\KeywordTok{bootstrap}\NormalTok{(mtcars))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: To accomplish this task, we take advantage of the ``list in, list out''-functionality of \texttt{map()}. This allows us to chain multiple transformation together. We start by fitting the models. We then calculate the summaries and extract the \(R^2\) values. For the last call we use \texttt{map\_dbl()}, which provides convenient output.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bootstraps }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{map}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, }\DataTypeTok{data =}\NormalTok{ .x)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{map}\NormalTok{(summary) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{map_dbl}\NormalTok{(}\StringTok{"r.squared"}\NormalTok{)}
\CommentTok{#>  [1] 0.588 0.822 0.745 0.746 0.784 0.749 0.613 0.792 0.653 0.726}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{map-variants}{%
\section{Map variants}\label{map-variants}}

\textbf{{Q1}}: Explain the results of \texttt{modify(mtcars,\ 1)}.

\textbf{{A}}: \texttt{modify()} is based on \texttt{map()}, and in this case, the extractor interface will be used. It extracts the first element of each column in \texttt{mtcars}. \texttt{modify()} always returns the same structure as its input: in this case it forces the first row to be recycled 32 times. (Internally \texttt{modify()} uses \texttt{.x{[}{]}\ \textless{}-\ map(.x,\ .f,\ ...)} for assignment.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(}\KeywordTok{modify}\NormalTok{(mtcars, }\DecValTok{1}\NormalTok{))}
\CommentTok{#>                   mpg cyl disp  hp drat   wt qsec vs am gear carb}
\CommentTok{#> Mazda RX4          21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\CommentTok{#> Mazda RX4 Wag      21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\CommentTok{#> Datsun 710         21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\CommentTok{#> Hornet 4 Drive     21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\CommentTok{#> Hornet Sportabout  21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\CommentTok{#> Valiant            21   6  160 110  3.9 2.62 16.5  0  1    4    4}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Rewrite the following code to use \texttt{iwalk()} instead of \texttt{walk2()}. What are the advantages and disadvantages?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\NormalTok{paths <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}
\KeywordTok{walk2}\NormalTok{(cyls, paths, write.csv)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{iwalk()} allows us to use a single variable, storing the output path in the names.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{dir.create}\NormalTok{(temp)}

\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\KeywordTok{names}\NormalTok{(cyls) <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}
\KeywordTok{iwalk}\NormalTok{(cyls, }\OperatorTok{~}\StringTok{ }\KeywordTok{write.csv}\NormalTok{(.x, .y))}
\end{Highlighting}
\end{Shaded}

We could do this in a single pipe by taking advantage of \texttt{set\_names()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{split}\NormalTok{(mtcars}\OperatorTok{$}\NormalTok{cyl) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{set_names}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{file.path}\NormalTok{(temp, }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, .x, }\StringTok{".csv"}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{iwalk}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{write.csv}\NormalTok{(.x, .y))}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Explain how the following code transforms a data frame using functions stored in a list.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{trans <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{disp =} \ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{*}\StringTok{ }\FloatTok{0.0163871}\NormalTok{,}
  \DataTypeTok{am =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{factor}\NormalTok{(x, }\DataTypeTok{labels =} \KeywordTok{c}\NormalTok{(}\StringTok{"auto"}\NormalTok{, }\StringTok{"manual"}\NormalTok{))}
\NormalTok{)}

\NormalTok{vars <-}\StringTok{ }\KeywordTok{names}\NormalTok{(trans)}
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(trans, mtcars[vars], }\ControlFlowTok{function}\NormalTok{(f, var) }\KeywordTok{f}\NormalTok{(var))}
\end{Highlighting}
\end{Shaded}

Compare and contrast the \texttt{map2()} approach to this \texttt{map()} approach:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map}\NormalTok{(vars, }\OperatorTok{~}\StringTok{ }\NormalTok{trans[[.x]](mtcars[[.x]]))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In the first approach

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(trans, mtcars[vars], }\ControlFlowTok{function}\NormalTok{(f, var) }\KeywordTok{f}\NormalTok{(var))}
\end{Highlighting}
\end{Shaded}

the list of the 2 functions (\texttt{trans}) and the 2 appropriately selected data frame columns (\texttt{mtcars{[}vars{]}}) are supplied to \texttt{map2()}. \texttt{map2()} creates an anonymous function (\texttt{f(var)}) which applies the functions to the variables when \texttt{map2()} iterates over their (similar) indices. On the left-hand side, the respective 2 elements of \texttt{mtcars} are being replaced by their new transformations.

The \texttt{map()} variant

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars[vars] <-}\StringTok{ }\KeywordTok{map}\NormalTok{(vars, }\OperatorTok{~}\StringTok{ }\NormalTok{trans[[.x]](mtcars[[.x]]))}
\end{Highlighting}
\end{Shaded}

does basically the same. However, it directly iterates over the names (\texttt{vars}) of the transformations. Therefore, the data frame columns are selected during the iteration.

Besides the iteration pattern, the approaches differ in the possibilities for appropriate argument naming in the \texttt{.f} argument. In the \texttt{map2()} approach we iterate over the elements of \texttt{x} and \texttt{y}. Therefore, it is possible to choose appropriate placeholders like \texttt{f} and \texttt{var}. This makes the anonymous function more expressive at the cost of making it longer. We think using the formula interface in this way is preferable compared to the rather cryptic \texttt{mtcars{[}vars{]}\ \textless{}-\ map2(trans,\ mtcars{[}vars{]},\ \textasciitilde{}\ .x(.y))}.

In the \texttt{map()} approach we map over the variable names. It is therefore not possible to introduce placeholders for the function and variable names. The formula syntax together with the \texttt{.x} pronoun is pretty compact. The object names and the brackets clearly indicate the application of transformations to specific columns of \texttt{mtcars}. In this case the iteration over the variable names comes in handy, as it highlights the importance of matching between \texttt{trans} and \texttt{mtcars} element names. Together with the replacement form on the left-hand side, this line is relatively easy to inspect.

To summarise, in situations where \texttt{map()} and \texttt{map2()} provide solutions for an iteration problem, several points may be considered before deciding for one or the other approach.

\textbf{{Q4}}: What does \texttt{write.csv()} return, i.e.~what happens if you use it with \texttt{map2()} instead of \texttt{walk2()}?

\textbf{{A}}: \texttt{write.csv()} returns \texttt{NULL}. As we call the function for its side effect (creating a CSV file), \texttt{walk2()} would be appropriate here. Otherwise, we receive a rather uninformative list of \texttt{NULL}s.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{cyls <-}\StringTok{ }\KeywordTok{split}\NormalTok{(mtcars, mtcars}\OperatorTok{$}\NormalTok{cyl)}
\NormalTok{paths <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{tempdir}\NormalTok{(), }\KeywordTok{paste0}\NormalTok{(}\StringTok{"cyl-"}\NormalTok{, }\KeywordTok{names}\NormalTok{(cyls), }\StringTok{".csv"}\NormalTok{))}

\KeywordTok{map2}\NormalTok{(cyls, paths, write.csv)}
\CommentTok{#> $`4`}
\CommentTok{#> NULL}
\CommentTok{#> }
\CommentTok{#> $`6`}
\CommentTok{#> NULL}
\CommentTok{#> }
\CommentTok{#> $`8`}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{predicate-functionals}{%
\section{Predicate Functionals}\label{predicate-functionals}}

\textbf{{Q1}}: Why isn't \texttt{is.na()} a predicate function? What base R function is closest to being a predicate version of \texttt{is.na()}?

\textbf{{A}}: \texttt{is.na()} is not a predicate function, because it returns a logical \emph{vector} the same length as the input, not a single \texttt{TRUE} or \texttt{FALSE}.

\texttt{anyNA()} is the closest equivalent because it always returns a single \texttt{TRUE} or \texttt{FALSE} if there are any missing values present. You could also imagine an \texttt{allNA()} which would return \texttt{TRUE} if all values were missing, but that's considerably less useful so base R does not provide it.

\textbf{{Q2}}: \texttt{simple\_reduce()} has a problem when \texttt{x} is length 0 or length 1. Describe the source of the problem and how you might go about fixing it.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_reduce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  out <-}\StringTok{ }\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{f}\NormalTok{(out, x[[i]])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The loop inside \texttt{simple\_reduce()} always starts with the index 2, and \texttt{seq()} can count both up \emph{and} down:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{#> [1] 2 1 0}
\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 2 1}
\end{Highlighting}
\end{Shaded}

Therefore, subsetting length-0 and length-1 vectors via \texttt{{[}{[}} will lead to a \emph{subscript out of bounds} error. To avoid this, we allow \texttt{simple\_reduce()} to return before the for loop is started and include a default argument for 0-length vectors.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_reduce <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f, default) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\NormalTok{0L) }\KeywordTok{return}\NormalTok{(default)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\NormalTok{1L) }\KeywordTok{return}\NormalTok{(x[[1L]])}
  
\NormalTok{  out <-}\StringTok{ }\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))) \{}
\NormalTok{    out <-}\StringTok{ }\KeywordTok{f}\NormalTok{(out, x[[i]])}
\NormalTok{  \}}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our new \texttt{simple\_reduce()} now works as intended:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{simple_reduce}\NormalTok{(}\KeywordTok{integer}\NormalTok{(}\DecValTok{0}\NormalTok{), }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> Error in simple_reduce(integer(0), `+`): argument "default" is}
\CommentTok{#> missing, with no default}
\KeywordTok{simple_reduce}\NormalTok{(}\KeywordTok{integer}\NormalTok{(}\DecValTok{0}\NormalTok{), }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DataTypeTok{default =}\NormalTok{ 0L)}
\CommentTok{#> [1] 0}
\KeywordTok{simple_reduce}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] 1}
\KeywordTok{simple_reduce}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Implement the \texttt{span()} function from Haskell: given a list \texttt{x} and a predicate function \texttt{f}, \texttt{span(x,\ f)} returns the location of the longest sequential run of elements where the predicate is true. (Hint: you might find \texttt{rle()} helpful.)

\textbf{{A}}: Our \texttt{span\_r()} function returns the indices of the (first occurring) longest sequential run of elements where the predicate is true. If the predicate is never true, the longest run has length 0, in which case we return \texttt{integer(0)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{span_r <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  idx <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(}\KeywordTok{map_lgl}\NormalTok{(x, }\OperatorTok{~}\StringTok{ }\KeywordTok{f}\NormalTok{(.x)))}
\NormalTok{  rle <-}\StringTok{ }\KeywordTok{rle}\NormalTok{(idx) }
  
  \CommentTok{# Check if the predicate is never true}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{any}\NormalTok{(rle}\OperatorTok{$}\NormalTok{values)) \{}
    \KeywordTok{return}\NormalTok{(}\KeywordTok{integer}\NormalTok{(}\DecValTok{0}\NormalTok{))}
\NormalTok{  \}}
  
  \CommentTok{# Find the length of the longest sequence of true values}
\NormalTok{  longest <-}\StringTok{ }\KeywordTok{max}\NormalTok{(rle}\OperatorTok{$}\NormalTok{lengths[rle}\OperatorTok{$}\NormalTok{values])}
  \CommentTok{# Find the positition of the (first) longest run in rle}
\NormalTok{  longest_idx <-}\StringTok{ }\KeywordTok{which}\NormalTok{(rle}\OperatorTok{$}\NormalTok{values }\OperatorTok{&}\StringTok{ }\NormalTok{rle}\OperatorTok{$}\NormalTok{lengths }\OperatorTok{==}\StringTok{ }\NormalTok{longest)[}\DecValTok{1}\NormalTok{]}
  
  \CommentTok{# Add up all lengths in rle before the longest run}
\NormalTok{  ind_before_longest <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(rle}\OperatorTok{$}\NormalTok{lengths[}\KeywordTok{seq_len}\NormalTok{(longest_idx }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)])}
  
\NormalTok{  out_start <-}\StringTok{ }\NormalTok{ind_before_longest }\OperatorTok{+}\StringTok{ }\NormalTok{1L}
\NormalTok{  out_end <-}\StringTok{ }\NormalTok{ind_before_longest }\OperatorTok{+}\StringTok{ }\NormalTok{longest}
\NormalTok{  out_start}\OperatorTok{:}\NormalTok{out_end}
\NormalTok{\}}

\CommentTok{# Check that it works}
\KeywordTok{span_r}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{), is.na)}
\CommentTok{#> integer(0)}
\KeywordTok{span_r}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{,  }\DecValTok{0}\NormalTok{), is.na)}
\CommentTok{#> [1] 1}
\KeywordTok{span_r}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{0}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{), is.na)}
\CommentTok{#> [1] 3 4 5}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Implement \texttt{arg\_max()}. It should take a function and a vector of inputs, and return the elements of the input where the function returns the highest value. For example, \texttt{arg\_max(-10:5,\ function(x)\ x\ \^{}\ 2)} should return \texttt{-10}. \texttt{arg\_max(-5:5,\ function(x)\ x\ \^{}\ 2)} should return \texttt{c(-5,\ 5)}. Also implement the matching \texttt{arg\_min()} function.

\textbf{{A}}: Both functions take a vector of inputs and a function as an argument. The function output is then used to subset the input accordingly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arg_max <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{map_dbl}\NormalTok{(x, f)}
\NormalTok{  x[y }\OperatorTok{==}\StringTok{ }\KeywordTok{max}\NormalTok{(y)]}
\NormalTok{\}}

\NormalTok{arg_min <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, f) \{}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{map_dbl}\NormalTok{(x, f)}
\NormalTok{  x[y }\OperatorTok{==}\StringTok{ }\KeywordTok{min}\NormalTok{(y)]}
\NormalTok{\}}

\KeywordTok{arg_max}\NormalTok{(}\OperatorTok{-}\DecValTok{10}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] -10}
\KeywordTok{arg_min}\NormalTok{(}\OperatorTok{-}\DecValTok{10}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 0}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: The function below scales a vector so it falls in the range {[}0, 1{]}. How would you apply it to every column of a data frame? How would you apply it to every numeric column in a data frame?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{scale01 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  rng <-}\StringTok{ }\KeywordTok{range}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  (x }\OperatorTok{-}\StringTok{ }\NormalTok{rng[}\DecValTok{1}\NormalTok{]) }\OperatorTok{/}\StringTok{ }\NormalTok{(rng[}\DecValTok{2}\NormalTok{] }\OperatorTok{-}\StringTok{ }\NormalTok{rng[}\DecValTok{1}\NormalTok{])}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: To apply a function to every column of a data frame, we can use \texttt{purrr::modify()} (or \texttt{purrr::map\_dfr()}), which also conveniently returns a data frame. To limit the application to numeric columns, the scoped version \texttt{modify\_if()} can be used.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{modify_if}\NormalTok{(mtcars, is.numeric, scale01)}
\end{Highlighting}
\end{Shaded}

\hypertarget{base-functionals}{%
\section{Base functionals}\label{base-functionals}}

\textbf{{Q1}}: How does \texttt{apply()} arrange the output? Read the documentation and perform some experiments.

\textbf{{A}}: Basically \texttt{apply()} applies a function over the margins of an array. In the two-dimensional case, the margins are just the rows and columns of a matrix. Let's make this concrete.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arr2 <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{dim =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\KeywordTok{rownames}\NormalTok{(arr2) <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"row"}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{colnames}\NormalTok{(arr2) <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"col"}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\NormalTok{arr2}
\CommentTok{#>      col1 col2 col3 col4}
\CommentTok{#> row1    1    4    7   10}
\CommentTok{#> row2    2    5    8   11}
\CommentTok{#> row3    3    6    9   12}
\end{Highlighting}
\end{Shaded}

When we apply the \texttt{head()} function over the first margin of \texttt{arr2()} (i.e.~the rows), the results are contained in the columns of the output, transposing the array compared to the original input.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(arr2, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{])}
\CommentTok{#>      row1 row2 row3}
\CommentTok{#> col1    1    2    3}
\CommentTok{#> col2    4    5    6}
\end{Highlighting}
\end{Shaded}

And vice versa if we apply over the second margin (the columns):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(arr2, }\DecValTok{2}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{])}
\CommentTok{#>      col1 col2 col3 col4}
\CommentTok{#> row1    1    4    7   10}
\CommentTok{#> row2    2    5    8   11}
\end{Highlighting}
\end{Shaded}

The output of \texttt{apply()} is organised first by the margins being operated over, then the results of the function. This can become quite confusing for higher dimensional arrays.

\textbf{{Q2}}: What do \texttt{eapply()} and \texttt{rapply()} do? Does \texttt{\{purrr\}} have equivalents?

\textbf{{A}}: \texttt{eapply()} is a variant of \texttt{lapply()}, which iterates over the (named) elements of an environment. In \texttt{\{purrr\}} there is no equivalent for \texttt{eapply()} as \texttt{\{purrr\}} mainly provides functions that operate on vectors and functions, but not on environments.

\texttt{rapply()} applies a function to all elements of a list recursively. This function makes it possible to limit the application of the function to specified classes (default \texttt{classes\ =\ ANY}). One may also specify how elements of other classes should remain: as their identity (\texttt{how\ =\ replace}) or another value (\texttt{default\ =\ NULL}). The closest equivalent in \texttt{\{purrr\}} is \texttt{modify\_depth()}, which allows you to modify elements at a specified depth in a nested list.

\textbf{{Q3}}: Challenge: read about the \href{https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-12.html\#\%25_idx_1096}{fixed point algorithm}. Complete the exercises using R.

\textbf{{A}}: A number \(x\) is called a fixed point of a function \(f\) if it satisfies the equation \(f(x) = x\). For some functions we may find a fixed point by beginning with a starting value and applying \(f\) repeatedly. Here \texttt{fixed\_point()} acts as a functional because it takes a function as an argument.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fixed_point <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, x_init, }\DataTypeTok{n_max =} \DecValTok{10000}\NormalTok{, }\DataTypeTok{tol =} \FloatTok{0.0001}\NormalTok{) \{}
\NormalTok{  n <-}\StringTok{ }\DecValTok{0}
\NormalTok{  x <-}\StringTok{ }\NormalTok{x_init}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x)}
  
\NormalTok{  is_fixed_point <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
    \KeywordTok{abs}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\NormalTok{y) }\OperatorTok{<}\StringTok{ }\NormalTok{tol}
\NormalTok{  \}}
  
  \ControlFlowTok{while}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is_fixed_point}\NormalTok{(x, y)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{y}
\NormalTok{    y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(y)}
    
    \CommentTok{# Make sure we eventually stop}
\NormalTok{    n <-}\StringTok{ }\NormalTok{n }\OperatorTok{+}\StringTok{ }\DecValTok{1}
    \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{>}\StringTok{ }\NormalTok{n_max) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Failed to converge."}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  \}}
  
\NormalTok{  x}
\NormalTok{\}}


\CommentTok{# Functions with fixed points}
\KeywordTok{fixed_point}\NormalTok{(sin, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 0.0843}
\KeywordTok{fixed_point}\NormalTok{(cos, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 0.739}

\CommentTok{# Functions without fixed points}
\NormalTok{add_one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\KeywordTok{fixed_point}\NormalTok{(add_one, }\DataTypeTok{x_init =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> Error: Failed to converge.}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-factories}{%
\chapter{Function factories}\label{function-factories}}

\hypertarget{prerequisites-4}{%
\section*{Prerequisites}\label{prerequisites-4}}


For most of this chapter base R is sufficient. Just a few exercises require the \texttt{\{rlang\}}, \texttt{\{dplyr\}}, \texttt{\{purrr\}} and \texttt{\{ggplot2\}} packages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(purrr)}
\KeywordTok{library}\NormalTok{(ggplot2)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{factory-fundamentals}{%
\section{Factory fundamentals}\label{factory-fundamentals}}

\textbf{{Q1}}: The definition of \texttt{force()} is simple:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{force}
\CommentTok{#> function (x) }
\CommentTok{#> x}
\CommentTok{#> <bytecode: 0x0000000012d99278>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

Why is it better to \texttt{force(x)} instead of just \texttt{x}?

\textbf{{A}}: As you can see \texttt{force(x)} is similar to \texttt{x}. As being mentioned in Advanced R we prefer this explicit form, because

\begin{quote}
using this function clearly indicates that you're forcing evaluation, not that you've accidentally typed \texttt{x}."
\end{quote}

\textbf{{Q2}}: Base R contains two function factories, \texttt{approxfun()} and \texttt{ecdf()}. Read their documentation and experiment to figure out what the functions do and what they return.

\textbf{{A}}: Let's begin with \texttt{approxfun()} as it is used within \texttt{ecdf()} as well:

\texttt{approxfun()} takes a combination of data points (x and y values) as input and returns a stepwise linear (or constant) interpolation function. To find out what this means exactly, we first create a few random data points.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(x, y, }\DataTypeTok{lwd =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-4-1} \end{center}

Next, we use \texttt{approxfun()} to construct the linear and constant interpolation functions for our \texttt{x} and \texttt{y} values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f_lin <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y)}
\NormalTok{f_con <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{method =} \StringTok{"constant"}\NormalTok{)}

\CommentTok{# Both functions exactly reproduce their input y values}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{f_lin}\NormalTok{(x), y)}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{f_con}\NormalTok{(x), y)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

When we apply these functions to new x values, these are mapped to the lines connecting the initial y values (linear case) or to the same y value as for the next smallest initial x value (constant case).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_new <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1000}\NormalTok{)}

\KeywordTok{plot}\NormalTok{(x, y, }\DataTypeTok{lwd =} \DecValTok{10}\NormalTok{)}
\KeywordTok{points}\NormalTok{(x_new, }\KeywordTok{f_lin}\NormalTok{(x_new), }\DataTypeTok{col =} \StringTok{"cornflowerblue"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}
\KeywordTok{points}\NormalTok{(x_new, }\KeywordTok{f_con}\NormalTok{(x_new), }\DataTypeTok{col =} \StringTok{"firebrick"}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-6-1} \end{center}

However, both functions are only defined within \texttt{range(x)}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f_lin}\NormalTok{(}\KeywordTok{range}\NormalTok{(x))}
\CommentTok{#> [1] 0.402 0.175}
\KeywordTok{f_con}\NormalTok{(}\KeywordTok{range}\NormalTok{(x))}
\CommentTok{#> [1] 0.402 0.175}

\NormalTok{(eps <-}\StringTok{ }\NormalTok{.Machine}\OperatorTok{$}\NormalTok{double.neg.eps)}
\CommentTok{#> [1] 1.11e-16}

\KeywordTok{f_lin}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{min}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{eps, }\KeywordTok{max}\NormalTok{(x) }\OperatorTok{+}\StringTok{ }\NormalTok{eps))}
\CommentTok{#> [1] NA NA}
\KeywordTok{f_con}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\KeywordTok{min}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{eps, }\KeywordTok{max}\NormalTok{(x) }\OperatorTok{+}\StringTok{ }\NormalTok{eps))}
\CommentTok{#> [1] NA NA}
\end{Highlighting}
\end{Shaded}

To change this behaviour, one can set \texttt{rule\ =\ 2}. This leads to the result that for values outside of \texttt{range(x)} the boundary values of the function are returned.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f_lin <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{rule =} \DecValTok{2}\NormalTok{)}
\NormalTok{f_con <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{method =} \StringTok{"constant"}\NormalTok{, }\DataTypeTok{rule =} \DecValTok{2}\NormalTok{)}

\KeywordTok{f_lin}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\OtherTok{Inf}\NormalTok{, }\OtherTok{Inf}\NormalTok{))}
\CommentTok{#> [1] 0.402 0.175}
\KeywordTok{f_con}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\OtherTok{Inf}\NormalTok{, }\OtherTok{Inf}\NormalTok{))}
\CommentTok{#> [1] 0.402 0.175}
\end{Highlighting}
\end{Shaded}

Another option is to customise the return values as individual constants for each side via \texttt{yleft} and/or \texttt{yright}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f_lin <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{yleft =} \DecValTok{5}\NormalTok{)}
\NormalTok{f_con <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{method =} \StringTok{"constant"}\NormalTok{, }\DataTypeTok{yleft =} \DecValTok{5}\NormalTok{, }\DataTypeTok{yright =} \DecValTok{-5}\NormalTok{)}

\KeywordTok{f_lin}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\OtherTok{Inf}\NormalTok{, }\OtherTok{Inf}\NormalTok{))}
\CommentTok{#> [1]  5 NA}
\KeywordTok{f_con}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\OtherTok{Inf}\NormalTok{, }\OtherTok{Inf}\NormalTok{))}
\CommentTok{#> [1]  5 -5}
\end{Highlighting}
\end{Shaded}

Further, \texttt{approxfun()} provides the option to shift the y values for \texttt{method\ =\ "constant"} between their left and right values. According to the documentation this indicates a compromise between left- and right-continuous steps.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f_con <-}\StringTok{ }\KeywordTok{approxfun}\NormalTok{(x, y, }\DataTypeTok{method =} \StringTok{"constant"}\NormalTok{, }\DataTypeTok{f =} \FloatTok{.5}\NormalTok{)}

\KeywordTok{plot}\NormalTok{(x, y, }\DataTypeTok{lwd =} \DecValTok{10}\NormalTok{)}
\KeywordTok{points}\NormalTok{(x_new, }\KeywordTok{f_con}\NormalTok{(x_new), }\DataTypeTok{pch =} \DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-10-1} \end{center}

Finally, the \texttt{ties} argument allows to aggregate y values if multiple ones were provided for the same x value. E.g. in the following line we use \texttt{mean()} to aggregate these y values before they are used for the interpolation \texttt{approxfun(x\ =\ c(1,1,2),\ y\ =\ 1:3,\ ties\ =\ mean)}.

Next, we focus on \texttt{ecdf()}. ``ecdf'' is an acronym for empirical cumulative distribution function. For a numeric vector of density values, \texttt{ecdf()} initially creates the (x, y) pairs for the nodes of the density function and then passes these pairs to \texttt{approxfun()}, which gets called with specifically adapted settings (\texttt{approxfun(vals,\ cumsum(tabulate(match(x,\ vals)))/n,\ method\ =\ "constant",\ yleft\ =\ 0,\ yright\ =\ 1,\ f\ =\ 0,\ ties\ =\ "ordered")}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{f_ecdf <-}\StringTok{ }\KeywordTok{ecdf}\NormalTok{(x)}
\KeywordTok{class}\NormalTok{(f_ecdf)}
\CommentTok{#> [1] "ecdf"     "stepfun"  "function"}

\KeywordTok{plot}\NormalTok{(x, }\KeywordTok{f_ecdf}\NormalTok{(x), }\DataTypeTok{lwd =} \DecValTok{10}\NormalTok{, }\DataTypeTok{ylim =} \DecValTok{0}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-11-1} \end{center}

New values are then mapped on the y value of the next smallest x value from within the initial input.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_new <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1000}\NormalTok{)}

\KeywordTok{plot}\NormalTok{(x, }\KeywordTok{f_ecdf}\NormalTok{(x), }\DataTypeTok{lwd =} \DecValTok{10}\NormalTok{, }\DataTypeTok{ylim =} \DecValTok{0}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\KeywordTok{points}\NormalTok{(x_new, }\KeywordTok{f_ecdf}\NormalTok{(x_new), }\DataTypeTok{ylim =} \DecValTok{0}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-12-1} \end{center}

\textbf{{Q3}}: Create a function \texttt{pick()} that takes an index, \texttt{i}, as an argument and returns a function with an argument \texttt{x} that subsets \texttt{x} with \texttt{i}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{pick}\NormalTok{(}\DecValTok{1}\NormalTok{)(x)}
\CommentTok{# should be equivalent to}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}

\KeywordTok{lapply}\NormalTok{(mtcars, }\KeywordTok{pick}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\CommentTok{# should be equivalent to}
\KeywordTok{lapply}\NormalTok{(mtcars, }\ControlFlowTok{function}\NormalTok{(x) x[[}\DecValTok{5}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In this exercise \texttt{pick(i)} acts as a function factory, which returns the required subsetting function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pick <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(i) \{}
  \KeywordTok{force}\NormalTok{(i)}
  
  \ControlFlowTok{function}\NormalTok{(x) x[[i]]}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{pick}\NormalTok{(}\DecValTok{1}\NormalTok{)(x))}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{lapply}\NormalTok{(mtcars, }\ControlFlowTok{function}\NormalTok{(x) x[[}\DecValTok{5}\NormalTok{]]),}
  \KeywordTok{lapply}\NormalTok{(mtcars, }\KeywordTok{pick}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Create a function that creates functions that compute the i\textsuperscript{th} \href{http://en.wikipedia.org/wiki/Central_moment}{central moment} of a numeric vector. You can test it by running the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m1}\NormalTok{(x), }\DecValTok{0}\NormalTok{))}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m2}\NormalTok{(x), }\KeywordTok{var}\NormalTok{(x) }\OperatorTok{*}\StringTok{ }\DecValTok{99} \OperatorTok{/}\StringTok{ }\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The first moment is closely related to the mean and describes the average deviation from the mean, which is 0 (within numerical margin of error). The second moment describes the variance of the input data. If we want to compare it to \texttt{var}, we need to undo \href{https://en.wikipedia.org/wiki/Bessel\%27s_correction}{Bessel's correction} by multiplying with \(\frac{N-1}{N}\).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{moment <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(i) \{}
  \KeywordTok{force}\NormalTok{(i)}
  
  \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\OperatorTok{^}\StringTok{ }\NormalTok{i) }\OperatorTok{/}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{m1 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m1}\NormalTok{(x), }\DecValTok{0}\NormalTok{)  }\CommentTok{# removed stopifnot() for clarity}
\CommentTok{#> [1] TRUE}
\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m2}\NormalTok{(x), }\KeywordTok{var}\NormalTok{(x) }\OperatorTok{*}\StringTok{ }\DecValTok{99} \OperatorTok{/}\StringTok{ }\DecValTok{100}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: What happens if you don't use a closure? Make predictions, then verify with the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\DecValTok{0}
\NormalTok{new_counter2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  i <<-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{  i}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Without the captured and encapsulated environment of a closure the counts will be stored in the global environment. Here they can be overwritten or deleted as well as interfere with other counters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{new_counter2}\NormalTok{()}
\CommentTok{#> [1] 1}
\NormalTok{i}
\CommentTok{#> [1] 1}
\KeywordTok{new_counter2}\NormalTok{()}
\CommentTok{#> [1] 2}
\NormalTok{i}
\CommentTok{#> [1] 2}

\NormalTok{i <-}\StringTok{ }\DecValTok{0}
\KeywordTok{new_counter2}\NormalTok{()}
\CommentTok{#> [1] 1}
\NormalTok{i}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: What happens if you use \texttt{\textless{}-} instead of \texttt{\textless{}\textless{}-}? Make predictions, then verify with the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_counter3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{  i <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{    i}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Without the super assignment \texttt{\textless{}\textless{}-}, the counter will always return 1. The counter always starts in a new execution environment within the same enclosing environment, which contains an unchanged value for \texttt{i} (in this case it remains 0).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_counter_}\DecValTok{3}\NormalTok{ <-}\StringTok{ }\KeywordTok{new_counter3}\NormalTok{()}

\KeywordTok{new_counter_3}\NormalTok{()}
\CommentTok{#> [1] 1}
\KeywordTok{new_counter_3}\NormalTok{()}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphical-factories}{%
\section{Graphical factories}\label{graphical-factories}}

\textbf{{Q1}}: Compare and contrast \texttt{ggplot2::label\_bquote()} with \texttt{scales::number\_format()}.

\textbf{{A}}: Both functions will help you in styling your output, e.g.~in your plots and they do this by returning the desired formatting function to you.

\texttt{ggplot2::label\_bquote()} takes relatively straightforward \href{https://stat.ethz.ch/R-manual/R-patched/library/grDevices/html/plotmath.html}{plotmath} expressions and uses them for faceting labels in \texttt{\{ggplot2\}}. Because this function is used in \texttt{\{ggplot2\}} it needs to return a function of \texttt{class\ =\ "labeller"}.

\texttt{scales::number\_format()} initially \texttt{force()}s the computation of all parameters. It's essentially a parametrised wrapper around \texttt{scales::number()} and will help you format numbers appropriately. It will return a simple function.

\hypertarget{statistical-factories}{%
\section{Statistical factories}\label{statistical-factories}}

\textbf{{Q1}}: In \texttt{boot\_model()}, why don't I need to force the evaluation of \texttt{df} or \texttt{model}?

\textbf{{A}}: \texttt{boot\_model()} ultimately returns a function, and whenever you return a function you need to make sure all the inputs are explicitly evaluated. Here that happens automatically because we use \texttt{df} and \texttt{formula} in \texttt{lm()} before returning the function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_model <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, formula) \{}
\NormalTok{  mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(formula, }\DataTypeTok{data =}\NormalTok{ df)}
\NormalTok{  fitted <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(}\KeywordTok{fitted}\NormalTok{(mod))}
\NormalTok{  resid <-}\StringTok{ }\KeywordTok{unname}\NormalTok{(}\KeywordTok{resid}\NormalTok{(mod))}
  \KeywordTok{rm}\NormalTok{(mod)}
  
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    fitted }\OperatorTok{+}\StringTok{ }\KeywordTok{sample}\NormalTok{(resid)}
\NormalTok{  \}}
\NormalTok{\} }
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Why might you formulate the Box-Cox transformation like this?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boxcox3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
      \KeywordTok{log}\NormalTok{(x)}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{    \}}
\NormalTok{  \}  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{boxcox3()} returns a function where \texttt{x} is fixed (though it is not forced, so it may be manipulated later). This allows us to apply and test different transformations for different inputs and give them a descriptive name.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boxcox_airpassengers <-}\StringTok{ }\KeywordTok{boxcox3}\NormalTok{(AirPassengers)}

\KeywordTok{plot}\NormalTok{(}\KeywordTok{boxcox_airpassengers}\NormalTok{(}\DecValTok{0}\NormalTok{))}
\KeywordTok{plot}\NormalTok{(}\KeywordTok{boxcox_airpassengers}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\KeywordTok{plot}\NormalTok{(}\KeywordTok{boxcox_airpassengers}\NormalTok{(}\DecValTok{2}\NormalTok{))}
\KeywordTok{plot}\NormalTok{(}\KeywordTok{boxcox_airpassengers}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.49\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-23-1} \includegraphics[width=0.49\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-23-2} \includegraphics[width=0.49\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-23-3} \includegraphics[width=0.49\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-23-4} \end{center}

\textbf{{Q3}}: Why don't you need to worry that \texttt{boot\_permute()} stores a copy of the data inside the function that it generates?

\textbf{{A}}: \texttt{boot\_permute()} is defined in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_permute <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{nrow}\NormalTok{(df)}
  \KeywordTok{force}\NormalTok{(var)}
  
  \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{    col <-}\StringTok{ }\NormalTok{df[[var]]}
\NormalTok{    col[}\KeywordTok{sample}\NormalTok{(n, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)]}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We don't need to worry that it stores a copy of the data, because it actually doesn't store one; it's just a name that points to the same underlying object in memory.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{boot_mtcars1 <-}\StringTok{ }\KeywordTok{boot_permute}\NormalTok{(mtcars, }\StringTok{"mpg"}\NormalTok{)}

\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(mtcars)}
\CommentTok{#> 7,208 B}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_size}\NormalTok{(boot_mtcars1)}
\CommentTok{#> 20,232 B}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{obj_sizes}\NormalTok{(mtcars, boot_mtcars1)}
\CommentTok{#> *  7,208 B}
\CommentTok{#> * 13,024 B}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: How much time does \texttt{ll\_poisson2()} save compared to \texttt{ll\_poisson1()}? Use \texttt{bench::mark()} to see how much faster the optimisation occurs. How does changing the length of \texttt{x} change the results?

\textbf{{A}}: Let us recall the definitions of \texttt{ll\_poisson1()}, \texttt{ll\_poisson2()} and the test data \texttt{x1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ll_poisson1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
  
  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \KeywordTok{log}\NormalTok{(lambda) }\OperatorTok{*}\StringTok{ }\KeywordTok{sum}\NormalTok{(x) }\OperatorTok{-}\StringTok{ }\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{lfactorial}\NormalTok{(x))}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{ll_poisson2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
\NormalTok{  sum_x <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(x)}
\NormalTok{  c <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{lfactorial}\NormalTok{(x))}
  
  \ControlFlowTok{function}\NormalTok{(lambda) \{}
    \KeywordTok{log}\NormalTok{(lambda) }\OperatorTok{*}\StringTok{ }\NormalTok{sum_x }\OperatorTok{-}\StringTok{ }\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\NormalTok{c}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{41}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{38}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{24}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{31}\NormalTok{, }\DecValTok{38}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A benchmark on \texttt{x1} reveals a performance improvement of factor 2 for \texttt{ll\_poisson2()} over \texttt{ll\_poisson1()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \DataTypeTok{llp1 =} \KeywordTok{optimise}\NormalTok{(}\KeywordTok{ll_poisson1}\NormalTok{(x1), }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{llp2 =} \KeywordTok{optimise}\NormalTok{(}\KeywordTok{ll_poisson2}\NormalTok{(x1), }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression      min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 llp1         36.9µs   42.3µs    21333.    12.8KB     22.3}
\CommentTok{#> 2 llp2         18.8µs   21.2µs    40063.        0B     24.1}
\end{Highlighting}
\end{Shaded}

As the redundant calculations within \texttt{ll\_poisson1()} become more expensive with growing length of \texttt{x1}, we expect even further relative performance improvements for \texttt{ll\_poisson2()}. The following benchmark reveals a relative performance improvement of factor 20 for \texttt{ll\_poisson2()} when \texttt{x1} is of length 100,000:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bench_poisson <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x_length) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{rpois}\NormalTok{(x_length, 100L)}
  
\NormalTok{  bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
    \DataTypeTok{llp1 =} \KeywordTok{optimise}\NormalTok{(}\KeywordTok{ll_poisson1}\NormalTok{(x), }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{),}
    \DataTypeTok{llp2 =} \KeywordTok{optimise}\NormalTok{(}\KeywordTok{ll_poisson2}\NormalTok{(x), }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{), }\DataTypeTok{maximum =} \OtherTok{TRUE}\NormalTok{),}
    \DataTypeTok{time_unit =} \StringTok{"ms"}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{performances <-}\StringTok{ }\KeywordTok{map_dfr}\NormalTok{(}\DecValTok{10}\OperatorTok{^}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), bench_poisson)}

\NormalTok{df_perf <-}\StringTok{ }\KeywordTok{tibble}\NormalTok{(}
  \DataTypeTok{x_length =} \KeywordTok{rep}\NormalTok{(}\DecValTok{10}\OperatorTok{^}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), }\DataTypeTok{each =} \DecValTok{2}\NormalTok{),}
  \DataTypeTok{method   =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{attr}\NormalTok{(performances}\OperatorTok{$}\NormalTok{expression, }\StringTok{"description"}\NormalTok{), }\DecValTok{5}\NormalTok{),}
  \DataTypeTok{median   =}\NormalTok{ performances}\OperatorTok{$}\NormalTok{median}
\NormalTok{)}

\KeywordTok{ggplot}\NormalTok{(df_perf, }\KeywordTok{aes}\NormalTok{(x_length, median, }\DataTypeTok{col =}\NormalTok{ method)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{linetype =} \DecValTok{2}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_x_log10}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}
    \DataTypeTok{x =} \StringTok{"Length of x"}\NormalTok{,}
    \DataTypeTok{y =} \StringTok{"Execution Time (ms)"}\NormalTok{,}
    \DataTypeTok{color =} \StringTok{"Method"}
\NormalTok{  ) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"top"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{10_Function_factories_files/figure-latex/unnamed-chunk-28-1} \end{center}

\hypertarget{function-factories-functionals}{%
\section{Function factories + functionals}\label{function-factories-functionals}}

\textbf{{Q1}}: Which of the following commands is equivalent to \texttt{with(x,\ f(z))}?

\begin{enumerate}
\def\labelenumi{(\alph{enumi})}
\tightlist
\item
  \texttt{x\$f(x\$z)}.
\item
  \texttt{f(x\$z)}.
\item
  \texttt{x\$f(z)}.
\item
  \texttt{f(z)}.
\item
  It depends.
\end{enumerate}

\textbf{{A}}: (e) ``It depends'' is the correct answer. Usually \texttt{with()} is used with a data frame, so you'd usually expect (b), but if \texttt{x} is a list, it could be any of the options.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{mean}
\NormalTok{z <-}\StringTok{ }\DecValTok{1}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{f =}\NormalTok{ mean, }\DataTypeTok{z =} \DecValTok{1}\NormalTok{)}

\KeywordTok{identical}\NormalTok{(}\KeywordTok{with}\NormalTok{(x, }\KeywordTok{f}\NormalTok{(z)), x}\OperatorTok{$}\KeywordTok{f}\NormalTok{(x}\OperatorTok{$}\NormalTok{z))}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{with}\NormalTok{(x, }\KeywordTok{f}\NormalTok{(z)), }\KeywordTok{f}\NormalTok{(x}\OperatorTok{$}\NormalTok{z))}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{with}\NormalTok{(x, }\KeywordTok{f}\NormalTok{(z)), x}\OperatorTok{$}\KeywordTok{f}\NormalTok{(z))}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{with}\NormalTok{(x, }\KeywordTok{f}\NormalTok{(z)), }\KeywordTok{f}\NormalTok{(z))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Compare and contrast the effects of \texttt{env\_bind()} vs.~\texttt{attach()} for the following code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{mean =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{sum =} \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{)}

\KeywordTok{attach}\NormalTok{(funs)}
\CommentTok{#> The following objects are masked from package:base:}
\CommentTok{#> }
\CommentTok{#>     mean, sum}
\NormalTok{mean <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{)}
\KeywordTok{detach}\NormalTok{(funs)}

\KeywordTok{env_bind}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{(), }\OperatorTok{!!!}\NormalTok{funs)}
\NormalTok{mean <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{stop}\NormalTok{(}\StringTok{"Hi!"}\NormalTok{) }
\KeywordTok{env_unbind}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{(), }\KeywordTok{names}\NormalTok{(funs))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{attach()} adds \texttt{funs} to the search path. Therefore, the provided functions are found before their respective versions from the \texttt{\{base\}} package. Further, they cannot get accidently overwritten by similar named functions in the global environment. One annoying downside of using \texttt{attach()} is the possibility to attach the same object multiple times, making it necessary to call \texttt{detach()} equally often.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attach}\NormalTok{(funs)}
\CommentTok{#> The following objects are masked from package:base:}
\CommentTok{#> }
\CommentTok{#>     mean, sum}
\KeywordTok{attach}\NormalTok{(funs)}
\CommentTok{#> The following objects are masked from funs (pos = 3):}
\CommentTok{#> }
\CommentTok{#>     mean, sum}
\CommentTok{#> }
\CommentTok{#> The following objects are masked from package:base:}
\CommentTok{#> }
\CommentTok{#>     mean, sum}

\KeywordTok{head}\NormalTok{(}\KeywordTok{search}\NormalTok{())}
\CommentTok{#> [1] ".GlobalEnv"      "funs"            "funs"           }
\CommentTok{#> [4] "package:ggplot2" "package:purrr"   "package:dplyr"}
\KeywordTok{detach}\NormalTok{(funs)}
\KeywordTok{detach}\NormalTok{(funs)}
\end{Highlighting}
\end{Shaded}

In contrast \texttt{rlang::env\_bind()} just adds the functions in \texttt{fun} to the global environment. No further side effects are introduced, and the functions are overwritten when similarly named functions are defined.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{env_bind}\NormalTok{(}\KeywordTok{globalenv}\NormalTok{(), }\OperatorTok{!!!}\NormalTok{funs)}
\KeywordTok{head}\NormalTok{(}\KeywordTok{search}\NormalTok{())}
\CommentTok{#> [1] ".GlobalEnv"             "package:ggplot2"       }
\CommentTok{#> [3] "package:purrr"          "package:dplyr"         }
\CommentTok{#> [5] "package:rlang"          "package:palmerpenguins"}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-operators}{%
\chapter{Function operators}\label{function-operators}}

\hypertarget{prerequisites-5}{%
\section*{Prerequisites}\label{prerequisites-5}}


Also, in the third chapter on functional programming we make relatively frequent use of the \texttt{\{purrr\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{existing-function-operators}{%
\section{Existing function operators}\label{existing-function-operators}}

\textbf{{Q1}}: Base R provides a function operator in the form of \texttt{Vectorize()}. What does it do? When might you use it?

\textbf{{A}}: In R a lot of functions are ``vectorised''. Vectorised has two meanings. First, it means (broadly) that a function inputs a vector or vectors and does something to each element. Secondly, it usually implies that these operations are implemented in a compiled language such as C or Fortran, so that the implementation is very fast.

However, despite what the function's name implies, \texttt{Vectorize()} is not able to speed up the provided function. It rather changes the input format of the supplied arguments (\texttt{vectorize.args}), so that they can be iterated over.

Let's take a look at an example from the documentation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vrep <-}\StringTok{ }\KeywordTok{Vectorize}\NormalTok{(rep.int)}
\NormalTok{vrep}
\CommentTok{#> function (x, times) }
\CommentTok{#> \{}
\CommentTok{#>   args <- lapply(as.list(match.call())[-1L], eval, parent.frame())}
\CommentTok{#>   names <- if (is.null(names(args))) }
\CommentTok{#>     character(length(args))}
\CommentTok{#>   else names(args)}
\CommentTok{#>   dovec <- names %in% vectorize.args}
\CommentTok{#>   do.call("mapply", c(FUN = FUN, args[dovec],}
\CommentTok{#>                       MoreArgs = list(args[!dovec]), }
\CommentTok{#>                       SIMPLIFY = SIMPLIFY, USE.NAMES = USE.NAMES))}
\CommentTok{#> \}}
\CommentTok{#> <environment: 0x558902db65d0>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Application}
\KeywordTok{vrep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1 1 1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 2 2 2 2}
\end{Highlighting}
\end{Shaded}

\texttt{Vectorize()} provides a convenient and concise notation to iterate over multiple arguments but has some major drawbacks that mean you generally shouldn't use it. See \url{https://www.jimhester.com/post/2018-04-12-vectorize/} for more details.

\textbf{{Q2}}: Read the source code for \texttt{possibly()}. How does it work?

\textbf{{A}}: \texttt{possibly()} modifies functions to return a specified default value (\texttt{otherwise}) in case of an error and to suppress any error messages (\texttt{quiet\ =\ TRUE}).

While reading the source code, we notice that \texttt{possibly()} internally uses \texttt{purrr::as\_mapper()}. This enables users to supply not only functions, but also formulas or atomics via the same syntax as known from other functions in the \texttt{\{purrr\}} package. Besides this, the new default value (\texttt{otherwise}) gets evaluated once to make it (almost) immutable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{possibly}
\CommentTok{#> function (.f, otherwise, quiet = TRUE) }
\CommentTok{#> \{}
\CommentTok{#>     .f <- as_mapper(.f)}
\CommentTok{#>     force(otherwise)}
\CommentTok{#>     function(...) \{}
\CommentTok{#>         tryCatch(.f(...), error = function(e) \{}
\CommentTok{#>             if (!quiet) }
\CommentTok{#>                 message("Error: ", e$message)}
\CommentTok{#>             otherwise}
\CommentTok{#>         \}, interrupt = function(e) \{}
\CommentTok{#>             stop("Terminated by user", call. = FALSE)}
\CommentTok{#>         \})}
\CommentTok{#>     \}}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000018a56b18>}
\CommentTok{#> <environment: namespace:purrr>}
\end{Highlighting}
\end{Shaded}

The main functionality of \texttt{possibly()} is provided by \texttt{base::tryCatch()}. In this part the supplied function (\texttt{.f}) gets wrapped and the error and interrupt handling are specified.

\textbf{{Q3}}: Read the source code for \texttt{safely()}. How does it work?

\textbf{{A}}: \texttt{safely()} modifies functions to return a list, containing the elements \texttt{result} and \texttt{error}. It works in a similar fashion as \texttt{possibly()} and besides using \texttt{as\_mapper()}, \texttt{safely()} also provides the \texttt{otherwise} and \texttt{quiet} arguments. However, in order to provide the result and the error in a consistent way, the \texttt{tryCatch()} part of the implementation returns a list with similar structure for both cases. In the case of successful evaluation \texttt{error} equals to \texttt{NULL} and in case of an error \texttt{result} equals to \texttt{otherwise}, which is \texttt{NULL} by default.

As the \texttt{tryCatch()} part is hidden in the internal \texttt{purrr:::capture\_output()} function, we provide it here in addition to \texttt{safely()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{safely}
\CommentTok{#> function (.f, otherwise = NULL, quiet = TRUE) }
\CommentTok{#> \{}
\CommentTok{#>     .f <- as_mapper(.f)}
\CommentTok{#>     function(...) capture_error(.f(...), otherwise, quiet)}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000018cc3c50>}
\CommentTok{#> <environment: namespace:purrr>}

\NormalTok{purrr}\OperatorTok{:::}\NormalTok{capture_error}
\CommentTok{#> function (code, otherwise = NULL, quiet = TRUE) }
\CommentTok{#> \{}
\CommentTok{#>     tryCatch(list(result = code, error = NULL), error = function(e) \{}
\CommentTok{#>         if (!quiet) }
\CommentTok{#>             message("Error: ", e$message)}
\CommentTok{#>         list(result = otherwise, error = e)}
\CommentTok{#>     \}, interrupt = function(e) \{}
\CommentTok{#>         stop("Terminated by user", call. = FALSE)}
\CommentTok{#>     \})}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000018d73830>}
\CommentTok{#> <environment: namespace:purrr>}
\end{Highlighting}
\end{Shaded}

Take a look at Advanced R or the documentation of \texttt{safely()} to see how you can take advantage of this behaviour, e.g.~when fitting many models.

\hypertarget{case-study-creating-your-own-function-operators}{%
\section{Case study: Creating your own function operators}\label{case-study-creating-your-own-function-operators}}

\textbf{{Q1}}: Weigh the pros and cons of \texttt{download.file\ \%\textgreater{}\%\ dot\_every(10)\ \%\textgreater{}\%\ delay\_by(0.1)} versus \texttt{download.file\ \%\textgreater{}\%\ delay\_by(0.1)\ \%\textgreater{}\%\ dot\_every(10)}.

\textbf{{A}}: Both commands will print a dot every 10 downloads and will take the same amount of time to run, so the differences may seem quite subtle.

In the first case, first the dot functionality is added to \texttt{download.file()}. Then the delay is added to this already tweaked function. This implies, that the printing of the dot will also be delayed, and the first dot will be printed as soon as the download for the 10th URL starts.

In the latter case the delay is added first and the dot-functionality is wrapped around it. This order will print the first dot immediately after the 9th download is finished, then the short delay occurs before the 10th download actually starts.

\textbf{{Q2}}: Should you memoise \texttt{file.download()}? Why or why not?

\textbf{{A}}: Memoising \texttt{file.download()} will only work if the files are immutable, i.e.~if the file at a given URL is always same. There's no point memoising unless this is true. Even if this is true, however, memoise has to store the results in memory, and large files will potentially take up a lot of memory.

This implies that it's probably not beneficial to memoise \texttt{file.download()} in most cases. The only exception is if you are downloading small files many times, and the file at a given URL is guaranteed not to change.

\textbf{{Q3}}: Create a function operator that reports whenever a file is created or deleted in the working directory, using \texttt{dir()} and \texttt{setdiff()}. What other global function effects might you want to track?

\textbf{{A}}: We start with a function that reports the difference between two vectors containing file names:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dir_compare <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(old, new) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{setequal}\NormalTok{(old, new)) \{}
    \KeywordTok{return}\NormalTok{()}
\NormalTok{  \}}
  
\NormalTok{  added <-}\StringTok{ }\KeywordTok{setdiff}\NormalTok{(new, old)}
\NormalTok{  removed <-}\StringTok{ }\KeywordTok{setdiff}\NormalTok{(old, new)}
  
\NormalTok{  changes <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(added) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" * '"}\NormalTok{, added, }\StringTok{"' was added"}\NormalTok{),}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(removed) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{paste0}\NormalTok{(}\StringTok{" * '"}\NormalTok{, removed ,}
                                    \StringTok{"' was removed"}\NormalTok{)}
\NormalTok{  )}
  \KeywordTok{message}\NormalTok{(}\KeywordTok{paste}\NormalTok{(changes, }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{dir_compare}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{))}
\CommentTok{#> NULL}
\KeywordTok{dir_compare}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"y"}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\CommentTok{#>  * 'a' was added}
\CommentTok{#>  * 'y' was removed}
\end{Highlighting}
\end{Shaded}

Then we wrap it up in a function operator

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{track_dir <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{    dir_old <-}\StringTok{ }\KeywordTok{dir}\NormalTok{()}
    \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{dir_compare}\NormalTok{(dir_old, }\KeywordTok{dir}\NormalTok{()), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
    
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And try it out by creating wrappers around \texttt{file.create()} and \texttt{file.remove()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{file_create <-}\StringTok{ }\KeywordTok{track_dir}\NormalTok{(file.create)}
\NormalTok{file_remove <-}\StringTok{ }\KeywordTok{track_dir}\NormalTok{(file.remove)}

\KeywordTok{file_create}\NormalTok{(}\StringTok{"delete_me"}\NormalTok{)}
\CommentTok{#>  * 'delete_me' was added}
\CommentTok{#> [1] TRUE}
\KeywordTok{file_remove}\NormalTok{(}\StringTok{"delete_me"}\NormalTok{)}
\CommentTok{#>  * 'delete_me' was removed}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

To create a more serious version of \texttt{track\_dir()} one might provide optionality to set the \texttt{full.names} and \texttt{recursive} arguments of \texttt{dir()} to \texttt{TRUE}. This would enable to also track the creation/deletion of hidden files and files in folders contained in the working directory.

Other global effects that might be worth tracking include changes regarding:

\begin{itemize}
\tightlist
\item
  the search path and possibly introduced \texttt{conflicts()}
\item
  \texttt{options()} and \texttt{par()} which modify global settings
\item
  the path of the working directory
\item
  environment variables
\end{itemize}

\textbf{{Q4}}: Write a function operator that logs a timestamp and message to a file every time a function is run.

\textbf{{A}}: Our \texttt{logger()} function operator takes a function and a file path as input. One timestamp is written to the file under \texttt{log\_path} when we call \texttt{logger()} and another timestamp is written to the same file each time the new function gets called.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{append_line <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path, ...) \{ }
  \KeywordTok{cat}\NormalTok{(..., }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{, }\DataTypeTok{file =}\NormalTok{ path, }\DataTypeTok{append =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{\}}

\NormalTok{logger <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, log_path) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \KeywordTok{force}\NormalTok{(log_path)}
  
  \KeywordTok{append_line}\NormalTok{(log_path, }\StringTok{"created at: "}\NormalTok{, }\KeywordTok{as.character}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()))}
  \ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{append_line}\NormalTok{(log_path, }\StringTok{"called at: "}\NormalTok{, }\KeywordTok{as.character}\NormalTok{(}\KeywordTok{Sys.time}\NormalTok{()))}
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, let's check if our \texttt{logger()} works as intended and apply it to the \texttt{mean()} function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{log_path <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\NormalTok{mean2 <-}\StringTok{ }\KeywordTok{logger}\NormalTok{(mean, log_path)}
\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\KeywordTok{mean2}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{) }
\CommentTok{#> [1] 2.5}
\KeywordTok{Sys.sleep}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\KeywordTok{mean2}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\CommentTok{#> [1] 2.5}

\KeywordTok{readLines}\NormalTok{(log_path)}
\CommentTok{#> [1] "created at: 2020-12-29 21:23:37"}
\CommentTok{#> [2] "called at: 2020-12-29 21:23:42" }
\CommentTok{#> [3] "called at: 2020-12-29 21:23:43"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Modify \texttt{delay\_by()} so that instead of delaying by a fixed amount of time, it ensures that a certain amount of time has elapsed since the function was last called. That is, if you called \texttt{g\ \textless{}-\ delay\_by(1,\ f);\ g();\ Sys.sleep(2);\ g()} there shouldn't be an extra delay.

\textbf{{A}}: \texttt{delay\_by()} was defined in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{delay_by <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, amount) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \KeywordTok{force}\NormalTok{(amount)}
  
  \ControlFlowTok{function}\NormalTok{(...) \{}
    \KeywordTok{Sys.sleep}\NormalTok{(amount)}
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To ensure that the function created by \texttt{delay\_by()} waits that a certain amount of time has passed since it's last execution, we incorporate three little changes into our new \texttt{delay\_atleast()} as indicated in the corresponding comments below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{delay_atleast <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(amount, f) \{}
  \KeywordTok{force}\NormalTok{(f)}
  \KeywordTok{force}\NormalTok{(amount)}
  
  \CommentTok{# Store the last time the function was run}
\NormalTok{  last_time <-}\StringTok{ }\OtherTok{NULL}
  
  \CommentTok{# Return modified "delay-aware" function}
  \ControlFlowTok{function}\NormalTok{(...) \{}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(last_time)) \{}
\NormalTok{      wait <-}\StringTok{ }\NormalTok{(last_time }\OperatorTok{-}\StringTok{ }\KeywordTok{Sys.time}\NormalTok{()) }\OperatorTok{+}\StringTok{ }\NormalTok{amount}
      \ControlFlowTok{if}\NormalTok{ (wait }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{Sys.sleep}\NormalTok{(wait)}
\NormalTok{      \}}
\NormalTok{    \}}
    
    \CommentTok{# Update the time after the function has finished}
    \KeywordTok{on.exit}\NormalTok{(last_time <<-}\StringTok{ }\KeywordTok{Sys.time}\NormalTok{()) }
    
    \KeywordTok{f}\NormalTok{(...)}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-object-oriented-programming}{%
\part{Object oriented programming}\label{part-object-oriented-programming}}

\stepcounter{chapter}

\hypertarget{s3}{%
\chapter{S3}\label{s3}}

\hypertarget{prerequisites-6}{%
\section*{Prerequisites}\label{prerequisites-6}}


In this chapter we will mainly use the \texttt{\{sloop\}} package, to interact with S3 objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(sloop)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{basics}{%
\section{Basics}\label{basics}}

\textbf{{Q1}}: Describe the difference between \texttt{t.test()} and \texttt{t.data.frame()}? When is each function called?

\textbf{{A}}: Because of S3's \texttt{generic.class()} naming scheme, both functions may initially look similar, while they are in fact unrelated.

\begin{itemize}
\tightlist
\item
  \texttt{t.test()} is a \emph{generic} function that performs a t-test.
\item
  \texttt{t.data.frame()} is a \emph{method} that gets called by the generic \texttt{t()} to transpose data frame input.
\end{itemize}

Due to R's S3 dispatch rules, \texttt{t.test()} would also get called when \texttt{t()} is applied to an object of class \texttt{test}.

\textbf{{Q2}}: Make a list of commonly used base R functions that contain \texttt{.} in their name but are not S3 methods.

\textbf{{A}}: In recent years ``snake\_case''-style has become increasingly common when naming functions and variables in R. But many functions in base R will continue to be ``point.separated'', which is why some inconsistency in your R code most likely cannot be avoided.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Some base R functions with point.separated names}
\KeywordTok{install.packages}\NormalTok{()}
\KeywordTok{read.csv}\NormalTok{()}

\KeywordTok{list.files}\NormalTok{()}
\KeywordTok{download.file}\NormalTok{()}

\KeywordTok{data.frame}\NormalTok{()}
\KeywordTok{as.character}\NormalTok{()}
\KeywordTok{Sys.Date}\NormalTok{()}

\KeywordTok{all.equal}\NormalTok{()}

\KeywordTok{do.call}\NormalTok{()}
\KeywordTok{on.exit}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: What does the \texttt{as.data.frame.data.frame()} method do? Why is it confusing? How could you avoid this confusion in your own code?

\textbf{{A}}: The function \texttt{as.data.frame.data.frame()} implements the \texttt{data.frame()} \emph{method} for the \texttt{as.data.frame()} \emph{generic}, which coerces objects to data frames.

The name is confusing, because it does not clearly communicate the type of the function, which could be a regular function, a generic or a method. Even if we assume a method, the amount of \texttt{.}'s makes it difficult to separate the generic- and the class-part of the name. Is it the \texttt{data.frame.data.frame()} method for the \texttt{as()} generic? Is it the \texttt{frame.data.frame()} method for the \texttt{as.data()} generic?

We could avoid this confusion by applying a different naming convention (e.g.~``snake\_case'') for our class and function names.

\textbf{{Q4}}: Describe the difference in behaviour in these two calls.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{some_days <-}\StringTok{ }\KeywordTok{as.Date}\NormalTok{(}\StringTok{"2017-01-31"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\KeywordTok{mean}\NormalTok{(some_days)}
\CommentTok{#> [1] "2017-02-06"}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{unclass}\NormalTok{(some_days))}
\CommentTok{#> [1] 17203}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{mean()} is a generic function, which will select the appropriate method based on the class of the input. \texttt{some\_days} has the class \texttt{Date} and \texttt{mean.Date(some\_days)} will be used to calculate the mean date of \texttt{some\_days}.

After \texttt{unclass()} has removed the class attribute from \texttt{some\_date}, the default method is chosen. \texttt{mean.default(unclass(some\_days))} then calculates the mean of the underlying double.

\textbf{{Q5}}: What class of object does the following code return? What base type is it built on? What attributes does it use?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{ecdf}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> Empirical CDF }
\CommentTok{#> Call: ecdf(rpois(100, 10))}
\CommentTok{#>  x[1:18] =  2,  3,  4,  ..., 2e+01, 2e+01}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: It returns an object of the class \texttt{ecdf} (empirical cumulative distribution function) with the superclasses \texttt{stepfun} and \texttt{function}. The \texttt{ecdf} object is built on the base type \texttt{closure} (a function). The expression, which was used to create it (\texttt{rpois(100,\ 10)}), is stored in in the \texttt{call} attribute.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(x)}
\CommentTok{#> [1] "closure"}

\KeywordTok{attributes}\NormalTok{(x)}
\CommentTok{#> $class}
\CommentTok{#> [1] "ecdf"     "stepfun"  "function"}
\CommentTok{#> }
\CommentTok{#> $call}
\CommentTok{#> ecdf(rpois(100, 10))}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: What class of object does the following code return? What base type is it built on? What attributes does it use?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{table}\NormalTok{(}\KeywordTok{rpois}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> }
\CommentTok{#>  1  2  3  4  5  6  7  8  9 10 }
\CommentTok{#>  7  5 18 14 15 15 14  4  5  3}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: This code returns a \texttt{table} object, which is built upon the \texttt{integer} type. The attribute \texttt{dimnames} is used to name the elements of the integer vector.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(x)}
\CommentTok{#> [1] "integer"}

\KeywordTok{attributes}\NormalTok{(x)}
\CommentTok{#> $dim}
\CommentTok{#> [1] 10}
\CommentTok{#> }
\CommentTok{#> $dimnames}
\CommentTok{#> $dimnames[[1]]}
\CommentTok{#>  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"}
\CommentTok{#> }
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "table"}
\end{Highlighting}
\end{Shaded}

\hypertarget{classes}{%
\section{Classes}\label{classes}}

\textbf{{Q1}}: Write a constructor for \texttt{data.frame} objects. What base type is a data frame built on? What attributes does it use? What are the restrictions placed on the individual elements? What about the names?

\textbf{{A}}: Data frames are built on named lists of vectors, which all have the same length. Besides the \texttt{class} and the column names (\texttt{names}), the \texttt{row.names} are their only further attribute. This must be a character vector with the same length as the other vectors.

We need to provide the number of rows as an input to make it possible to create data frames with 0 columns but multiple rows.

This leads to the following constructor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_data.frame <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, n, }\DataTypeTok{row.names =} \OtherTok{NULL}\NormalTok{) \{}
  \CommentTok{# Check if the underlying object is a list}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.list}\NormalTok{(x))}
  
  \CommentTok{# Check all inputs are the same length}
  \CommentTok{# (This check also allows that x has length 0)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all}\NormalTok{(}\KeywordTok{lengths}\NormalTok{(x) }\OperatorTok{==}\StringTok{ }\NormalTok{n))}
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(row.names)) \{}
    \CommentTok{# Use special row names helper from base R}
\NormalTok{    row.names <-}\StringTok{ }\KeywordTok{.set_row_names}\NormalTok{(n)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \CommentTok{# Otherwise check that they're a character vector with the }
    \CommentTok{# correct length}
    \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(row.names), }\KeywordTok{length}\NormalTok{(row.names) }\OperatorTok{==}\StringTok{ }\NormalTok{n)}
\NormalTok{  \}}
  
  \KeywordTok{structure}\NormalTok{(}
\NormalTok{    x,}
    \DataTypeTok{class =} \StringTok{"data.frame"}\NormalTok{,}
    \DataTypeTok{row.names =}\NormalTok{ row.names}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Test}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\KeywordTok{new_data.frame}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{1}\NormalTok{)}
\CommentTok{#>   a b}
\CommentTok{#> 1 1 2}
\KeywordTok{new_data.frame}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{1}\NormalTok{, }\DataTypeTok{row.names =} \StringTok{"l1"}\NormalTok{)}
\CommentTok{#>    a b}
\CommentTok{#> l1 1 2}

\CommentTok{# Create a data frame with 0 columns and 2 rows}
\KeywordTok{new_data.frame}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\CommentTok{#> data frame with 0 columns and 2 rows}
\end{Highlighting}
\end{Shaded}

There are two additional restrictions we could implement if we were being very strict: both the row names and column names should be unique.

\textbf{{Q2}}: Enhance my \texttt{factor()} helper to have better behaviour when one or more \texttt{values} is not found in \texttt{levels}. What does \texttt{base::factor()} do in this situation?

\textbf{{A}}: \texttt{base::factor()} converts these values (silently) into \texttt{NA}s:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\CommentTok{#> [1] a    b    <NA>}
\CommentTok{#> Levels: a b}
\end{Highlighting}
\end{Shaded}

The \texttt{factor()} helper including the constructor (\texttt{new\_factor()}) and its validator (\texttt{validate\_factor()}) were given in Advanced R. However, as the goal of this question is to throw an early error within the helper, we only repeat the code for the helper:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Simplified version of `factor()` helper, as defined in Advanced R}
\NormalTok{factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{character}\NormalTok{(), }\DataTypeTok{levels =} \KeywordTok{unique}\NormalTok{(x)) \{}
\NormalTok{  ind <-}\StringTok{ }\KeywordTok{match}\NormalTok{(x, levels)}
  \KeywordTok{validate_factor}\NormalTok{(}\KeywordTok{new_factor}\NormalTok{(ind, levels))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To improve the \texttt{factor()} helper we choose to return an informative error message instead.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{factor2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{levels =} \KeywordTok{unique}\NormalTok{(x)) \{}
\NormalTok{  new_levels <-}\StringTok{ }\KeywordTok{match}\NormalTok{(x, levels)}
  
  \CommentTok{# Error if levels don't include all values}
\NormalTok{  missing <-}\StringTok{ }\KeywordTok{unique}\NormalTok{(}\KeywordTok{setdiff}\NormalTok{(x, levels))}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(missing) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{stop}\NormalTok{(}
      \StringTok{"The following values do not occur in the levels of x: "}\NormalTok{,}
      \KeywordTok{paste0}\NormalTok{(}\StringTok{"'"}\NormalTok{, missing, }\StringTok{"'"}\NormalTok{, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{), }\StringTok{"."}\NormalTok{, }
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}
  
  \KeywordTok{validate_factor}\NormalTok{(}\KeywordTok{new_factor}\NormalTok{(new_levels, levels))}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{factor2}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\CommentTok{#> Error: The following values do not occur in the levels of x: 'c'.}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Carefully read the source code of \texttt{factor()}. What does it do that our constructor does not?

\textbf{{A}}: The original implementation (\texttt{base::factor()}) allows more flexible input for \texttt{x}. It coerces \texttt{x} to character or replaces it with \texttt{character(0)} (in case of \texttt{NULL}). It also ensures that the \texttt{levels} are unique. This is achieved by setting them via \texttt{base::levels\textless{}-}, which fails when duplicate values are supplied.

\textbf{{Q4}}: Factors have an optional ``contrasts'' attribute. Read the help for \texttt{C()}, and briefly describe the purpose of the attribute. What type should it have? Rewrite the \texttt{new\_factor()} constructor to include this attribute.

\textbf{{A}}: When factor variables (representing nominal or ordinal information) are used in statistical models, they are typically encoded as dummy variables and by default each level is compared with the first factor level. However, many different encodings (``contrasts'') are possible, see \url{https://en.wikipedia.org/wiki/Contrast_(statistics)}.

Within R's formula interface you can wrap a factor in \texttt{stats::C()} and specify the contrast of your choice. Alternatively, you can set the \texttt{contrasts} attribute of your factor variable, which accepts matrix input. (See \texttt{?contr.helmert} or similar for details).

The \texttt{new\_factor()} constructor was given in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# new_factor() constructor from Advanced R}
\NormalTok{new_factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{integer}\NormalTok{(), }\DataTypeTok{levels =} \KeywordTok{character}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.integer}\NormalTok{(x))}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(levels))}

  \KeywordTok{structure}\NormalTok{(}
\NormalTok{    x,}
    \DataTypeTok{levels =}\NormalTok{ levels,}
    \DataTypeTok{class =} \StringTok{"factor"}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Our updated \texttt{new\_factor()} constructor gets a \texttt{contrasts} argument, which accepts a numeric matrix or \texttt{NULL} (default).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Updated new_factor() constructor}
\NormalTok{new_factor <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}
  \DataTypeTok{x =} \KeywordTok{integer}\NormalTok{(),}
  \DataTypeTok{levels =} \KeywordTok{character}\NormalTok{(),}
  \DataTypeTok{contrasts =} \OtherTok{NULL}
\NormalTok{) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.integer}\NormalTok{(x))}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.character}\NormalTok{(levels))}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{is.null}\NormalTok{(constrasts)) \{}
    \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.matrix}\NormalTok{(contrasts) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is.numeric}\NormalTok{(contrasts))}
\NormalTok{  \}}
  
  \KeywordTok{structure}\NormalTok{(}
\NormalTok{    x,}
    \DataTypeTok{levels =}\NormalTok{ levels,}
    \DataTypeTok{class =} \StringTok{"factor"}\NormalTok{,}
    \DataTypeTok{contrasts =}\NormalTok{ contrasts}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Read the documentation for \texttt{utils::as.roman()}. How would you write a constructor for this class? Does it need a validator? What might a helper do?

\textbf{{A}}: This function transforms numeric input into Roman numbers. It is built on the integer type, which results in the following constructor.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_roman <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{integer}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.integer}\NormalTok{(x))}
  \KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"roman"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The documentation tells us, that only values between 1 and 3899 are uniquely represented, which we then include in our validation function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{validate_roman <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  values <-}\StringTok{ }\KeywordTok{unclass}\NormalTok{(x)}
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{any}\NormalTok{(values }\OperatorTok{<}\StringTok{ }\DecValTok{1} \OperatorTok{|}\StringTok{ }\NormalTok{values }\OperatorTok{>}\StringTok{ }\DecValTok{3899}\NormalTok{)) \{}
    \KeywordTok{stop}\NormalTok{(}
      \StringTok{"Roman numbers must fall between 1 and 3899."}\NormalTok{,}
      \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{    )}
\NormalTok{  \}}
  
\NormalTok{  x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For convenience, we allow the user to also pass real values to a helper function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{roman <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{integer}\NormalTok{()) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(x)}
  
  \KeywordTok{validate_roman}\NormalTok{(}\KeywordTok{new_roman}\NormalTok{(x))}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{roman}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{753}\NormalTok{, }\DecValTok{2019}\NormalTok{))}
\CommentTok{#> [1] I       DCCLIII MMXIX}
\KeywordTok{roman}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\CommentTok{#> Error: Roman numbers must fall between 1 and 3899.}
\end{Highlighting}
\end{Shaded}

\hypertarget{generics-and-methods}{%
\section{Generics and methods}\label{generics-and-methods}}

\textbf{{Q1}}: Read the source code for \texttt{t()} and \texttt{t.test()} and confirm that \texttt{t.test()} is an S3 generic and not an S3 method. What happens if you create an object with class \texttt{test} and call \texttt{t()} with it? Why?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{class =} \StringTok{"test"}\NormalTok{)}
\KeywordTok{t}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: We can see that \texttt{t.test()} is a generic because it calls \texttt{UseMethod()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t.test}
\CommentTok{#> function (x, ...) }
\CommentTok{#> UseMethod("t.test")}
\CommentTok{#> <bytecode: 0x0000000013798010>}
\CommentTok{#> <environment: namespace:stats>}

\CommentTok{# or simply call}
\NormalTok{sloop}\OperatorTok{::}\KeywordTok{ftype}\NormalTok{(t.test)}
\CommentTok{#> [1] "S3"      "generic"}
\end{Highlighting}
\end{Shaded}

Interestingly, R also provides helpers, which list functions that look like methods, but in fact are not:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tools}\OperatorTok{::}\KeywordTok{nonS3methods}\NormalTok{(}\StringTok{"stats"}\NormalTok{)}
\CommentTok{#> [1] "anova.lmlist"        "expand.model.frame"  "fitted.values"      }
\CommentTok{#> [4] "influence.measures"  "lag.plot"            "t.test"             }
\CommentTok{#> [7] "plot.spec.phase"     "plot.spec.coherency"}
\end{Highlighting}
\end{Shaded}

When we create an object with class \texttt{test}, \texttt{t()}, will dispatch to \texttt{t.test()}. This happens, because \texttt{UseMethod()} simply searches for functions named \texttt{paste0("generic",\ ".",\ c(class(x),\ "default"))}.

Consequently \texttt{t.test()} is erroneously treated as a method of \texttt{t()}. Because \texttt{t.test()} is a generic itself and doesn't find a method called \texttt{t.test.test()}, it dispatches to \texttt{t.test.default()}. We can define \texttt{t.test.test()} to demonstrate that this is really what is happening internally.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{class =} \StringTok{"test"}\NormalTok{)}
\KeywordTok{t}\NormalTok{(x)}
\CommentTok{#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]}
\CommentTok{#> [1,]    1    2    3    4    5    6    7    8    9    10}
\CommentTok{#> attr(,"class")}
\CommentTok{#> [1] "test"}

\NormalTok{t.test.test <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"Hi!"}
\KeywordTok{t.test}\NormalTok{(x)}
\CommentTok{#> [1] "Hi!"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What generics does the \texttt{table} class have methods for?

\textbf{{A}}: This is a simple application of \texttt{sloop::s3\_methods\_class()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"table"}\NormalTok{)}
\CommentTok{#> # A tibble: 11 x 4}
\CommentTok{#>    generic       class visible source             }
\CommentTok{#>    <chr>         <chr> <lgl>   <chr>              }
\CommentTok{#>  1 [             table TRUE    base               }
\CommentTok{#>  2 aperm         table TRUE    base               }
\CommentTok{#>  3 as.data.frame table TRUE    base               }
\CommentTok{#>  4 as_tibble     table FALSE   registered S3method}
\CommentTok{#>  5 Axis          table FALSE   registered S3method}
\CommentTok{#>  6 lines         table FALSE   registered S3method}
\CommentTok{#>  7 plot          table FALSE   registered S3method}
\CommentTok{#>  8 points        table FALSE   registered S3method}
\CommentTok{#>  9 print         table TRUE    base               }
\CommentTok{#> 10 summary       table TRUE    base               }
\CommentTok{#> 11 tail          table FALSE   registered S3method}
\end{Highlighting}
\end{Shaded}

Interestingly, the \texttt{table} class has a number of methods designed to help plotting with base graphics.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{rpois}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(}\KeywordTok{table}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{13_S3_files/figure-latex/unnamed-chunk-22-1} \end{center}

\textbf{{Q3}}: What generics does the \texttt{ecdf} class have methods for?

\textbf{{A}}: We use the same approach as above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"ecdf"}\NormalTok{)}
\CommentTok{#> # A tibble: 4 x 4}
\CommentTok{#>   generic  class visible source             }
\CommentTok{#>   <chr>    <chr> <lgl>   <chr>              }
\CommentTok{#> 1 plot     ecdf  TRUE    stats              }
\CommentTok{#> 2 print    ecdf  FALSE   registered S3method}
\CommentTok{#> 3 quantile ecdf  FALSE   registered S3method}
\CommentTok{#> 4 summary  ecdf  FALSE   registered S3method}
\end{Highlighting}
\end{Shaded}

The methods are primarily designed for display (\texttt{plot()}, \texttt{print()}, \texttt{summary()}), but you can also extract quantiles with \texttt{quantile()}.

\textbf{{Q4}}: Which base generic has the greatest number of defined methods?

\textbf{{A}}: A little experimentation (and thinking about the most popular functions) suggests that the \texttt{print()} generic has the most defined methods.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nrow}\NormalTok{(}\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"print"}\NormalTok{))}
\CommentTok{#> [1] 261}
\KeywordTok{nrow}\NormalTok{(}\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"summary"}\NormalTok{))}
\CommentTok{#> [1] 38}
\KeywordTok{nrow}\NormalTok{(}\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"plot"}\NormalTok{))}
\CommentTok{#> [1] 34}
\end{Highlighting}
\end{Shaded}

Let's verify this programmatically with the tools we have learned in this and the previous chapters.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(purrr)}

\KeywordTok{ls}\NormalTok{(}\DataTypeTok{all.names =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{env =} \KeywordTok{baseenv}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{mget}\NormalTok{(}\DataTypeTok{envir =} \KeywordTok{baseenv}\NormalTok{()) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{keep}\NormalTok{(is_function) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{keep}\NormalTok{(is_s3_generic) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{map}\NormalTok{(}\OperatorTok{~}\StringTok{ }\KeywordTok{set_names}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(}\KeywordTok{s3_methods_generic}\NormalTok{(.x)), .x)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{flatten_int}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{sort}\NormalTok{(}\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\CommentTok{#>        print       format            [      summary         plot }
\CommentTok{#>          261          100           53           38           34 }
\CommentTok{#> as.character }
\CommentTok{#>           33}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Carefully read the documentation for \texttt{UseMethod()} and explain why the following code returns the results that it does. What two usual rules of function evaluation does \texttt{UseMethod()} violate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  y <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{UseMethod}\NormalTok{(}\StringTok{"g"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{g.default <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}

\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{y <-}\StringTok{ }\DecValTok{1}
\KeywordTok{g}\NormalTok{(x)}
\CommentTok{#>  x  y }
\CommentTok{#>  1 10}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let's take this step by step. If you call \texttt{g.default()} directly you get \texttt{c(1,\ 1)} as you might expect.

The value bound to \texttt{x} comes from the argument, the value from \texttt{y} comes from the global environment.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{g.default}\NormalTok{(x)}
\CommentTok{#> x y }
\CommentTok{#> 1 1}
\end{Highlighting}
\end{Shaded}

But when we call \texttt{g()} we get \texttt{c(1,\ 10)}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{g}\NormalTok{(x)}
\CommentTok{#>  x  y }
\CommentTok{#>  1 10}
\end{Highlighting}
\end{Shaded}

This is seemingly inconsistent: why does \texttt{x} come from the value defined inside of \texttt{g()}, and \texttt{y} still come from the global environment? It's because \texttt{UseMethod()} calls \texttt{g.default()} in a special way so that variables defined inside the generic are available to methods. The exception are arguments supplied to the function: they are passed on as is and cannot be affected by code inside the generic.

\textbf{{Q6}}: What are the arguments to \texttt{{[}}? Why is this a hard question to answer?

\textbf{{A}}: The subsetting operator \texttt{{[}} is a primitive and a generic function, which can be confirmed via \texttt{ftype()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ftype}\NormalTok{(}\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{)}
\CommentTok{#> [1] "primitive" "generic"}
\end{Highlighting}
\end{Shaded}

For primitive functions \texttt{formals({[})} returns \texttt{NULL} so we need to find another way to determine the functions arguments. One possible way to figure out \texttt{{[}}'s arguments would be to inspect the underlying C source code, which can be searched for via \texttt{pryr::show\_c\_source(.Primitive("{[}"))}.

When we inspect the arguments of some of \texttt{{[}}'s methods, we see that the arguments vary with the class of \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(}\KeywordTok{formals}\NormalTok{(}\StringTok{`}\DataTypeTok{[.data.frame}\StringTok{`}\NormalTok{))}
\CommentTok{#> [1] "x"    "i"    "j"    "drop"}
\KeywordTok{names}\NormalTok{(}\KeywordTok{formals}\NormalTok{(}\StringTok{`}\DataTypeTok{[.table}\StringTok{`}\NormalTok{))}
\CommentTok{#> [1] "x"    "i"    "j"    "..."  "drop"}
\KeywordTok{names}\NormalTok{(}\KeywordTok{formals}\NormalTok{(}\StringTok{`}\DataTypeTok{[.Date}\StringTok{`}\NormalTok{))}
\CommentTok{#> [1] "x"    "..."  "drop"}
\KeywordTok{names}\NormalTok{(}\KeywordTok{formals}\NormalTok{(}\StringTok{`}\DataTypeTok{[.AsIs}\StringTok{`}\NormalTok{))}
\CommentTok{#> [1] "x"   "i"   "..."}
\end{Highlighting}
\end{Shaded}

To finally get a better overview, we have to put in a little more effort and also use \texttt{s3\_methods\_generic()} again.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}

\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"["}\NormalTok{) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{filter}\NormalTok{(visible) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{mutate}\NormalTok{(}
    \DataTypeTok{method =} \KeywordTok{paste0}\NormalTok{(}\StringTok{"[."}\NormalTok{, class),}
    \DataTypeTok{argnames =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(method, }\OperatorTok{~}\StringTok{ }\KeywordTok{names}\NormalTok{(}\KeywordTok{formals}\NormalTok{(.x))),}
    \DataTypeTok{args =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(method, }\OperatorTok{~}\StringTok{ }\KeywordTok{formals}\NormalTok{(.x)),}
    \DataTypeTok{args =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{map2}\NormalTok{(}
\NormalTok{      argnames, args,}
      \OperatorTok{~}\StringTok{ }\KeywordTok{paste}\NormalTok{(.x, .y, }\DataTypeTok{sep =} \StringTok{" = "}\NormalTok{)}
\NormalTok{    ),}
    \DataTypeTok{args =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{set_names}\NormalTok{(args, method)}
\NormalTok{  ) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{pull}\NormalTok{(args) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{head}\NormalTok{()}
\CommentTok{#> $`[.AsIs`}
\CommentTok{#> [1] "x = "   "i = "   "... = "}
\CommentTok{#> }
\CommentTok{#> $`[.data.frame`}
\CommentTok{#> [1] "x = "                                              }
\CommentTok{#> [2] "i = "                                              }
\CommentTok{#> [3] "j = "                                              }
\CommentTok{#> [4] "drop = if (missing(i)) TRUE else length(cols) == 1"}
\CommentTok{#> }
\CommentTok{#> $`[.Date`}
\CommentTok{#> [1] "x = "        "... = "      "drop = TRUE"}
\CommentTok{#> }
\CommentTok{#> $`[.difftime`}
\CommentTok{#> [1] "x = "        "... = "      "drop = TRUE"}
\CommentTok{#> }
\CommentTok{#> $`[.Dlist`}
\CommentTok{#> [1] "x = "   "i = "   "... = "}
\CommentTok{#> }
\CommentTok{#> $`[.DLLInfoList`}
\CommentTok{#> [1] "x = "   "... = "}
\end{Highlighting}
\end{Shaded}

\hypertarget{object-styles}{%
\section{Object styles}\label{object-styles}}

\textbf{{Q1}}: Categorise the objects returned by \texttt{lm()}, \texttt{factor()}, \texttt{table()}, \texttt{as.Date()}, \texttt{as.POSIXct()}, \texttt{ecdf()}, \texttt{ordered()}, \texttt{I()} into the styles described above.

\textbf{{A}}: We can categorise the return values into the various object styles by observing how the \href{https://vctrs.r-lib.org/articles/type-size.html\#size}{number of observations} is calculated: For vector style classes, \texttt{length(x)} represents the number of observations. Record style objects use a list of equal length elements to represent individual components. For data frames and matrices, the observations are represented by the rows. Scalar style objects use a list to represent a single thing.

This leads us to:

\begin{itemize}
\tightlist
\item
  Vector object-style: \texttt{factor()}, \texttt{table()}, \texttt{as.Date()}, \texttt{as.POSIXct()}, \texttt{ordered()}
\item
  Record object-style: not observed
\item
  Data frame object-style: not observed
\item
  Scalar object-style: \texttt{lm()}, \texttt{ecdf()}
\end{itemize}

The object style of \texttt{I()} depends on the input since this function returns a ``copy of the object with class \texttt{AsIs} prepended to the class(es)''.

\textbf{{Q2}}: What would a constructor function for \texttt{lm} objects, \texttt{new\_lm()}, look like? Use \texttt{?lm} and experimentation to figure out the required fields and their types.

\textbf{{A}}: The constructor needs to populate the attributes of an \texttt{lm} object and check their types for correctness. Let's start by creating a simple \texttt{lm} object and explore it's underlying base type and attributes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(cyl }\OperatorTok{~}\StringTok{ }\NormalTok{., }\DataTypeTok{data =}\NormalTok{ mtcars)}

\KeywordTok{typeof}\NormalTok{(mod)}
\CommentTok{#> [1] "list"}

\KeywordTok{attributes}\NormalTok{(mod)}
\CommentTok{#> $names}
\CommentTok{#>  [1] "coefficients"  "residuals"     "effects"       "rank"         }
\CommentTok{#>  [5] "fitted.values" "assign"        "qr"            "df.residual"  }
\CommentTok{#>  [9] "xlevels"       "call"          "terms"         "model"        }
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "lm"}
\end{Highlighting}
\end{Shaded}

As \texttt{mod} is built upon a list, we can simply use \texttt{map(mod,\ typeof)} to find out the base types of its elements. (Additionally, we inspect \texttt{?lm}, to learn more about the individual attributes.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{map_chr}\NormalTok{(mod, typeof)}
\CommentTok{#>  coefficients     residuals       effects          rank }
\CommentTok{#>      "double"      "double"      "double"     "integer" }
\CommentTok{#> fitted.values        assign            qr   df.residual }
\CommentTok{#>      "double"     "integer"        "list"     "integer" }
\CommentTok{#>       xlevels          call         terms         model }
\CommentTok{#>        "list"    "language"    "language"        "list"}
\end{Highlighting}
\end{Shaded}

Now we should have enough information to write a constructor for new \texttt{lm} objects.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_lm <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}
\NormalTok{  coefficients, residuals, effects, rank, fitted.values, assign,}
\NormalTok{  qr, df.residual, xlevels, call, terms, model}
\NormalTok{) \{}
  
  \KeywordTok{stopifnot}\NormalTok{(}
    \KeywordTok{is.double}\NormalTok{(coefficients), }\KeywordTok{is.double}\NormalTok{(residuals), }
    \KeywordTok{is.double}\NormalTok{(effects), }\KeywordTok{is.integer}\NormalTok{(rank), }\KeywordTok{is.double}\NormalTok{(fitted.values),}
    \KeywordTok{is.integer}\NormalTok{(assign), }\KeywordTok{is.list}\NormalTok{(qr), }\KeywordTok{is.integer}\NormalTok{(df.residual),}
    \KeywordTok{is.list}\NormalTok{(xlevels), }\KeywordTok{is.language}\NormalTok{(call), }\KeywordTok{is.language}\NormalTok{(terms),}
    \KeywordTok{is.list}\NormalTok{(model)}
\NormalTok{  )}
  
  \KeywordTok{structure}\NormalTok{(}
    \KeywordTok{list}\NormalTok{(}
      \DataTypeTok{coefficients =}\NormalTok{ coefficients,}
      \DataTypeTok{residuals =}\NormalTok{ residuals,}
      \DataTypeTok{effects =}\NormalTok{ effects,}
      \DataTypeTok{rank =}\NormalTok{ rank, }
      \DataTypeTok{fitted.values =}\NormalTok{ fitted.values,}
      \DataTypeTok{assign =}\NormalTok{ assign,}
      \DataTypeTok{qr =}\NormalTok{ qr,}
      \DataTypeTok{df.residual =}\NormalTok{ df.residual,}
      \DataTypeTok{xlevels =}\NormalTok{ xlevels,}
      \DataTypeTok{call =}\NormalTok{ call,}
      \DataTypeTok{terms =}\NormalTok{ terms, }
      \DataTypeTok{model =}\NormalTok{ model}
\NormalTok{    ),}
    \DataTypeTok{class =} \StringTok{"lm"}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{inheritance}{%
\section{Inheritance}\label{inheritance}}

\textbf{{Q1}}: How does \texttt{{[}.Date} support subclasses? How does it fail to support subclasses?

\textbf{{A}}: \texttt{{[}.Date} calls \texttt{.Date} with the result of calling \texttt{{[}} on the parent class, along with \texttt{oldClass()}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.Date}\StringTok{`}
\CommentTok{#> function (x, ..., drop = TRUE) }
\CommentTok{#> \{}
\CommentTok{#>     .Date(NextMethod("["), oldClass(x))}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x00000000153bbf08>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\texttt{.Date} is kind of like a constructor for date classes, although it doesn't check the input is the correct type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.Date}
\CommentTok{#> function (xx, cl = "Date") }
\CommentTok{#> `class<-`(xx, cl)}
\CommentTok{#> <bytecode: 0x0000000015c2b6a0>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\texttt{oldClass()} is basically the same as \texttt{class()}, except that it doesn't return implicit classes, i.e.~it's basically \texttt{attr(x,\ "class")} (looking at the C code that's exactly what it does, except that it also handles S4 objects).

As \texttt{oldClass()} is ``basically'' \texttt{class()}, we can rewrite \texttt{{[}.Date} to make the implementation more clear:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{[.Date}\StringTok{`}\NormalTok{ <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ..., }\DataTypeTok{drop =} \OtherTok{TRUE}\NormalTok{) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{.Date}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{(}\StringTok{"["}\NormalTok{), }\KeywordTok{oldClass}\NormalTok{(x))}
  \KeywordTok{class}\NormalTok{(out) <-}\StringTok{ }\KeywordTok{class}\NormalTok{(x)}
\NormalTok{  out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

So, \texttt{{[}.Date} ensures that the output has the same class as in the input. But what about other attributes that a subclass might possess? They get lost:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{test =} \StringTok{"test"}\NormalTok{, }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"myDate"}\NormalTok{, }\StringTok{"Date"}\NormalTok{))}
\KeywordTok{attributes}\NormalTok{(x[}\DecValTok{1}\NormalTok{])}
\CommentTok{#> $class}
\CommentTok{#> [1] "myDate" "Date"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: R has two classes for representing date time data, \texttt{POSIXct} and \texttt{POSIXlt}, which both inherit from \texttt{POSIXt}. Which generics have different behaviours for the two classes? Which generics share the same behaviour?

\textbf{{A}}: To answer this question, we have to get the respective generics

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generics_t  <-}\StringTok{ }\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"POSIXt"}\NormalTok{)}\OperatorTok{$}\NormalTok{generic}
\NormalTok{generics_ct <-}\StringTok{ }\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"POSIXct"}\NormalTok{)}\OperatorTok{$}\NormalTok{generic}
\NormalTok{generics_lt <-}\StringTok{ }\KeywordTok{s3_methods_class}\NormalTok{(}\StringTok{"POSIXlt"}\NormalTok{)}\OperatorTok{$}\NormalTok{generic}
\end{Highlighting}
\end{Shaded}

The generics in \texttt{generics\_t} with a method for the superclass POSIXt potentially share the same behaviour for both subclasses. However, if a generic has a specific method for one of the subclasses, it has to be subtracted:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# These generics provide subclass-specific methods}
\KeywordTok{union}\NormalTok{(generics_ct, generics_lt)}
\CommentTok{#>  [1] "["             "[["            "[<-"           "as.data.frame"}
\CommentTok{#>  [5] "as.Date"       "as.list"       "as.POSIXlt"    "c"            }
\CommentTok{#>  [9] "format"        "length<-"      "mean"          "print"        }
\CommentTok{#> [13] "rep"           "split"         "summary"       "Summary"      }
\CommentTok{#> [17] "weighted.mean" "xtfrm"         "[[<-"          "anyNA"        }
\CommentTok{#> [21] "as.double"     "as.matrix"     "as.POSIXct"    "duplicated"   }
\CommentTok{#> [25] "is.na"         "length"        "names"         "names<-"      }
\CommentTok{#> [29] "sort"          "unique"}

\CommentTok{# These generics share (inherited) methods for both subclasses}
\KeywordTok{setdiff}\NormalTok{(generics_t, }\KeywordTok{union}\NormalTok{(generics_ct, generics_lt))}
\CommentTok{#>  [1] "-"            "+"            "all.equal"    "as.character"}
\CommentTok{#>  [5] "Axis"         "cut"          "diff"         "hist"        }
\CommentTok{#>  [9] "is.numeric"   "julian"       "Math"         "months"      }
\CommentTok{#> [13] "Ops"          "pretty"       "quantile"     "quarters"    }
\CommentTok{#> [17] "round"        "seq"          "str"          "trunc"       }
\CommentTok{#> [21] "weekdays"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: What do you expect this code to return? What does it actually return? Why?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generic2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"generic2"}\NormalTok{)}
\NormalTok{generic2.a1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"a1"}
\NormalTok{generic2.a2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"a2"}
\NormalTok{generic2.b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ "a1"}
  \KeywordTok{NextMethod}\NormalTok{()}
\NormalTok{\}}

\KeywordTok{generic2}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"a2"}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: When we execute the code above, this is what is happening:

\begin{itemize}
\item
  we pass an object of classes \texttt{b} and \texttt{a2} to \texttt{generic2()}, which prompts R to look for a method\texttt{generic2.b()}
\item
  the method \texttt{generic2.b()} then changes the class to \texttt{a1} and calls \texttt{NextMethod()}
\item
  One would think that this will lead R to call \texttt{generic2.a1()}, but in fact, as mentioned in Advanced R, \texttt{NextMethod()}

  \begin{quote}
  doesn't actually work with the class attribute of the object, but instead uses a special global variable (.Class) to keep track of which method to call next.
  \end{quote}

  This is why \texttt{generic2.a2()} is called instead.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{generic2}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"a2"}\NormalTok{)))}
\CommentTok{#> [1] "a2"}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Let's just double check the statement above and evaluate \texttt{.Class} explicitly within the \texttt{generic2.b()} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{generic2.b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{class}\NormalTok{(x) <-}\StringTok{ "a1"}
  \KeywordTok{print}\NormalTok{(.Class)}
  \KeywordTok{NextMethod}\NormalTok{()}
\NormalTok{\}}

\KeywordTok{generic2}\NormalTok{(}\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(), }\DataTypeTok{class =} \KeywordTok{c}\NormalTok{(}\StringTok{"b"}\NormalTok{, }\StringTok{"a2"}\NormalTok{)))}
\CommentTok{#> [1] "b"  "a2"}
\CommentTok{#> [1] "a2"}
\end{Highlighting}
\end{Shaded}

\hypertarget{dispatch-details}{%
\section{Dispatch details}\label{dispatch-details}}

\textbf{{Q1}}: Explain the differences in dispatch below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\KeywordTok{class}\NormalTok{(x1)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(x1[}\DecValTok{1}\NormalTok{])}
\CommentTok{#>    [.integer}
\CommentTok{#>    [.numeric}
\CommentTok{#>    [.default}
\CommentTok{#> => [ (internal)}

\NormalTok{x2 <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(x1, }\DataTypeTok{class =} \StringTok{"integer"}\NormalTok{)}
\KeywordTok{class}\NormalTok{(x2)}
\CommentTok{#> [1] "integer"}
\KeywordTok{s3_dispatch}\NormalTok{(x2[}\DecValTok{1}\NormalTok{])}
\CommentTok{#>    [.integer}
\CommentTok{#>    [.default}
\CommentTok{#> => [ (internal)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{class()} returns \texttt{integer} in both cases. But the class of \texttt{x1} is created implicitly and inherits from the \texttt{numeric} class, while the class of \texttt{x2} is set explicitly and no parent class is assumed. This is important because \texttt{{[}} is an internal generic, so when the class is explicitly set, the ``implicit'' parent class \texttt{numeric} is not considered.

An object has no explicit class if \texttt{attr(x,\ "class")} returns \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attr}\NormalTok{(x1, }\StringTok{"class"}\NormalTok{)}
\CommentTok{#> NULL}
\KeywordTok{attr}\NormalTok{(x2, }\StringTok{"class"}\NormalTok{)}
\CommentTok{#> [1] "integer"}
\end{Highlighting}
\end{Shaded}

To see the relevant classes for the S3 dispatch, one can use \texttt{sloop::s3\_class()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_class}\NormalTok{(x1)  }\CommentTok{# implicit}
\CommentTok{#> [1] "integer" "numeric"}

\KeywordTok{s3_class}\NormalTok{(x2)  }\CommentTok{# explicit}
\CommentTok{#> [1] "integer"}
\end{Highlighting}
\end{Shaded}

For a better understanding of \texttt{s3\_dipatch()}'s output we quote from \texttt{?s3\_dispatch}:

\begin{itemize}
\tightlist
\item
  =\textgreater{} method exists and is found by UseMethod().
\item
  -\textgreater{} method exists and is used by NextMethod().
\item
  * method exists but is not used.
\item
  Nothing (and greyed out in console): method does not exist.
\end{itemize}

\textbf{{Q2}}: What classes have a method for the \texttt{Math()} group generic in base R? Read the source code. How do the methods work?

\textbf{{A}}: The following functions belong to this group (see ?\texttt{Math}):

\begin{itemize}
\tightlist
\item
  \texttt{abs}, \texttt{sign}, \texttt{sqrt}, \texttt{floor}, \texttt{ceiling}, \texttt{trunc}, \texttt{round}, \texttt{signif}
\item
  \texttt{exp}, \texttt{log}, \texttt{expm1}, \texttt{log1p}, \texttt{cos}, \texttt{sin}, \texttt{tan}, \texttt{cospi}, \texttt{sinpi}, \texttt{tanpi}, \texttt{acos}, \texttt{asin}, \texttt{atan}, \texttt{cosh}, \texttt{sinh}, \texttt{tanh}, \texttt{acosh}, \texttt{asinh}, \texttt{atanh}
\item
  \texttt{lgamma}, \texttt{gamma}, \texttt{digamma}, \texttt{trigamma}
\item
  \texttt{cumsum}, \texttt{cumprod}, \texttt{cummax}, \texttt{cummin}
\end{itemize}

The following classes have a method for this group generic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{s3_methods_generic}\NormalTok{(}\StringTok{"Math"}\NormalTok{)}
\CommentTok{#> # A tibble: 8 x 4}
\CommentTok{#>   generic class      visible source             }
\CommentTok{#>   <chr>   <chr>      <lgl>   <chr>              }
\CommentTok{#> 1 Math    data.frame TRUE    base               }
\CommentTok{#> 2 Math    Date       TRUE    base               }
\CommentTok{#> 3 Math    difftime   TRUE    base               }
\CommentTok{#> 4 Math    factor     TRUE    base               }
\CommentTok{#> 5 Math    POSIXt     TRUE    base               }
\CommentTok{#> 6 Math    quosure    FALSE   registered S3method}
\CommentTok{#> 7 Math    vctrs_sclr FALSE   registered S3method}
\CommentTok{#> 8 Math    vctrs_vctr FALSE   registered S3method}
\end{Highlighting}
\end{Shaded}

To explain the basic idea, we just overwrite the data frame method:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Math.data.frame <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"hello"}
\end{Highlighting}
\end{Shaded}

Now all functions from the math generic group, will return \texttt{"hello"}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{abs}\NormalTok{(mtcars)}
\CommentTok{#> [1] "hello"}
\KeywordTok{exp}\NormalTok{(mtcars)}
\CommentTok{#> [1] "hello"}
\KeywordTok{lgamma}\NormalTok{(mtcars)}
\CommentTok{#> [1] "hello"}
\end{Highlighting}
\end{Shaded}

Of course, different functions should perform different calculations. Here \texttt{.Generic} comes into play, which provides us with the calling generic as a string

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Math.data.frame <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  .Generic}
\NormalTok{\}}

\KeywordTok{abs}\NormalTok{(mtcars)}
\CommentTok{#> [1] "abs"}
\KeywordTok{exp}\NormalTok{(mtcars)}
\CommentTok{#> [1] "exp"}
\KeywordTok{lgamma}\NormalTok{(mtcars)}
\CommentTok{#> [1] "lgamma"}

\KeywordTok{rm}\NormalTok{(Math.data.frame)}
\end{Highlighting}
\end{Shaded}

The original source code of \texttt{Math.data.frame()} is a good example on how to invoke the string returned by \texttt{.Generic} into a specific method. \texttt{Math.factor()} is a good example of a method, which is simply defined for better error messages.

\textbf{{Q3}}: \texttt{Math.difftime()} is more complicated than I described. Why?

\textbf{{A}}: \texttt{Math.difftime()} also excludes cases apart from \texttt{abs}, \texttt{sign}, \texttt{floor}, \texttt{ceiling}, \texttt{trunc}, \texttt{round} and \texttt{signif} and needs to return a fitting error message.

For comparison: \texttt{Math.difftime()} as defined in Advanced R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Math.difftime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{new_difftime}\NormalTok{(}\KeywordTok{NextMethod}\NormalTok{(), }\DataTypeTok{units =} \KeywordTok{attr}\NormalTok{(x, }\StringTok{"units"}\NormalTok{))}
\NormalTok{\}}
\KeywordTok{rm}\NormalTok{(Math.difftime)}
\end{Highlighting}
\end{Shaded}

\texttt{Math.difftime()} as defined in the \texttt{\{base\}} package:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Math.difftime}
\CommentTok{#> function (x, ...) }
\CommentTok{#> \{}
\CommentTok{#>     switch(.Generic, abs = , sign = , floor = , ceiling = , trunc = , }
\CommentTok{#>         round = , signif = \{}
\CommentTok{#>             units <- attr(x, "units")}
\CommentTok{#>             .difftime(NextMethod(), units)}
\CommentTok{#>         \}, stop(gettextf("'%s' not defined for \textbackslash{}"difftime\textbackslash{}" objects", }
\CommentTok{#>             .Generic), domain = NA))}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x000000001882b280>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\hypertarget{r6}{%
\chapter{R6}\label{r6}}

\hypertarget{prerequisites-7}{%
\section*{Prerequisites}\label{prerequisites-7}}


To solve the exercises in this chapter we will have to create R6 objects, which are implemented in the \texttt{\{R6\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(R6)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{classes-and-methods}{%
\section{Classes and methods}\label{classes-and-methods}}

\textbf{{Q1}}: Create a bank account R6 class that stores a balance and allows you to deposit and withdraw money. Create a subclass that throws an error if you attempt to go into overdraft. Create another subclass that allows you to go into overdraft, but charges you a fee.

\textbf{{A}}: Let's start with a basic bank account, similar to the \texttt{Accumulator} class in Advanced R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{BankAccount <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"BankAccount"}\NormalTok{, }
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{balance =} \DecValTok{0}\NormalTok{,}
    \DataTypeTok{deposit =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{dep =} \DecValTok{0}\NormalTok{) \{}
\NormalTok{      self}\OperatorTok{$}\NormalTok{balance <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{balance }\OperatorTok{+}\StringTok{ }\NormalTok{dep}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \},}
    \DataTypeTok{withdraw =} \ControlFlowTok{function}\NormalTok{(draw) \{}
\NormalTok{      self}\OperatorTok{$}\NormalTok{balance <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{balance }\OperatorTok{-}\StringTok{ }\NormalTok{draw}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To test this class, we create one instance and leave it with a negative balance.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_account <-}\StringTok{ }\NormalTok{BankAccount}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{my_account}\OperatorTok{$}\NormalTok{balance}
\CommentTok{#> [1] 0}

\NormalTok{my_account}\OperatorTok{$}
\StringTok{  }\KeywordTok{deposit}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{withdraw}\NormalTok{(}\DecValTok{15}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\NormalTok{balance}
\CommentTok{#> [1] -10}
\end{Highlighting}
\end{Shaded}

Now, we create the first subclass that prevents us from going into overdraft and throws an error in case we attempt to withdraw more than our current balance.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{BankAccountStrict <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"BankAccountStrict"}\NormalTok{,}
  \DataTypeTok{inherit =}\NormalTok{ BankAccount,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{withdraw =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{draw =} \DecValTok{0}\NormalTok{) \{}
      \ControlFlowTok{if}\NormalTok{ (self}\OperatorTok{$}\NormalTok{balance }\OperatorTok{-}\StringTok{ }\NormalTok{draw }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{stop}\NormalTok{(}\StringTok{"Your `withdraw` must be smaller "}\NormalTok{,}
          \StringTok{"than your `balance`."}\NormalTok{,}
          \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{        )}
\NormalTok{      \}}
\NormalTok{      super}\OperatorTok{$}\KeywordTok{withdraw}\NormalTok{(}\DataTypeTok{draw =}\NormalTok{ draw)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This time our test should throw an error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_strict_account <-}\StringTok{ }\NormalTok{BankAccountStrict}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{my_strict_account}\OperatorTok{$}\NormalTok{balance}
\CommentTok{#> [1] 0}

\NormalTok{my_strict_account}\OperatorTok{$}
\StringTok{  }\KeywordTok{deposit}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{withdraw}\NormalTok{(}\DecValTok{15}\NormalTok{)}
\CommentTok{#> Error: Your `withdraw` must be smaller than your `balance`.}

\NormalTok{my_strict_account}\OperatorTok{$}\NormalTok{balance}
\CommentTok{#> [1] 5}
\end{Highlighting}
\end{Shaded}

Finally, we create another subclass that charges a constant fee of 1 for each withdrawal which leaves the account with a negative balance.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{BankAccountCharging <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"BankAccountCharging"}\NormalTok{,}
  \DataTypeTok{inherit =}\NormalTok{ BankAccount,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{withdraw =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{draw =} \DecValTok{0}\NormalTok{) \{}
      \ControlFlowTok{if}\NormalTok{ (self}\OperatorTok{$}\NormalTok{balance }\OperatorTok{-}\StringTok{ }\NormalTok{draw }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        draw <-}\StringTok{ }\NormalTok{draw }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{      \}}
\NormalTok{      super}\OperatorTok{$}\KeywordTok{withdraw}\NormalTok{(}\DataTypeTok{draw =}\NormalTok{ draw)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's take a look at the implemented functionality. We expect a final balance of -12, because we pay the fee twice.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_charging_account <-}\StringTok{ }\NormalTok{BankAccountCharging}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{my_charging_account}\OperatorTok{$}\NormalTok{balance}
\CommentTok{#> [1] 0}

\NormalTok{my_charging_account}\OperatorTok{$}
\StringTok{  }\KeywordTok{deposit}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{withdraw}\NormalTok{(}\DecValTok{15}\NormalTok{)}\OperatorTok{$}
\StringTok{  }\KeywordTok{withdraw}\NormalTok{(}\DecValTok{0}\NormalTok{)}

\NormalTok{my_charging_account}\OperatorTok{$}\NormalTok{balance}
\CommentTok{#> [1] -12}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Create an R6 class that represents a shuffled deck of cards. You should be able to draw cards from the deck with \texttt{\$draw(n)}, and return all cards to the deck and reshuffle with \texttt{\$reshuffle()}. Use the following code to make a vector of cards.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{suit <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"SPADE"}\NormalTok{, }\StringTok{"HEARTS"}\NormalTok{, }\StringTok{"DIAMOND"}\NormalTok{, }\StringTok{"CLUB"}\NormalTok{)}
\NormalTok{value <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\StringTok{"J"}\NormalTok{, }\StringTok{"Q"}\NormalTok{, }\StringTok{"K"}\NormalTok{)}
\NormalTok{cards <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{rep}\NormalTok{(value, }\DecValTok{4}\NormalTok{), suit)}
\end{Highlighting}
\end{Shaded}

\emph{(This question was altered slightly to avoid the unicode characters.)}

\textbf{{A}}: Our new \texttt{ShuffledDeck} class will use \texttt{sample()} and positive integer subsetting to implement the reshuffling and drawing functionality. We also add a check, so you cannot draw more cards than there are left in the deck.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ShuffledDeck <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"ShuffledDeck"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{deck =} \OtherTok{NULL}\NormalTok{,}
    \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{deck =}\NormalTok{ cards) \{}
\NormalTok{      self}\OperatorTok{$}\NormalTok{deck <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(deck)}
\NormalTok{    \},}
    \DataTypeTok{reshuffle =} \ControlFlowTok{function}\NormalTok{() \{}
\NormalTok{      self}\OperatorTok{$}\NormalTok{deck <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(cards)}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \},}
    \DataTypeTok{n =} \ControlFlowTok{function}\NormalTok{() \{}
      \KeywordTok{length}\NormalTok{(self}\OperatorTok{$}\NormalTok{deck)}
\NormalTok{    \},}
    \DataTypeTok{draw =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{n =} \DecValTok{1}\NormalTok{) \{}
      \ControlFlowTok{if}\NormalTok{ (n }\OperatorTok{>}\StringTok{ }\NormalTok{self}\OperatorTok{$}\KeywordTok{n}\NormalTok{()) \{}
        \KeywordTok{stop}\NormalTok{(}\StringTok{"Only "}\NormalTok{, self}\OperatorTok{$}\KeywordTok{n}\NormalTok{(), }\StringTok{" cards remaining."}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{      \}}

\NormalTok{      output <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{deck[}\KeywordTok{seq_len}\NormalTok{(n)]}
\NormalTok{      self}\OperatorTok{$}\NormalTok{deck <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\NormalTok{deck[}\OperatorTok{-}\KeywordTok{seq_len}\NormalTok{(n)]}
\NormalTok{      output}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To test this class, we create a deck (initialise an instance), draw all the cards, then reshuffle, checking we get different cards each time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_deck <-}\StringTok{ }\NormalTok{ShuffledDeck}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

\NormalTok{my_deck}\OperatorTok{$}\KeywordTok{draw}\NormalTok{(}\DecValTok{52}\NormalTok{)}
\CommentTok{#>  [1] "6<U+2660>"  "10<U+2666>" "Q<U+2663>"  "J<U+2660>"  "Q<U+2665>" }
\CommentTok{#>  [6] "8<U+2666>"  "5<U+2666>"  "4<U+2663>"  "9<U+2663>"  "9<U+2660>" }
\CommentTok{#> [11] "5<U+2660>"  "3<U+2665>"  "J<U+2663>"  "2<U+2666>"  "K<U+2660>" }
\CommentTok{#> [16] "2<U+2665>"  "2<U+2660>"  "8<U+2660>"  "8<U+2665>"  "6<U+2665>" }
\CommentTok{#> [21] "7<U+2665>"  "6<U+2663>"  "K<U+2663>"  "3<U+2663>"  "10<U+2660>"}
\CommentTok{#> [26] "3<U+2666>"  "Q<U+2660>"  "9<U+2665>"  "J<U+2666>"  "7<U+2666>" }
\CommentTok{#> [31] "9<U+2666>"  "7<U+2660>"  "4<U+2666>"  "10<U+2665>" "2<U+2663>" }
\CommentTok{#> [36] "4<U+2660>"  "4<U+2665>"  "8<U+2663>"  "K<U+2665>"  "A<U+2660>" }
\CommentTok{#> [41] "A<U+2665>"  "5<U+2665>"  "A<U+2666>"  "5<U+2663>"  "7<U+2663>" }
\CommentTok{#> [46] "Q<U+2666>"  "A<U+2663>"  "10<U+2663>" "3<U+2660>"  "K<U+2666>" }
\CommentTok{#> [51] "J<U+2665>"  "6<U+2666>"}
\NormalTok{my_deck}\OperatorTok{$}\KeywordTok{draw}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error: Only 0 cards remaining}

\NormalTok{my_deck}\OperatorTok{$}\KeywordTok{reshuffle}\NormalTok{()}\OperatorTok{$}\KeywordTok{draw}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] "6<U+2666>" "2<U+2663>" "Q<U+2666>" "9<U+2663>" "J<U+2666>"}
\NormalTok{my_deck}\OperatorTok{$}\KeywordTok{reshuffle}\NormalTok{()}\OperatorTok{$}\KeywordTok{draw}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] "8<U+2663>" "9<U+2660>" "2<U+2660>" "Q<U+2665>" "6<U+2660>"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Why can't you model a bank account or a deck of cards with an S3 class?

\textbf{{A}}: Because S3 classes obey R's usual semantics of copy-on-modify: every time you deposit money onto your bank account or drew a card from the deck, you'd get a new copy of the object.

It is possible to combine S3 classes with an environment (which is how R6 works), but it is ill-advised to create an object that looks like a regular R object but has reference semantics.

\textbf{{Q4}}: Create an R6 class that allows you to get and set the current time zone. You can access the current time zone with \texttt{Sys.timezone()} and set it with \texttt{Sys.setenv(TZ\ =\ "newtimezone")}. When setting the time zone, make sure the new time zone is in the list provided by \texttt{OlsonNames()}.

\textbf{{A}}: To create an R6 class that allows us to get and set the time zone, we provide the respective functions as public methods to the R6 class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Timezone <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"Timezone"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{get =} \ControlFlowTok{function}\NormalTok{() \{}
      \KeywordTok{Sys.timezone}\NormalTok{()}
\NormalTok{    \},}
    \DataTypeTok{set =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \KeywordTok{stopifnot}\NormalTok{(value }\OperatorTok{%in%}\StringTok{ }\KeywordTok{OlsonNames}\NormalTok{())}

\NormalTok{      old <-}\StringTok{ }\NormalTok{self}\OperatorTok{$}\KeywordTok{get}\NormalTok{()}
      \KeywordTok{Sys.setenv}\NormalTok{(}\DataTypeTok{TZ =}\NormalTok{ value)}
      \KeywordTok{invisible}\NormalTok{(old)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

(When setting, we return the old value invisibly because this makes it easy to restore the previous value.)

Now, let us create one instance of this class and test, if we can set and get the time zone as intended.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tz <-}\StringTok{ }\NormalTok{Timezone}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

\NormalTok{old <-}\StringTok{ }\NormalTok{tz}\OperatorTok{$}\KeywordTok{set}\NormalTok{(}\StringTok{"Antarctica/South_Pole"}\NormalTok{)}
\NormalTok{tz}\OperatorTok{$}\KeywordTok{get}\NormalTok{()}
\CommentTok{#> [1] "Antarctica/South_Pole"}

\NormalTok{tz}\OperatorTok{$}\KeywordTok{set}\NormalTok{(old)}
\NormalTok{tz}\OperatorTok{$}\KeywordTok{get}\NormalTok{()}
\CommentTok{#> [1] "Europe/Berlin"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Create an R6 class that manages the current working directory. It should have \texttt{\$get()} and \texttt{\$set()} methods.

\textbf{{A}}: Take a look at the following implementation, which is quite minimalistic:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{WorkingDirectory <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"WorkingDirectory"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{get =} \ControlFlowTok{function}\NormalTok{() \{}
      \KeywordTok{getwd}\NormalTok{()}
\NormalTok{    \},}
    \DataTypeTok{set =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \KeywordTok{setwd}\NormalTok{(value)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: Why can't you model the time zone or current working directory with an S3 class?

\textbf{{A}}: Because S3 classes are not suitable for modelling state that changes over time. S3 methods should (almost) always return the same result when called with the same inputs.

\textbf{{Q7}}: What base type are R6 objects built on top of? What attributes do they have?

\textbf{{A}}: R6 objects are built on top of environments. They have a \texttt{class} attribute, which is a character vector containing the class name, the name of any super classes (if existent) and the string \texttt{"R6"} as the last element.

\hypertarget{controlling-access}{%
\section{Controlling access}\label{controlling-access}}

\textbf{{Q1}}: Create a bank account class that prevents you from directly setting the account balance, but you can still withdraw from and deposit to. Throw an error if you attempt to go into overdraft.

\textbf{{A}}: To fulfil this requirement, we make balance a private field. The user has to use the \texttt{\$deposit()} and \texttt{\$withdraw()} methods which have access to the balance field.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{BankAccountStrict2 <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"BankAccountStrict2"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{deposit =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{dep =} \DecValTok{0}\NormalTok{) \{}
\NormalTok{      private}\OperatorTok{$}\NormalTok{balance <-}\StringTok{ }\NormalTok{private}\OperatorTok{$}\NormalTok{balance }\OperatorTok{+}\StringTok{ }\NormalTok{dep}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \},}
    \DataTypeTok{withdraw =} \ControlFlowTok{function}\NormalTok{(}\DataTypeTok{draw =} \DecValTok{0}\NormalTok{) \{}
      \ControlFlowTok{if}\NormalTok{ (private}\OperatorTok{$}\NormalTok{balance }\OperatorTok{-}\StringTok{ }\NormalTok{draw }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{stop}\NormalTok{(}
          \StringTok{"Your `withdraw` must be smaller "}\NormalTok{,}
          \StringTok{"than your `balance`."}\NormalTok{,}
          \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{        )}
\NormalTok{      \}}
\NormalTok{      private}\OperatorTok{$}\NormalTok{balance <-}\StringTok{ }\NormalTok{private}\OperatorTok{$}\NormalTok{balance }\OperatorTok{-}\StringTok{ }\NormalTok{draw}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \}}
\NormalTok{  ),}
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{balance =} \DecValTok{0}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To test our new class, we create an instance and try to go into overdraft.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_account_strict_}\DecValTok{2}\NormalTok{ <-}\StringTok{ }\NormalTok{BankAccountStrict2}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}

\NormalTok{my_account_strict_}\DecValTok{2}\OperatorTok{$}\KeywordTok{deposit}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\NormalTok{my_account_strict_}\DecValTok{2}\OperatorTok{$}\KeywordTok{withdraw}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> Error: Your `withdraw` must be smaller than your `balance`.}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Create a class with a write-only \texttt{\$password} field. It should have \texttt{\$check\_password(password)} method that returns \texttt{TRUE} or \texttt{FALSE}, but there should be no way to view the complete password.

\textbf{{A}}: To protect the password from changes and direct access, the password will be a private field. Further, our \texttt{Password} will get its own print method which hides the password.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Password <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"Password"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{print =} \ControlFlowTok{function}\NormalTok{(...) \{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"<Password>: ********}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
      \KeywordTok{invisible}\NormalTok{(self)}
\NormalTok{    \},}
    \DataTypeTok{set =} \ControlFlowTok{function}\NormalTok{(value) \{}
\NormalTok{      private}\OperatorTok{$}\NormalTok{password <-}\StringTok{ }\NormalTok{value}
\NormalTok{    \},}
    \DataTypeTok{check =} \ControlFlowTok{function}\NormalTok{(password) \{}
      \KeywordTok{identical}\NormalTok{(password, private}\OperatorTok{$}\NormalTok{password)}
\NormalTok{    \}}
\NormalTok{  ),}
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{password =} \OtherTok{NULL}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's create one instance of our new class and confirm that the password is neither accessible nor visible, but still check-able.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_pw <-}\StringTok{ }\NormalTok{Password}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{my_pw}\OperatorTok{$}\KeywordTok{set}\NormalTok{(}\StringTok{"snuffles"}\NormalTok{)}
\NormalTok{my_pw}\OperatorTok{$}\NormalTok{password}
\CommentTok{#> NULL}
\NormalTok{my_pw}
\CommentTok{#> <Password>: ********}
\NormalTok{my_pw}\OperatorTok{$}\KeywordTok{check}\NormalTok{(}\StringTok{"snuggles"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\NormalTok{my_pw}\OperatorTok{$}\KeywordTok{check}\NormalTok{(}\StringTok{"snuffles"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Extend the \texttt{Rando} class with another active binding that allows you to access the previous random value. Ensure that active binding is the only way to access the value.

\textbf{{A}}: To access the previous random value from an instance, we add a private \texttt{\$last\_random} field to our class, and we modify \texttt{\$random()} to write to this field, whenever it is called. To access the \texttt{\$last\_random} field we provide \texttt{\$previous()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Rando <-}\StringTok{ }\NormalTok{R6}\OperatorTok{::}\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"Rando"}\NormalTok{,}
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{last_random =} \OtherTok{NULL}
\NormalTok{  ),}
  \DataTypeTok{active =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{random =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(value)) \{}
\NormalTok{        private}\OperatorTok{$}\NormalTok{last_random <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{        private}\OperatorTok{$}\NormalTok{last_random}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{stop}\NormalTok{(}\StringTok{"Can't set `$random`."}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{    \},}
    \DataTypeTok{previous =} \ControlFlowTok{function}\NormalTok{(value) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{missing}\NormalTok{(value)) \{}
\NormalTok{        private}\OperatorTok{$}\NormalTok{last_random}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now, we initiate a new \texttt{Rando} object and see if it behaves as expected.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\NormalTok{Rando}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}
\NormalTok{x}\OperatorTok{$}\NormalTok{random}
\CommentTok{#> [1] 0.349}
\NormalTok{x}\OperatorTok{$}\NormalTok{random}
\CommentTok{#> [1] 0.947}
\NormalTok{x}\OperatorTok{$}\NormalTok{previous}
\CommentTok{#> [1] 0.947}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Can subclasses access private fields/methods from their parent? Perform an experiment to find out.

\textbf{{A}}: To find out if private fields/methods can be accessed from subclasses, we first create a class \texttt{A} with a private field \texttt{foo} and a private method \texttt{bar()}. Afterwards, an instance of a subclass \texttt{B} is created and calls the \texttt{foobar()} methods, which tries to access the \texttt{foo} field and the \texttt{bar()} method from its superclass \texttt{A}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"A"}\NormalTok{,}
  \DataTypeTok{private =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{field =} \StringTok{"foo"}\NormalTok{,}
    \DataTypeTok{method =} \ControlFlowTok{function}\NormalTok{() \{}
      \StringTok{"bar"}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{B <-}\StringTok{ }\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"B"}\NormalTok{,}
  \DataTypeTok{inherit =}\NormalTok{ A,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{test =} \ControlFlowTok{function}\NormalTok{() \{}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Field:  "}\NormalTok{, super}\OperatorTok{$}\NormalTok{field, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
      \KeywordTok{cat}\NormalTok{(}\StringTok{"Method: "}\NormalTok{, super}\OperatorTok{$}\KeywordTok{method}\NormalTok{(), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}

\NormalTok{B}\OperatorTok{$}\KeywordTok{new}\NormalTok{()}\OperatorTok{$}\KeywordTok{test}\NormalTok{()}
\CommentTok{#> Field:  }
\CommentTok{#> Method: bar}
\end{Highlighting}
\end{Shaded}

We conclude that subclasses can access private methods from their superclasses, but not private fields.

\hypertarget{reference-semantics}{%
\section{Reference semantics}\label{reference-semantics}}

\textbf{{Q1}}: Create a class that allows you to write a line to a specified file. You should open a connection to the file in \texttt{\$initialize()}, append a line using \texttt{cat()} in \texttt{\$append\_line()}, and close the connection in \texttt{\$finalize()}.

\textbf{{A}}: Our \texttt{FileWriter} class will create a connection to a file at initialization. Therefore, we open a connection to a user specified file during the initialisation. Note that we need to set \texttt{open\ =\ "a"} in \texttt{file()} to open connection for appending text. Otherwise, \texttt{cat()} would only work when applied to files, but not with connections as explicitly asked for in the exercise. Further, we add the \texttt{append\_line()} method and a \texttt{close()} statement as finalizer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{FileWriter <-}\StringTok{ }\NormalTok{R6}\OperatorTok{::}\KeywordTok{R6Class}\NormalTok{(}
  \DataTypeTok{classname =} \StringTok{"FileWriter"}\NormalTok{,}
  \DataTypeTok{public =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{con =} \OtherTok{NULL}\NormalTok{,}
    \DataTypeTok{initialize =} \ControlFlowTok{function}\NormalTok{(filename) \{}
\NormalTok{      self}\OperatorTok{$}\NormalTok{con <-}\StringTok{ }\KeywordTok{file}\NormalTok{(filename, }\DataTypeTok{open =} \StringTok{"a"}\NormalTok{)}
\NormalTok{    \},}

    \DataTypeTok{finalize =} \ControlFlowTok{function}\NormalTok{() \{}
      \KeywordTok{close}\NormalTok{(self}\OperatorTok{$}\NormalTok{con)}
\NormalTok{    \},}

    \DataTypeTok{append_line =} \ControlFlowTok{function}\NormalTok{(x) \{}
      \KeywordTok{cat}\NormalTok{(x, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{, }\DataTypeTok{file =}\NormalTok{ self}\OperatorTok{$}\NormalTok{con)}
\NormalTok{    \}}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's see, if new instances of our class work as expected.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp_file <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\NormalTok{my_fw <-}\StringTok{ }\NormalTok{FileWriter}\OperatorTok{$}\KeywordTok{new}\NormalTok{(tmp_file)}

\KeywordTok{readLines}\NormalTok{(tmp_file)}
\CommentTok{#> character(0)}
\NormalTok{my_fw}\OperatorTok{$}\KeywordTok{append_line}\NormalTok{(}\StringTok{"First"}\NormalTok{)}
\NormalTok{my_fw}\OperatorTok{$}\KeywordTok{append_line}\NormalTok{(}\StringTok{"Second"}\NormalTok{)}
\KeywordTok{readLines}\NormalTok{(tmp_file)}
\CommentTok{#> [1] "First"  "Second"}
\end{Highlighting}
\end{Shaded}

\hypertarget{s4}{%
\chapter{S4}\label{s4}}

\hypertarget{prerequisites-8}{%
\section*{Prerequisites}\label{prerequisites-8}}


We load the \texttt{\{methods\}} package as it contains the S4 object-oriented programming system.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(methods)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{basics-1}{%
\section{Basics}\label{basics-1}}

\textbf{{Q1}}: \texttt{lubridate::period()} returns an S4 class. What slots does it have? What class is each slot? What accessors does it provide?

\textbf{{A}}: Objects of the S4 \texttt{Period} class have six slots named \texttt{year}, \texttt{month}, \texttt{day}, \texttt{hour}, \texttt{minute}, and \texttt{.Data} (which contains the number of seconds). All slots are of type double. Most fields can be retrieved by an identically named accessor (e.g.~\texttt{lubridate::year()} will return the field), use \texttt{second()} to get the \texttt{.Data} slot.

As a short example, we create a period of 1 second, 2 minutes, 3 hours, 4 days and 5 weeks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{example_}\DecValTok{12345}\NormalTok{ <-}\StringTok{ }\NormalTok{lubridate}\OperatorTok{::}\KeywordTok{period}\NormalTok{(}
  \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{), }
  \KeywordTok{c}\NormalTok{(}\StringTok{"second"}\NormalTok{, }\StringTok{"minute"}\NormalTok{, }\StringTok{"hour"}\NormalTok{, }\StringTok{"day"}\NormalTok{, }\StringTok{"week"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This should add up to a period of 39 days, 3 hours, 2 minutes and 1 second.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{example_}\DecValTok{12345}
\CommentTok{#> [1] "39d 3H 2M 1S"}
\end{Highlighting}
\end{Shaded}

When we inspect \texttt{example\_12345}, we see the fields and infer that the seconds are stored in the \texttt{.Data} field.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(example_}\DecValTok{12345}\NormalTok{)}
\CommentTok{#> Formal class 'Period' [package "lubridate"] with 6 slots}
\CommentTok{#>   ..@ .Data : num 1}
\CommentTok{#>   ..@ year  : num 0}
\CommentTok{#>   ..@ month : num 0}
\CommentTok{#>   ..@ day   : num 39}
\CommentTok{#>   ..@ hour  : num 3}
\CommentTok{#>   ..@ minute: num 2}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What other ways can you find help for a method? Read \texttt{?"?"} and summarise the details.

\textbf{{A}}: Besides adding \texttt{?} in front of a function call (i.e.~\texttt{?method()}), we may find:

\begin{itemize}
\tightlist
\item
  general documentation for a generic via \texttt{?genericName}
\item
  general documentation for the methods of a generic via \texttt{methods?genericName}
\item
  documentation for a specific method via \texttt{ClassName?methodName}.
\end{itemize}

\hypertarget{classes-1}{%
\section{Classes}\label{classes-1}}

\textbf{{Q1}}: Extend the Person class with fields to match \texttt{utils::person()}. Think about what slots you will need, what class each slot should have, and what you'll need to check in your validity method.

\textbf{{A}}: The Person class from Advanced R contains the slots \texttt{name} and \texttt{age}. The person class from the \texttt{\{utils\}} package contains the slots \texttt{given} (vector of given names), \texttt{family}, \texttt{role}, \texttt{email} and \texttt{comment} (see \texttt{?utils::person}).

All slots from \texttt{utils::person()} besides \texttt{role} must be of type character and length 1. The entries in the \texttt{role} slot must match one of the following abbreviations ``aut'', ``com'', ``cph'', ``cre'', ``ctb'', ``ctr'', ``dtc'', ``fnd'', ``rev'', ``ths'', ``trl''. Therefore, \texttt{role} might be of different length than the other slots and we'll add a corresponding constraint within the validator.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Definition of the Person class}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{,}
    \DataTypeTok{given =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{family =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{role =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{email =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{comment =} \StringTok{"character"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{age =} \OtherTok{NA_real_}\NormalTok{,}
    \DataTypeTok{given =} \OtherTok{NA_character_}\NormalTok{,}
    \DataTypeTok{family =} \OtherTok{NA_character_}\NormalTok{,}
    \DataTypeTok{role =} \OtherTok{NA_character_}\NormalTok{,}
    \DataTypeTok{email =} \OtherTok{NA_character_}\NormalTok{,}
    \DataTypeTok{comment =} \OtherTok{NA_character_}
\NormalTok{  )}
\NormalTok{)}

\CommentTok{# Helper to create instances of the Person class}
\NormalTok{Person <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(given, family,}
                   \DataTypeTok{age =} \OtherTok{NA_real_}\NormalTok{,}
                   \DataTypeTok{role =} \OtherTok{NA_character_}\NormalTok{,}
                   \DataTypeTok{email =} \OtherTok{NA_character_}\NormalTok{,}
                   \DataTypeTok{comment =} \OtherTok{NA_character_}\NormalTok{) \{}
\NormalTok{  age <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(age)}

  \KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{,}
    \DataTypeTok{age =}\NormalTok{ age,}
    \DataTypeTok{given =}\NormalTok{ given,}
    \DataTypeTok{family =}\NormalTok{ family,}
    \DataTypeTok{role =}\NormalTok{ role,}
    \DataTypeTok{email =}\NormalTok{ email,}
    \DataTypeTok{comment =}\NormalTok{ comment}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Validator to ensure that each slot is of length one}
\KeywordTok{setValidity}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{  invalids <-}\StringTok{ }\KeywordTok{c}\NormalTok{()}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{age)     }\OperatorTok{!=}\StringTok{ }\DecValTok{1} \OperatorTok{||}
\StringTok{      }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{given)   }\OperatorTok{!=}\StringTok{ }\DecValTok{1} \OperatorTok{||}
\StringTok{      }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{family)  }\OperatorTok{!=}\StringTok{ }\DecValTok{1} \OperatorTok{||}
\StringTok{      }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{email)   }\OperatorTok{!=}\StringTok{ }\DecValTok{1} \OperatorTok{||}
\StringTok{      }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{comment) }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
\NormalTok{    invalids <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"@name, @age, @given, @family, @email, "}\NormalTok{,}
                       \StringTok{"@comment must be of length 1"}\NormalTok{)}
\NormalTok{  \} }
  
\NormalTok{  known_roles <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
    \OtherTok{NA_character_}\NormalTok{, }\StringTok{"aut"}\NormalTok{, }\StringTok{"com"}\NormalTok{, }\StringTok{"cph"}\NormalTok{, }\StringTok{"cre"}\NormalTok{, }\StringTok{"ctb"}\NormalTok{,}
    \StringTok{"ctr"}\NormalTok{, }\StringTok{"dtc"}\NormalTok{, }\StringTok{"fnd"}\NormalTok{, }\StringTok{"rev"}\NormalTok{, }\StringTok{"ths"}\NormalTok{, }\StringTok{"trl"}
\NormalTok{  )}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{all}\NormalTok{(object}\OperatorTok{@}\NormalTok{role }\OperatorTok{%in%}\StringTok{ }\NormalTok{known_roles)) \{}
    \KeywordTok{paste}\NormalTok{(}
      \StringTok{"@role(s) must be one of"}\NormalTok{, }
      \KeywordTok{paste}\NormalTok{(known_roles, }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  \}}
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(invalids)) }\KeywordTok{return}\NormalTok{(invalids)  }
  \OtherTok{TRUE}
\NormalTok{\})}
\CommentTok{#> Class "Person" [in ".GlobalEnv"]}
\CommentTok{#> }
\CommentTok{#> Slots:}
\CommentTok{#>                                                                   }
\CommentTok{#> Name:        age     given    family      role     email   comment}
\CommentTok{#> Class:   numeric character character character character character}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What happens if you define a new S4 class that doesn't have any slots? (Hint: read about virtual classes in \texttt{?setClass}.)

\textbf{{A}}: It depends on the other arguments. If we inherit from another class, we get the same slots. But something interesting happens if we don't inherit from an existing class. We get a virtual class. A virtual class can't be instantiated:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Human"}\NormalTok{)}
\KeywordTok{new}\NormalTok{(}\StringTok{"Human"}\NormalTok{)}
\CommentTok{#> Error in new("Human"): trying to generate an object from a virtual}
\CommentTok{#> class ("Human")}
\end{Highlighting}
\end{Shaded}

But can be inherited from:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Programmer"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Human"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Imagine you were going to reimplement factors, dates, and data frames in S4. Sketch out the \texttt{setClass()} calls that you would use to define the classes. Think about appropriate \texttt{slots} and \texttt{prototype}.

\textbf{{A}}: For all these classes we need one slot for the data and one slot per attribute. Keep in mind, that inheritance matters for ordered factors and dates. For data frames, special checks like equal lengths of the underlying list's elements should be done within a validator.

For simplicity we don't introduce an explicit subclass for ordered factors. Instead, we introduce \texttt{ordered} as a slot.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Factor"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{data =} \StringTok{"integer"}\NormalTok{,}
    \DataTypeTok{levels =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{ordered =} \StringTok{"logical"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{data =} \KeywordTok{integer}\NormalTok{(),}
    \DataTypeTok{levels =} \KeywordTok{character}\NormalTok{(),}
    \DataTypeTok{ordered =} \OtherTok{FALSE}
\NormalTok{  )}
\NormalTok{)}


\KeywordTok{new}\NormalTok{(}\StringTok{"Factor"}\NormalTok{, }\DataTypeTok{data =} \KeywordTok{c}\NormalTok{(1L, 2L), }\DataTypeTok{levels =}\NormalTok{ letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{])}
\CommentTok{#> An object of class "Factor"}
\CommentTok{#> Slot "data":}
\CommentTok{#> [1] 1 2}
\CommentTok{#> }
\CommentTok{#> Slot "levels":}
\CommentTok{#> [1] "a" "b" "c"}
\CommentTok{#> }
\CommentTok{#> Slot "ordered":}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

The \texttt{Date2} class stores its dates as integers, similarly to base R which uses doubles. Dates don't have any other attributes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Date2"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{data =} \StringTok{"integer"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{data =} \KeywordTok{integer}\NormalTok{()}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{new}\NormalTok{(}\StringTok{"Date2"}\NormalTok{, }\DataTypeTok{data =}\NormalTok{ 1L)}
\CommentTok{#> An object of class "Date2"}
\CommentTok{#> Slot "data":}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

Our \texttt{DataFrame} class consists of a list and a slot for \texttt{row.names}. Most of the logic (e.g.~checking that all elements of the list are a vector, and that they all have the same length) would need to be part of a validator.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"DataFrame"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{data =} \StringTok{"list"}\NormalTok{,}
    \DataTypeTok{row.names =} \StringTok{"character"}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{data =} \KeywordTok{list}\NormalTok{(),}
    \DataTypeTok{row.names =} \KeywordTok{character}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}

\KeywordTok{new}\NormalTok{(}\StringTok{"DataFrame"}\NormalTok{, }\DataTypeTok{data =} \KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{))}
\CommentTok{#> An object of class "DataFrame"}
\CommentTok{#> Slot "data":}
\CommentTok{#> $a}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> $b}
\CommentTok{#> [1] 2}
\CommentTok{#> }
\CommentTok{#> }
\CommentTok{#> Slot "row.names":}
\CommentTok{#> character(0)}
\end{Highlighting}
\end{Shaded}

\hypertarget{generics-and-methods-1}{%
\section{Generics and methods}\label{generics-and-methods-1}}

\textbf{{Q1}}: Add \texttt{age()} accessors for the \texttt{Person} class.

\textbf{{A}}: We implement the accessors via an \texttt{age()} generic, with a method for the \texttt{Person} class and a corresponding replacement function \texttt{age\textless{}-}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"age"}\NormalTok{))}
\CommentTok{#> [1] "age"}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{@}\NormalTok{age)}

\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"age<-"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"age<-"}\NormalTok{))}
\CommentTok{#> [1] "age<-"}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"age<-"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, value) \{}
\NormalTok{  x}\OperatorTok{@}\NormalTok{age <-}\StringTok{ }\NormalTok{value}
  \KeywordTok{validObject}\NormalTok{(x)}
\NormalTok{  x}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: In the definition of the generic, why is it necessary to repeat the name of the generic twice?

\textbf{{A}}: Within \texttt{setGeneric()} the \texttt{name} (1st argument) is needed as the name of the generic. Then, the name also explicitly incorporates method dispatch via \texttt{standardGeneric()} within the generic's body (\texttt{def} parameter of \texttt{setGeneric()}). This behaviour is similar to \texttt{UseMethod()} in S3.

\textbf{{Q3}}: Why does the \texttt{show()} method defined in section \href{https://adv-r.hadley.nz/s4.html\#show-method}{15.4.3} use \texttt{is(object){[}{[}1{]}{]}}? (Hint: try printing the employee subclass.)

\textbf{{A}}: \texttt{is(object)} returns the class of the object. \texttt{is(object)} also contains the superclass, for subclasses like \texttt{Employee}. In order to always return the most specific class (the subclass), \texttt{show()} returns the first element of \texttt{is(object)}.

\textbf{{Q4}}: What happens if you define a method with different argument names to the generic?

\textbf{{A}}: It depends. We first create the object \texttt{hadley} of class \texttt{Person}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.Person <-}\StringTok{ }\KeywordTok{setClass}\NormalTok{(}
  \StringTok{"Person"}\NormalTok{,}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{)}
\NormalTok{)}

\NormalTok{hadley <-}\StringTok{ }\KeywordTok{.Person}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{)}
\NormalTok{hadley}
\CommentTok{#> An object of class "Person"}
\CommentTok{#> Slot "name":}
\CommentTok{#> [1] "Hadley"}
\CommentTok{#> }
\CommentTok{#> Slot "age":}
\CommentTok{#> numeric(0)}
\end{Highlighting}
\end{Shaded}

Now let's see, which arguments can be supplied to the \texttt{show()} generic.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{formals}\NormalTok{(}\StringTok{"show"}\NormalTok{)}
\CommentTok{#> $object}
\end{Highlighting}
\end{Shaded}

Usually, we would use this argument when defining a new method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
  \KeywordTok{cat}\NormalTok{(object}\OperatorTok{@}\NormalTok{name, }\StringTok{"creates hard exercises"}\NormalTok{)}
\NormalTok{\})}

\NormalTok{hadley}
\CommentTok{#> Hadley creates hard exercises}
\end{Highlighting}
\end{Shaded}

When we supply another name as a first element of our method (e.g.~\texttt{x} instead of \texttt{object}), this element will be matched to the correct \texttt{object} argument and we receive a warning. Our method will work, though:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat}\NormalTok{(x}\OperatorTok{@}\NormalTok{name, }\StringTok{"creates hard exercises"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> Warning: For function 'show', signature 'Person': argument in method}
\CommentTok{#> definition changed from (x) to (object)}

\NormalTok{hadley}
\CommentTok{#> Hadley creates hard exercises}
\end{Highlighting}
\end{Shaded}

If we add more arguments to our method than our generic can handle, we will get an error.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, y) \{}
  \KeywordTok{cat}\NormalTok{(x}\OperatorTok{@}\NormalTok{name, }\StringTok{"is"}\NormalTok{, x}\OperatorTok{@}\NormalTok{age, }\StringTok{"years old"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> Error in conformMethod(signature, mnames, fnames, f, fdef,}
\CommentTok{#> definition): in method for 'show' with signature 'object="Person"':}
\CommentTok{#> formal arguments (object = "Person") omitted in the method}
\CommentTok{#> definition cannot be in the signature}
\end{Highlighting}
\end{Shaded}

If we do this with arguments added to the correctly written \texttt{object} argument, we will receive an informative error message. It states that we could add other argument names for generics, which can take the \texttt{...} argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"show"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object, y) \{}
  \KeywordTok{cat}\NormalTok{(object}\OperatorTok{@}\NormalTok{name, }\StringTok{"is"}\NormalTok{, object}\OperatorTok{@}\NormalTok{age, }\StringTok{"years old"}\NormalTok{)}
\NormalTok{\})}
\CommentTok{#> Error in rematchDefinition(definition, fdef, mnames, fnames,}
\CommentTok{#> signature): methods can add arguments to the generic 'show' only if}
\CommentTok{#> '...' is an argument to the generic}
\end{Highlighting}
\end{Shaded}

\hypertarget{method-dispatch}{%
\section{Method dispatch}\label{method-dispatch}}

\textbf{{Q1}}: Draw the method graph for \texttt{f(}\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f605.png}}, \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f63d.png}}\texttt{)}.

\textbf{{A}}: Look at the graph and repeat after me: ``I will keep my class structure simple and use multiple inheritance sparingly''.

\begin{center}\includegraphics[width=350pt]{images/s4/method_dispatch1} \end{center}

\textbf{{Q2}}: Draw the method graph for \texttt{f(}\raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f603.png}}, \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f609.png}}, \raisebox{-.1\height}{\includegraphics[height=10pt]{emoji/1f619.png}}\texttt{)}.

\textbf{{A}}: We see that the method graph below looks simpler than the one above. Relatively speaking, multiple dispatch seems to introduce less complexity than multiple inheritance. Use it with care, though!

\begin{center}\includegraphics[width=350pt]{images/s4/method_dispatch2} \end{center}

\textbf{{Q3}}: Take the last example which shows multiple dispatch over two classes that use multiple inheritance. What happens if you define a method for all terminal classes? Why does method dispatch not save us much work here?

\textbf{{A}}: We will introduce ambiguity, since one class has distance 2 to all terminal nodes and the other four have distance 1 to two terminal nodes each. To resolve this ambiguity we h,ave to define five more methods, one per class combination.

\hypertarget{s4-and-s3}{%
\section{S4 and S3}\label{s4-and-s3}}

\textbf{{Q1}}: What would a full \texttt{setOldClass()} definition look like for an ordered factor (i.e.~add \texttt{slots} and \texttt{prototype} to the definition above)?

\textbf{{A}}: The purpose of \texttt{setOldClass()} lies in registering an S3 class as a ``formally defined class'', so that it can be used within the S4 object-oriented programming system. When using it, we may provide the argument \texttt{S4Class}, which will inherit the slots and their default values (prototype) to the registered class.

Let's build an S4 \texttt{OrderedFactor} on top of the S3 factor in such a way.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setOldClass}\NormalTok{(}\StringTok{"factor"}\NormalTok{)    }\CommentTok{# use build-in definition for brevity}

\NormalTok{OrderedFactor <-}\StringTok{ }\KeywordTok{setClass}\NormalTok{(}
  \StringTok{"OrderedFactor"}\NormalTok{,}
  \DataTypeTok{contains =} \StringTok{"factor"}\NormalTok{,   }\CommentTok{# inherit from registered S3 class}
  \DataTypeTok{slots =} \KeywordTok{c}\NormalTok{(}
    \DataTypeTok{levels =} \StringTok{"character"}\NormalTok{,}
    \DataTypeTok{ordered =} \StringTok{"logical"}  \CommentTok{# add logical order slot}
\NormalTok{  ),}
  \DataTypeTok{prototype =} \KeywordTok{structure}\NormalTok{(}
    \KeywordTok{integer}\NormalTok{(),}
    \DataTypeTok{levels =} \KeywordTok{character}\NormalTok{(),}
    \DataTypeTok{ordered =} \KeywordTok{logical}\NormalTok{()  }\CommentTok{# add default value}
\NormalTok{  )}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can now register the (S3) ordered-class, while providing an ``S4 template''. We can also use the S4-class to create new object directly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setOldClass}\NormalTok{(}\StringTok{"ordered"}\NormalTok{, }\DataTypeTok{S4Class =} \StringTok{"OrderedFactor"}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{OrderedFactor}\NormalTok{(}
  \KeywordTok{c}\NormalTok{(1L, 2L, 2L),}
  \DataTypeTok{levels =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{),}
  \DataTypeTok{ordered =} \OtherTok{TRUE}
\NormalTok{)}
\KeywordTok{str}\NormalTok{(x)}
\CommentTok{#> Formal class 'OrderedFactor' [package ".GlobalEnv"] with 4 slots}
\CommentTok{#>   ..@ .Data   : int [1:3] 1 2 2}
\CommentTok{#>   ..@ levels  : chr [1:3] "a" "b" "c"}
\CommentTok{#>   ..@ ordered : logi TRUE}
\CommentTok{#>   ..@ .S3Class: chr "factor"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Define a \texttt{length} method for the \texttt{Person} class.

\textbf{{A}}: We keep things simple and will just return \texttt{"180cm"} when the \texttt{length()} method is called on a \texttt{Person} object. The method can be defined either as an S3 or S4 method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{length.Person <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"180cm"}  \CommentTok{# S3}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"length"}\NormalTok{, }\StringTok{"Person"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"180cm"}\NormalTok{)  }\CommentTok{# S4}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-metaprogramming}{%
\part{Metaprogramming}\label{part-metaprogramming}}

\stepcounter{chapter}
\stepcounter{chapter}

\hypertarget{expressions}{%
\chapter{Expressions}\label{expressions}}

\hypertarget{prerequisites-9}{%
\section*{Prerequisites}\label{prerequisites-9}}


To capture and compute on expressions, and to visualise them, we will load the \texttt{\{rlang\}} and the \texttt{\{lobstr\}} packages.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(lobstr)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{abstract-syntax-trees}{%
\section{Abstract syntax trees}\label{abstract-syntax-trees}}

\textbf{{Q1}}: Reconstruct the code represented by the trees below:

\begin{verbatim}
#> o-f 
#> \-o-g 
#>   \-o-h
#> o-`+` 
#> +-o-`+` 
#> | +-1 
#> | \-2 
#> \-3
#> o-`*` 
#> +-o-`(` 
#> | \-o-`+` 
#> |   +-x 
#> |   \-y 
#> \-z
\end{verbatim}

\textbf{{A}}: Let the source (of the code chunks above) be with you and show you how the ASTs (abstract syntax trees) were produced.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\KeywordTok{h}\NormalTok{())))}
\CommentTok{#> o-f }
\CommentTok{#> \textbackslash{}-o-g }
\CommentTok{#>   \textbackslash{}-o-h}

\KeywordTok{ast}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{3}\NormalTok{)}
\CommentTok{#> o-`+` }
\CommentTok{#> +-o-`+` }
\CommentTok{#> | +-1 }
\CommentTok{#> | \textbackslash{}-2 }
\CommentTok{#> \textbackslash{}-3}

\KeywordTok{ast}\NormalTok{((x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{*}\StringTok{ }\NormalTok{z)}
\CommentTok{#> o-`*` }
\CommentTok{#> +-o-`(` }
\CommentTok{#> | \textbackslash{}-o-`+` }
\CommentTok{#> |   +-x }
\CommentTok{#> |   \textbackslash{}-y }
\CommentTok{#> \textbackslash{}-z}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Draw the following trees by hand then check your answers with \texttt{ast()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\KeywordTok{h}\NormalTok{(}\KeywordTok{i}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))))}
\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{())))}
\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let us delegate the drawing to the \texttt{\{lobstr\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\KeywordTok{h}\NormalTok{(}\KeywordTok{i}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)))))}
\CommentTok{#> o-f }
\CommentTok{#> \textbackslash{}-o-g }
\CommentTok{#>   \textbackslash{}-o-h }
\CommentTok{#>     \textbackslash{}-o-i }
\CommentTok{#>       +-1 }
\CommentTok{#>       +-2 }
\CommentTok{#>       \textbackslash{}-3}

\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{g}\NormalTok{(}\DecValTok{2}\NormalTok{, }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{()))))}
\CommentTok{#> o-f }
\CommentTok{#> +-1 }
\CommentTok{#> \textbackslash{}-o-g }
\CommentTok{#>   +-2 }
\CommentTok{#>   \textbackslash{}-o-h }
\CommentTok{#>     +-3 }
\CommentTok{#>     \textbackslash{}-o-i}

\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\KeywordTok{h}\NormalTok{(}\DecValTok{3}\NormalTok{, }\KeywordTok{i}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{))))}
\CommentTok{#> o-f }
\CommentTok{#> +-o-g }
\CommentTok{#> | +-1 }
\CommentTok{#> | \textbackslash{}-2 }
\CommentTok{#> \textbackslash{}-o-h }
\CommentTok{#>   +-3 }
\CommentTok{#>   \textbackslash{}-o-i }
\CommentTok{#>     +-4 }
\CommentTok{#>     \textbackslash{}-5}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: What's happening with the ASTs below? (Hint: carefully read \texttt{?"\^{}"})

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\StringTok{`}\DataTypeTok{x}\StringTok{`} \OperatorTok{+}\StringTok{ `}\DataTypeTok{y}\StringTok{`}\NormalTok{)}
\CommentTok{#> o-`+` }
\CommentTok{#> +-x }
\CommentTok{#> \textbackslash{}-y}
\KeywordTok{ast}\NormalTok{(x }\OperatorTok{**}\StringTok{ }\NormalTok{y)}
\CommentTok{#> o-`^` }
\CommentTok{#> +-x }
\CommentTok{#> \textbackslash{}-y}
\KeywordTok{ast}\NormalTok{(}\DecValTok{1}\NormalTok{ ->}\StringTok{ }\NormalTok{x)}
\CommentTok{#> o-`<-` }
\CommentTok{#> +-x }
\CommentTok{#> \textbackslash{}-1}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: ASTs start function calls with the name of the function. This is why the call in the first expression is translated into its prefix form. In the second case, \texttt{**} is translated by R's parser into \texttt{\^{}}. In the last AST, the expression is flipped when R parses it:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{**}\StringTok{ }\NormalTok{y))}
\CommentTok{#>  language x^y}
\KeywordTok{str}\NormalTok{(}\KeywordTok{expr}\NormalTok{(a ->}\StringTok{ }\NormalTok{b))}
\CommentTok{#>  language b <- a}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: What is special about the AST below? (Hint: re-read section \href{https://adv-r.hadley.nz/functions.html\#fun-components}{6.2.1})

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \DecValTok{2}\NormalTok{) \{\})}
\CommentTok{#> o-`function` }
\CommentTok{#> +-o-x = 1 }
\CommentTok{#> | \textbackslash{}-y = 2 }
\CommentTok{#> +-o-`\{` }
\CommentTok{#> \textbackslash{}-<inline srcref>}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The last leaf of the AST is not explicitly specified in the expression. Instead, the \texttt{srcref} attribute, which points to the functions source code, is automatically created by base R.

\textbf{{Q5}}: What does the call tree of an \texttt{if} statement with multiple \texttt{else\ if} conditions look like? Why?

\textbf{{A}}: The AST of nested \texttt{else\ if} statements might look a bit confusing because it contains multiple curly braces. However, we can see that in the \texttt{else} part of the AST just another expression is being evaluated, which happens to be an \texttt{if} statement and so forth.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}
  \ControlFlowTok{if}\NormalTok{ (}\OtherTok{FALSE}\NormalTok{) \{}
    \DecValTok{1}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OtherTok{FALSE}\NormalTok{) \{}
    \DecValTok{2}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OtherTok{TRUE}\NormalTok{) \{}
    \DecValTok{3}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> o-`if` }
\CommentTok{#> +-FALSE }
\CommentTok{#> +-o-`\{` }
\CommentTok{#> | \textbackslash{}-1 }
\CommentTok{#> \textbackslash{}-o-`if` }
\CommentTok{#>   +-FALSE }
\CommentTok{#>   +-o-`\{` }
\CommentTok{#>   | \textbackslash{}-2 }
\CommentTok{#>   \textbackslash{}-o-`if` }
\CommentTok{#>     +-TRUE }
\CommentTok{#>     \textbackslash{}-o-`\{` }
\CommentTok{#>       \textbackslash{}-3}
\end{Highlighting}
\end{Shaded}

We can see the structure more clearly if we avoid the curly braces:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}
  \ControlFlowTok{if}\NormalTok{ (}\OtherTok{FALSE}\NormalTok{) }\DecValTok{1} 
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OtherTok{FALSE}\NormalTok{) }\DecValTok{2} 
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\OtherTok{TRUE}\NormalTok{) }\DecValTok{3}
\NormalTok{)}
\CommentTok{#> o-`if` }
\CommentTok{#> +-FALSE }
\CommentTok{#> +-1 }
\CommentTok{#> \textbackslash{}-o-`if` }
\CommentTok{#>   +-FALSE }
\CommentTok{#>   +-2 }
\CommentTok{#>   \textbackslash{}-o-`if` }
\CommentTok{#>     +-TRUE }
\CommentTok{#>     \textbackslash{}-3}
\end{Highlighting}
\end{Shaded}

\hypertarget{expressions-1}{%
\section{Expressions}\label{expressions-1}}

\textbf{{Q1}}: Which two of the six types of atomic vector can't appear in an expression? Why? Similarly, why can't you create an expression that contains an atomic vector of length greater than one?

\textbf{{A}}: There is no way to create raws and complex atomics without using a function call (this is only possible for imaginary scalars like \texttt{i}, \texttt{5i} etc.). But expressions that include a function are \emph{calls}. Therefore, both of these vector types cannot appear in an expression.

Similarly, it is not possible to create an expression that evaluates to an atomic of length greater than one without using a function (e.g.~\texttt{c()}).

Let's make this observation concrete via an example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Atomic}
\KeywordTok{is_atomic}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] TRUE}

\CommentTok{# Not an atomic (although it would evaluate to an atomic)}
\KeywordTok{is_atomic}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] FALSE}
\KeywordTok{is_call}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{)))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: What happens when you subset a call object to remove the first element, e.g.~\texttt{expr(read.csv("foo.csv",\ header\ =\ TRUE)){[}-1{]}}. Why?

\textbf{{A}}: When the first element of a call object is removed, the second element moves to the first position, which is the function to call. Therefore, we get \texttt{"foo.csv"(header\ =\ TRUE)}.

\textbf{{Q3}}: Describe the differences between the following call objects.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}

\KeywordTok{call2}\NormalTok{(median, x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(median, }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The call objects differ in their first two elements, which are in some cases evaluated before the call is constructed. In the first one, both \texttt{median()} and \texttt{x} are evaluated and inlined into the call. Therefore, we can see in the constructed call that median is a generic and the \texttt{x} argument is 1:10.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(median, x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> (function (x, na.rm = FALSE, ...) }
\CommentTok{#> UseMethod("median"))(1:10, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

In the following calls we remain with differing combinations. Once, only \texttt{x} and once only \texttt{median()} gets evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> median(1:10, na.rm = TRUE)}
\KeywordTok{call2}\NormalTok{(median, }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> (function (x, na.rm = FALSE, ...) }
\CommentTok{#> UseMethod("median"))(x, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

In the final call neither \texttt{x} nor \texttt{median()} are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\KeywordTok{expr}\NormalTok{(median), }\KeywordTok{expr}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> median(x, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

Note that all these calls will generate the same result when evaluated. The key difference is when the values bound to the \texttt{x} and \texttt{median} symbols are found.

\textbf{{Q4}}: \texttt{rlang::call\_standardise()} doesn't work so well for the following calls.
Why? What makes \texttt{mean()} special?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, na.rm = TRUE)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{n =}\NormalTok{ T, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, n = T)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, , }\OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, , TRUE)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The reason for this unexpected behaviour is that \texttt{mean()} uses the \texttt{...} argument and therefore cannot standardise the regarding arguments. Since \texttt{mean()} uses S3 dispatch (i.e.~\texttt{UseMethod()}) and the underlying \texttt{mean.default()} method specifies some more arguments, \texttt{call\_standardise()} can do much better with a specific S3 method.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean.default}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean.default(x = 1:10, na.rm = TRUE)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean.default}\NormalTok{(}\DataTypeTok{n =}\NormalTok{ T, }\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean.default(x = 1:10, na.rm = T)}
\KeywordTok{call_standardise}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean.default}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, , }\OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean.default(x = 1:10, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: Why does this code not make sense?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: As stated in Advanced R

\begin{quote}
The first element of a call is always the function that gets called.
\end{quote}

Let's see what happens when we run the code

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\NormalTok{x}
\CommentTok{#> foo(x = 1)}

\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\StringTok{""}\NormalTok{)}
\NormalTok{x}
\CommentTok{#> foo(1)}

\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{""}\NormalTok{, }\StringTok{"x"}\NormalTok{)}
\NormalTok{x}
\CommentTok{#> foo(x = 1)}
\end{Highlighting}
\end{Shaded}

So, giving the first element a name just adds metadata that R ignores.

\textbf{{Q6}}: Construct the expression \texttt{if(x\ \textgreater{}\ 1)\ "a"\ else\ "b"} using multiple calls to \texttt{call2()}. How does the code structure reflect the structure of the AST?

\textbf{{A}}: Similar to the prefix version we get

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call2}\NormalTok{(}\StringTok{"if"}\NormalTok{, }\KeywordTok{call2}\NormalTok{(}\StringTok{">"}\NormalTok{, }\KeywordTok{sym}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{), }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{)}
\CommentTok{#> if (x > 1) "a" else "b"}
\end{Highlighting}
\end{Shaded}

When we read the AST from left to right, we get the same structure: Function to evaluate, expression, which is another function and is evaluated first, and two constants which will be evaluated next.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{(x }\OperatorTok{>}\StringTok{ }\DecValTok{1}\NormalTok{, }\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{))}
\CommentTok{#> o-`if` }
\CommentTok{#> +-o-`>` }
\CommentTok{#> | +-x }
\CommentTok{#> | \textbackslash{}-1 }
\CommentTok{#> +-"a" }
\CommentTok{#> \textbackslash{}-"b"}
\end{Highlighting}
\end{Shaded}

\hypertarget{parsing-and-grammar}{%
\section{Parsing and grammar}\label{parsing-and-grammar}}

\textbf{{Q1}}: R uses parentheses in two slightly different ways as illustrated by these two calls:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{((}\DecValTok{1}\NormalTok{))}
\StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Compare and contrast the two uses by referencing the AST.

\textbf{{A}}: The trick with these examples lies in the fact, that \texttt{(} can be a part of R's general prefix function syntax but can also represent a call to the \texttt{(} function.

So, in the AST of the first example, we will not see the outer \texttt{(} since it is prefix function syntax and belongs to \texttt{f()}. In contrast, the inner \texttt{(} is a function (represented as a symbol in the AST):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{((}\DecValTok{1}\NormalTok{)))}
\CommentTok{#> o-f }
\CommentTok{#> \textbackslash{}-o-`(` }
\CommentTok{#>   \textbackslash{}-1}
\end{Highlighting}
\end{Shaded}

In the second example, we can see that the outer \texttt{(} is a function and the inner \texttt{(} belongs to its syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{(}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{))}
\CommentTok{#> o-`(` }
\CommentTok{#> \textbackslash{}-o-`+` }
\CommentTok{#>   +-1 }
\CommentTok{#>   \textbackslash{}-1}
\end{Highlighting}
\end{Shaded}

For the sake of clarity, let's also create a third example, where none of the \texttt{(} is part of another function's syntax:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(((}\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{)))}
\CommentTok{#> o-`(` }
\CommentTok{#> \textbackslash{}-o-`(` }
\CommentTok{#>   \textbackslash{}-o-`+` }
\CommentTok{#>     +-1 }
\CommentTok{#>     \textbackslash{}-1}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: \texttt{=} can also be used in two ways. Construct a simple example that shows both uses.

\textbf{{A}}: \texttt{=} is used both for assignment, and for naming arguments in function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{c =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

So, when we play with \texttt{ast()}, we can directly see that the following is not possible:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{c =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> Error in ast(b = c(c = 1)): unused argument (b = c(c = 1))}
\end{Highlighting}
\end{Shaded}

We get an error because \texttt{b\ =} makes R looking for an argument called \texttt{b}. Since \texttt{x} is the only argument of \texttt{ast()}, we get an error.

The easiest way around this problem is to wrap this line in \texttt{\{\}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(\{b =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{c =} \DecValTok{1}\NormalTok{)\})}
\CommentTok{#> o-`\{` }
\CommentTok{#> \textbackslash{}-o-`=` }
\CommentTok{#>   +-b }
\CommentTok{#>   \textbackslash{}-o-c }
\CommentTok{#>     \textbackslash{}-c = 1}
\end{Highlighting}
\end{Shaded}

When we ignore the braces and compare the trees, we can see, that the first \texttt{=} is used for assignment and the second \texttt{=} is part of the syntax of function calls.

\textbf{{Q3}}: Does \texttt{-2\^{}2} yield 4 or -4? Why?

\textbf{{A}}: It yields \texttt{-4}, because \texttt{\^{}} has a higher operator precedence than \texttt{-}, which we can verify by looking at the AST (or looking it up under \texttt{?"Syntax"}):

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{-2}\OperatorTok{^}\DecValTok{2}
\CommentTok{#> [1] -4}

\KeywordTok{ast}\NormalTok{(}\OperatorTok{-}\DecValTok{2}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\CommentTok{#> o-`-` }
\CommentTok{#> \textbackslash{}-o-`^` }
\CommentTok{#>   +-2 }
\CommentTok{#>   \textbackslash{}-2}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: What does \texttt{!1\ +\ !1} return? Why?

\textbf{{A}}: The answer is a little surprising:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!}\DecValTok{1} \OperatorTok{+}\StringTok{ }\OperatorTok{!}\DecValTok{1}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

To answer the ``why?'', we take a look at the AST:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\OperatorTok{!}\DecValTok{1} \OperatorTok{+}\StringTok{ }\OperatorTok{!}\DecValTok{1}\NormalTok{)}
\CommentTok{#> o-`!` }
\CommentTok{#> \textbackslash{}-o-`+` }
\CommentTok{#>   +-1 }
\CommentTok{#>   \textbackslash{}-o-`!` }
\CommentTok{#>     \textbackslash{}-1}
\end{Highlighting}
\end{Shaded}

The right \texttt{!1} is evaluated first. It evaluates to \texttt{FALSE}, because R coerces every non 0 numeric to \texttt{TRUE}, when a logical operator is applied. The negation of \texttt{TRUE} then equals \texttt{FALSE}.

Next \texttt{1\ +\ FALSE} is evaluated to \texttt{1}, since \texttt{FALSE} is coerced to \texttt{0}.

Finally \texttt{!1} is evaluated to \texttt{FALSE}.

Note that if \texttt{!} had a higher precedence, the intermediate result would be \texttt{FALSE\ +\ FALSE}, which would evaluate to \texttt{0}.

\textbf{{Q5}}: Why does \texttt{x1\ \textless{}-\ x2\ \textless{}-\ x3\ \textless{}-\ 0} work? Describe the two reasons.

\textbf{{A}}: One reason is that \texttt{\textless{}-} is right-associative, i.e.~evaluation takes place from right to left:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x1 <-}\StringTok{ }\NormalTok{(x2 <-}\StringTok{ }\NormalTok{(x3 <-}\StringTok{ }\DecValTok{0}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

The other reason is that \texttt{\textless{}-} invisibly returns the value on the right-hand side.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x3 <-}\StringTok{ }\DecValTok{0}\NormalTok{)}
\CommentTok{#> [1] 0}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: Compare the ASTs of \texttt{x\ +\ y\ \%+\%\ z} and \texttt{x\ \^{}\ y\ \%+\%\ z}. What have you learned about the precedence of custom infix functions?

\textbf{{A}}: Let's take a look at the syntax trees:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{%+%}\StringTok{ }\NormalTok{z)}
\CommentTok{#> o-`+` }
\CommentTok{#> +-x }
\CommentTok{#> \textbackslash{}-o-`%+%` }
\CommentTok{#>   +-y }
\CommentTok{#>   \textbackslash{}-z}
\end{Highlighting}
\end{Shaded}

Here \texttt{y\ \%+\%\ z} will be calculated first and the result will be added to \texttt{x}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(x }\OperatorTok{^}\StringTok{ }\NormalTok{y }\OperatorTok{%+%}\StringTok{ }\NormalTok{z)}
\CommentTok{#> o-`%+%` }
\CommentTok{#> +-o-`^` }
\CommentTok{#> | +-x }
\CommentTok{#> | \textbackslash{}-y }
\CommentTok{#> \textbackslash{}-z}
\end{Highlighting}
\end{Shaded}

Here \texttt{x\ \^{}\ y} will be calculated first, and the result will be used as first argument to \texttt{\%+\%()}.

We can conclude that custom infix functions have precedence between addition and exponentiation.

The exact precedence of infix functions can be looked up under \texttt{?"Syntax"} where we see that it lies directly behind the sequence operator (\texttt{:}) and in front of the multiplication and division operators (\texttt{*} and \texttt{/}).

\textbf{{Q7}}: What happens if you call \texttt{parse\_expr()} with a string that generates multiple expressions, e.g.~\texttt{parse\_expr("x\ +\ 1;\ y\ +\ 1")}?

\textbf{{A}}: In this case \texttt{parse\_expr()} notices that more than one expression would have to be generated and throws an error.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{parse_expr}\NormalTok{(}\StringTok{"x + 1; y + 1"}\NormalTok{)}
\CommentTok{#> Error: More than one expression parsed}
\end{Highlighting}
\end{Shaded}

\textbf{{Q8}}: What happens if you attempt to parse an invalid expression, e.g.~\texttt{"a\ +"} or \texttt{"f())"}?

\textbf{{A}}: Invalid expressions will lead to an error in the underlying \texttt{parse()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{parse_expr}\NormalTok{(}\StringTok{"a +"}\NormalTok{)}
\CommentTok{#> Error in parse(text = elt): <text>:2:0: unexpected end of input}
\CommentTok{#> 1: a +}
\CommentTok{#> ^}
\KeywordTok{parse_expr}\NormalTok{(}\StringTok{"f())"}\NormalTok{)}
\CommentTok{#> Error in parse(text = elt): <text>:1:4: unexpected ')'}
\CommentTok{#> 1: f())}
\CommentTok{#> ^}

\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \StringTok{"a +"}\NormalTok{)}
\CommentTok{#> Error in parse(text = "a +"): <text>:2:0: unexpected end of input}
\CommentTok{#> 1: a +}
\CommentTok{#> ^}
\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \StringTok{"f())"}\NormalTok{)}
\CommentTok{#> Error in parse(text = "f())"): <text>:1:4: unexpected ')'}
\CommentTok{#> 1: f())}
\CommentTok{#> ^}
\end{Highlighting}
\end{Shaded}

\textbf{{Q9}}: \texttt{deparse()} produces vectors when the input is long. For example, the following call produces a vector of length two:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{g}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{e }\OperatorTok{+}\StringTok{ }\NormalTok{f }\OperatorTok{+}\StringTok{ }\NormalTok{g }\OperatorTok{+}\StringTok{ }\NormalTok{h }\OperatorTok{+}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\NormalTok{k }\OperatorTok{+}\StringTok{ }\NormalTok{l }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{+}\StringTok{ }
\StringTok{                 }\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{o }\OperatorTok{+}\StringTok{ }\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{q }\OperatorTok{+}\StringTok{ }\NormalTok{r }\OperatorTok{+}\StringTok{ }\NormalTok{s }\OperatorTok{+}\StringTok{ }\NormalTok{t }\OperatorTok{+}\StringTok{ }\NormalTok{u }\OperatorTok{+}\StringTok{ }\NormalTok{v }\OperatorTok{+}\StringTok{ }\NormalTok{w }\OperatorTok{+}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z))}

\KeywordTok{deparse}\NormalTok{(expr)}
\end{Highlighting}
\end{Shaded}

What does \texttt{expr\_text()} do instead?

\textbf{{A}}: \texttt{expr\_text()} will paste the results from \texttt{deparse(expr)} together and use a linebreak (\texttt{\textbackslash{}n}) as separator.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{g}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b }\OperatorTok{+}\StringTok{ }\NormalTok{c }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{e }\OperatorTok{+}\StringTok{ }\NormalTok{f }\OperatorTok{+}\StringTok{ }\NormalTok{g }\OperatorTok{+}\StringTok{ }\NormalTok{h }\OperatorTok{+}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\NormalTok{k }\OperatorTok{+}\StringTok{ }\NormalTok{l }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{+}\StringTok{ }
\StringTok{                 }\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{o }\OperatorTok{+}\StringTok{ }\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{q }\OperatorTok{+}\StringTok{ }\NormalTok{r }\OperatorTok{+}\StringTok{ }\NormalTok{s }\OperatorTok{+}\StringTok{ }\NormalTok{t }\OperatorTok{+}\StringTok{ }\NormalTok{u }\OperatorTok{+}\StringTok{ }\NormalTok{v }\OperatorTok{+}\StringTok{ }\NormalTok{w }\OperatorTok{+}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\NormalTok{z))}
\KeywordTok{deparse}\NormalTok{(expr)}
\CommentTok{#> [1] "g(a + b + c + d + e + f + g + h + i + j + k + l + m + n + "}
\CommentTok{#> [2] "o + p + q + r + s + t + u + v + w + x + y + z)"}
\KeywordTok{expr_text}\NormalTok{(expr)}
\CommentTok{#> [1] "g(a + b + c + d + e + f + g + h + i + j + k + l + m + n }
\CommentTok{#> + \textbackslash{}n    o + p + q + r + s + t + u + v + w + x + y + z)"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q10}}: \texttt{pairwise.t.test()} assumes that \texttt{deparse()} always returns a length one character vector. Can you construct an input that violates this expectation? What happens?

\textbf{{A}}: The function \texttt{pairwise.t.test()} captures its data arguments (\texttt{x} and \texttt{g}) so it can print the input expressions along the computed p-values. Prior to R 4.0.0 this used to be implemented via \texttt{deparse(subsitute(x))} in combination with \texttt{paste()}. This could lead to unexpected output, if one of the inputs exceeded the default \texttt{width.cutoff} value of 60 characters within \texttt{deparse()}. In this case, the expression would be split into a character vector of length greater 1.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Output prior to R 4.0.0}
\NormalTok{d <-}\StringTok{ }\DecValTok{1}
\KeywordTok{pairwise.t.test}\NormalTok{(}\DecValTok{2}\NormalTok{, d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }
\StringTok{                  }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\CommentTok{#>  Pairwise comparisons using t tests with pooled SD }
\CommentTok{#> }
\CommentTok{#> data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d}
\CommentTok{#> + d + d +  2 and     d }
\CommentTok{#> }
\CommentTok{#> <0 x 0 matrix>}
\CommentTok{#> }
\CommentTok{#> P value adjustment method: holm }
\end{Highlighting}
\end{Shaded}

In \href{https://cran.r-project.org/doc/manuals/r-release/NEWS.html}{R 4.0.0} \texttt{pairwise.t.test()} was updated to use the newly introduced \texttt{deparse1()}, which serves as a wrapper around \texttt{deparse()}.

\begin{quote}
deparse1() is a simple utility added in R 4.0.0 to ensure a string result (character vector of length one), typically used in name construction, as deparse1(substitute(.)).
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Output since R 4.0.0}
\NormalTok{d <-}\StringTok{ }\DecValTok{1}
\KeywordTok{pairwise.t.test}\NormalTok{(}\DecValTok{2}\NormalTok{, d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }
\StringTok{                  }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\CommentTok{#>  Pairwise comparisons using t tests with pooled SD }
\CommentTok{#> }
\CommentTok{#> data:  2 and d + d + d + d + d + d + d + d + d + d + d + d + d + d}
\CommentTok{#> + d + d + d}
\CommentTok{#> }
\CommentTok{#> <0 x 0 matrix>}
\CommentTok{#> }
\CommentTok{#> P value adjustment method: holm }
\end{Highlighting}
\end{Shaded}

\hypertarget{ast-funs}{%
\section{Walking AST with recursive functions}\label{ast-funs}}

\textbf{{Q1}}: \texttt{logical\_abbr()} returns \texttt{TRUE} for \texttt{T(1,\ 2,\ 3)}. How could you modify \texttt{logical\_abbr\_rec()} so that it ignores function calls that use \texttt{T} or \texttt{F}?

\textbf{{A}}: We can apply a similar logic as in the \href{https://adv-r.hadley.nz/expressions.html\#finding-all-variables-created-by-assignment}{assignment example} from Advanced R. We just treat it as a special case handled within a sub function called \texttt{find\_T\_call()}, which finds \texttt{T()} calls and ``bounces them out''. Therefore, we also repeat the \texttt{expr\_type()} helper which tells us if we are in the base or in the recursive case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr_type <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (rlang}\OperatorTok{::}\KeywordTok{is_syntactic_literal}\NormalTok{(x)) \{}
    \StringTok{"constant"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.symbol}\NormalTok{(x)) \{}
    \StringTok{"symbol"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \StringTok{"call"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \StringTok{"pairlist"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{typeof}\NormalTok{(x)}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{switch_expr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \ControlFlowTok{switch}\NormalTok{(}\KeywordTok{expr_type}\NormalTok{(x),}
\NormalTok{         ...,}
         \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }
              \KeywordTok{typeof}\NormalTok{(x), }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_T_call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"T"}\NormalTok{)) \{}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{    purrr}\OperatorTok{::}\KeywordTok{some}\NormalTok{(x, logical_abbr_rec)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    purrr}\OperatorTok{::}\KeywordTok{some}\NormalTok{(x, logical_abbr_rec)}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{logical_abbr_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(}
\NormalTok{    x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =} \OtherTok{FALSE}\NormalTok{,}
    \DataTypeTok{symbol =} \KeywordTok{as_string}\NormalTok{(x) }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{, }\StringTok{"T"}\NormalTok{),}
    
    \CommentTok{# Recursive cases}
    \DataTypeTok{pairlist =}\NormalTok{ purrr}\OperatorTok{::}\KeywordTok{some}\NormalTok{(x, logical_abbr_rec),}
    \DataTypeTok{call =} \KeywordTok{find_T_call}\NormalTok{(x)}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{logical_abbr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{logical_abbr_rec}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now let's test our new \texttt{logical\_abbr()} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{T}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{#> [1] FALSE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{T}\NormalTok{(T, }\KeywordTok{T}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)))}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{T}\NormalTok{(T))}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{T}\NormalTok{())}
\CommentTok{#> [1] FALSE}
\KeywordTok{logical_abbr}\NormalTok{()}
\CommentTok{#> [1] FALSE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, T, T))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: \texttt{logical\_abbr()} works with expressions. It currently fails when you give it a function. Why? How could you modify \texttt{logical\_abbr()} to make it work? What components of a function will you need to recurse over?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{x =} \OtherTok{TRUE}\NormalTok{) \{}
  \KeywordTok{g}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{T)}
\NormalTok{\}}
\KeywordTok{logical_abbr}\NormalTok{(}\OperatorTok{!!}\NormalTok{f)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The function currently fails, because \texttt{"closure"} is not handled in \texttt{switch\_expr()} within \texttt{logical\_abbr\_rec()}. If we want to make it work, we have to write a function to also iterate over the formals and the body of the input function.

\textbf{{Q3}}: Modify \texttt{find\_assign} to also detect assignment using replacement functions, i.e.~\texttt{names(x)\ \textless{}-\ y}.

\textbf{{A}}: Let`s see what the AST of such an assignment looks like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\NormalTok{x)}
\CommentTok{#> o-`<-` }
\CommentTok{#> +-o-names }
\CommentTok{#> | \textbackslash{}-x }
\CommentTok{#> \textbackslash{}-x}
\end{Highlighting}
\end{Shaded}

So, we need to catch the case where the first two elements are both calls. Further the first call is identical to \texttt{\textless{}-} and we must return only the second call to see which objects got new values assigned.

This is why we add the following block within another \texttt{else} statement in \texttt{find\_assign\_call()}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"<-"}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is_call}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])) \{}
\NormalTok{  lhs <-}\StringTok{ }\KeywordTok{expr_text}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{  children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let us finish with the whole code, followed by some tests for our new function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{flat_map_chr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.x, .f, ...) \{}
\NormalTok{  purrr}\OperatorTok{::}\KeywordTok{flatten_chr}\NormalTok{(purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(.x, .f, ...))}
\NormalTok{\}}

\NormalTok{find_assign <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{unique}\NormalTok{(}\KeywordTok{find_assign_rec}\NormalTok{(}\KeywordTok{enexpr}\NormalTok{(x)))}

\NormalTok{find_assign_call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"<-"}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is_symbol}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])) \{}
\NormalTok{    lhs <-}\StringTok{ }\KeywordTok{as_string}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{    children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x, }\StringTok{"<-"}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\KeywordTok{is_call}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])) \{}
\NormalTok{      lhs <-}\StringTok{ }\KeywordTok{expr_text}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      lhs <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)}
\NormalTok{    \}\}}
  
  \KeywordTok{c}\NormalTok{(lhs, }\KeywordTok{flat_map_chr}\NormalTok{(children, find_assign_rec))}
\NormalTok{\}}

\NormalTok{find_assign_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(}
\NormalTok{    x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =}\NormalTok{ ,}\DataTypeTok{symbol =} \KeywordTok{character}\NormalTok{(),}
    \CommentTok{# Recursive cases}
    \DataTypeTok{pairlist =} \KeywordTok{flat_map_chr}\NormalTok{(x, find_assign_rec),}
    \DataTypeTok{call =} \KeywordTok{find_assign_call}\NormalTok{(x)}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Tests functionality}
\KeywordTok{find_assign}\NormalTok{(x <-}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] "x"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{names}\NormalTok{(x))}
\CommentTok{#> character(0)}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] "names(x)"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\KeywordTok{x}\NormalTok{(y)) <-}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] "names(x(y))"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\KeywordTok{x}\NormalTok{(y)) <-}\StringTok{ }\NormalTok{y <-}\StringTok{ }\NormalTok{z)}
\CommentTok{#> [1] "names(x(y))" "y"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Write a function that extracts all calls to a specified function.

\textbf{{A}}: Here we need to delete the previously added else statement and check for a call (not necessarily \texttt{\textless{}-}) within the first \texttt{if()} in \texttt{find\_assign\_call()}. We save a call when we found one and return it later as part of our character output. Everything else stays the same:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign_call <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is_call}\NormalTok{(x)) \{}
\NormalTok{    lhs <-}\StringTok{ }\KeywordTok{expr_text}\NormalTok{(x)}
\NormalTok{    children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    lhs <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
\NormalTok{    children <-}\StringTok{ }\KeywordTok{as.list}\NormalTok{(x)}
\NormalTok{  \}}
  
  \KeywordTok{c}\NormalTok{(lhs, }\KeywordTok{flat_map_chr}\NormalTok{(children, find_assign_rec))}
\NormalTok{\}}

\NormalTok{find_assign_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(}
\NormalTok{    x,}
    \CommentTok{# Base cases}
    \DataTypeTok{constant =}\NormalTok{ ,}
    \DataTypeTok{symbol =} \KeywordTok{character}\NormalTok{(),}

    \CommentTok{# Recursive cases}
    \DataTypeTok{pairlist =} \KeywordTok{flat_map_chr}\NormalTok{(x, find_assign_rec),}
    \DataTypeTok{call =} \KeywordTok{find_assign_call}\NormalTok{(x)}
\NormalTok{  )}
\NormalTok{\}}

\KeywordTok{find_assign}\NormalTok{(x <-}\StringTok{ }\NormalTok{y)}
\CommentTok{#> [1] "x <- y"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{names}\NormalTok{(}\KeywordTok{x}\NormalTok{(y)) <-}\StringTok{ }\NormalTok{y <-}\StringTok{ }\NormalTok{z)}
\CommentTok{#> [1] "names(x(y)) <- y <- z" "names(x(y))"          }
\CommentTok{#> [3] "x(y)"                  "y <- z"}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)))}
\CommentTok{#> [1] "mean(sum(1:3))" "sum(1:3)"       "1:3"}
\end{Highlighting}
\end{Shaded}

\hypertarget{quasiquotation}{%
\chapter{Quasiquotation}\label{quasiquotation}}

\hypertarget{prerequisites-10}{%
\section*{Prerequisites}\label{prerequisites-10}}


To continue computing on the language, we keep using the \texttt{\{rlang\}} package in this chapter.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{motivation}{%
\section{Motivation}\label{motivation}}

\textbf{{Q1}}: For each function in the following base R code, identify which arguments are quoted and which are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(MASS)}

\NormalTok{mtcars2 <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(mtcars, cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{)}

\KeywordTok{with}\NormalTok{(mtcars2, }\KeywordTok{sum}\NormalTok{(vs))}
\KeywordTok{sum}\NormalTok{(mtcars2}\OperatorTok{$}\NormalTok{am)}

\KeywordTok{rm}\NormalTok{(mtcars2)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: For each argument we first follow the advice from Advanced R and execute the argument outside of the respective function. Since \texttt{MASS}, \texttt{cyl}, \texttt{vs} and \texttt{am} are not objects contained in the global environment, their execution raises an ``Object not found'' error. This way we confirm that the respective function arguments are quoted. For the other arguments, we may inspect the source code (and the documentation) to check if any quoting mechanisms are applied or the arguments are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(MASS)  }\CommentTok{# MASS -> quoted}
\end{Highlighting}
\end{Shaded}

\texttt{library()} also accepts character vectors and doesn't quote when \texttt{character.only} is set to \texttt{TRUE}, so \texttt{library(MASS,\ character.only\ =\ TRUE)} would raise an error.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mtcars2 <-}\StringTok{ }\KeywordTok{subset}\NormalTok{(mtcars, cyl }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{)  }\CommentTok{# mtcars -> evaluated}
\CommentTok{# cyl -> quoted}

\KeywordTok{with}\NormalTok{(mtcars2, }\KeywordTok{sum}\NormalTok{(vs))  }\CommentTok{# mtcars2 -> evaluated}
\CommentTok{# sum(vs) -> quoted}

\KeywordTok{sum}\NormalTok{(mtcars2}\OperatorTok{$}\NormalTok{am)  }\CommentTok{# matcars$am -> evaluated}
\CommentTok{# am -> quoted by $()    }
\end{Highlighting}
\end{Shaded}

When we inspect the source code of \texttt{rm()}, we notice that \texttt{rm()} catches its \texttt{...} argument as an unevaluated call (in this case a pairlist) via \texttt{match.call()}. This call is then converted into a string for further evaluation.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rm}\NormalTok{(mtcars2)  }\CommentTok{# mtcars2 -> quoted}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: For each function in the following tidyverse code, identify which arguments are quoted and which are evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{library}\NormalTok{(ggplot2)}

\NormalTok{by_cyl <-}\StringTok{ }\NormalTok{mtcars }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(cyl) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(mpg))}

\KeywordTok{ggplot}\NormalTok{(by_cyl, }\KeywordTok{aes}\NormalTok{(cyl, mean)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: From the previous exercise we've already learned that \texttt{library()} quotes its first argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)    }\CommentTok{# dplyr   -> quoted}
\KeywordTok{library}\NormalTok{(ggplot2)  }\CommentTok{# ggplot2 -> quoted}
\end{Highlighting}
\end{Shaded}

In similar fashion, it becomes clear that \texttt{cyl} is quoted by \texttt{group\_by()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{by_cyl <-}\StringTok{ }\NormalTok{mtcars }\OperatorTok{%>%}\StringTok{           }\CommentTok{# mtcars -> evaluated}
\StringTok{  }\KeywordTok{group_by}\NormalTok{(cyl) }\OperatorTok{%>%}\StringTok{            }\CommentTok{# cyl -> quoted}
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{mean =} \KeywordTok{mean}\NormalTok{(mpg))  }\CommentTok{# mean = mean(mpg) -> quoted}
\end{Highlighting}
\end{Shaded}

To find out what happens in \texttt{summarise()}, we inspect the source code. Tracing down the S3-dispatch of \texttt{summarise()}, we see that the \texttt{...} argument is quoted in \texttt{dplyr:::summarise\_cols()} which is called in the underlying \texttt{summarise.data.frame()} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{::}\NormalTok{summarise}
\CommentTok{#> function (.data, ..., .groups = NULL) }
\CommentTok{#> \{}
\CommentTok{#>     UseMethod("summarise")}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000018c33218>}
\CommentTok{#> <environment: namespace:dplyr>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{:::}\NormalTok{summarise.data.frame}
\CommentTok{#> function (.data, ..., .groups = NULL) }
\CommentTok{#> \{}
\CommentTok{#>     cols <- summarise_cols(.data, ...)}
\CommentTok{#>     out <- summarise_build(.data, cols)}
\CommentTok{#>     if (identical(.groups, "rowwise")) \{}
\CommentTok{#>         out <- rowwise_df(out, character())}
\CommentTok{#>     \}}
\CommentTok{#>     out}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x00000000192ed1d8>}
\CommentTok{#> <environment: namespace:dplyr>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplyr}\OperatorTok{:::}\NormalTok{summarise_cols}
\CommentTok{#> function (.data, ...) }
\CommentTok{#> \{}
\CommentTok{#>     mask <- DataMask$new(.data, caller_env())}
\CommentTok{#>     dots <- enquos(...)}
\CommentTok{#>     dots_names <- names(dots)}
\CommentTok{#>     auto_named_dots <- names(enquos(..., .named = TRUE))}
\CommentTok{#>     cols <- list()}
\CommentTok{#>     sizes <- 1L}
\CommentTok{#>     chunks <- vector("list", length(dots))}
\CommentTok{#>     types <- vector("list", length(dots))}
\CommentTok{#>     }
\CommentTok{#>     ## function definition abbreviated for clarity ##}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x55b540c07ca0>}
\CommentTok{#> <environment: namespace:dplyr>}
\end{Highlighting}
\end{Shaded}

In the following \texttt{\{ggplot2\}} expression the \texttt{cyl}- and \texttt{mean}-objects are quoted.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(by_cyl,            }\CommentTok{# by_cyl -> evaluated}
       \KeywordTok{aes}\NormalTok{(cyl, mean)) }\OperatorTok{+}\StringTok{  }\CommentTok{# aes() -> evaluated}
\StringTok{  }\CommentTok{# cyl, mean -> quoted (via aes)}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() }
\end{Highlighting}
\end{Shaded}

We can confirm this also by inspecting \texttt{aes()}'s source code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ggplot2}\OperatorTok{::}\NormalTok{aes}
\CommentTok{#> function (x, y, ...) }
\CommentTok{#> \{}
\CommentTok{#>     exprs <- enquos(x = x, y = y, ..., .ignore_empty = "all")}
\CommentTok{#>     aes <- new_aes(exprs, env = parent.frame())}
\CommentTok{#>     rename_aes(aes)}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x00000000196df248>}
\CommentTok{#> <environment: namespace:ggplot2>}
\end{Highlighting}
\end{Shaded}

\hypertarget{quoting}{%
\section{Quoting}\label{quoting}}

\textbf{{Q1}}: How is \texttt{expr()} implemented? Look at its source code.

\textbf{{A}}: \texttt{expr()} acts as a simple wrapper, which passes its argument to \texttt{enexpr()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr}
\CommentTok{#> function (expr) }
\CommentTok{#> \{}
\CommentTok{#>     enexpr(expr)}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000015eba350>}
\CommentTok{#> <environment: namespace:rlang>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Compare and contrast the following two functions. Can you predict the output before running them?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
  \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}
\NormalTok{\}}
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
  \KeywordTok{enexprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\KeywordTok{f2}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Both functions are able to capture multiple arguments and will return a named list of expressions. \texttt{f1()} will return the arguments defined within the body of \texttt{f1()}. This happens because \texttt{exprs()} captures the expressions as specified by the developer during the definition of \texttt{f1()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f1}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\CommentTok{#> $x}
\CommentTok{#> x}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> y}
\end{Highlighting}
\end{Shaded}

\texttt{f2()} will return the arguments supplied to \texttt{f2()} as specified by the user when the function is called.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f2}\NormalTok{(a }\OperatorTok{+}\StringTok{ }\NormalTok{b, c }\OperatorTok{+}\StringTok{ }\NormalTok{d)}
\CommentTok{#> $x}
\CommentTok{#> a + b}
\CommentTok{#> }
\CommentTok{#> $y}
\CommentTok{#> c + d}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: What happens if you try to use \texttt{enexpr()} with an expression (i.e.~\texttt{enexpr(x\ +\ y)})? What happens if \texttt{enexpr()} is passed a missing argument?

\textbf{{A}}: In the first case an error is thrown:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{on_expr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}\KeywordTok{enexpr}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x))\}}
\KeywordTok{on_expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\CommentTok{#> Error: `arg` must be a symbol}
\end{Highlighting}
\end{Shaded}

In the second case a missing argument is returned:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{on_missing <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}\KeywordTok{enexpr}\NormalTok{(x)\}}
\KeywordTok{on_missing}\NormalTok{()}
\KeywordTok{is_missing}\NormalTok{(}\KeywordTok{on_missing}\NormalTok{())}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: How are \texttt{exprs(a)} and \texttt{exprs(a\ =\ )} different? Think about both the input and the output.

\textbf{{A}}: In \texttt{exprs(a)} the input \texttt{a} is interpreted as a symbol for an unnamed argument. Consequently, the output shows an unnamed list with the first element containing the symbol \texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out1 <-}\StringTok{ }\KeywordTok{exprs}\NormalTok{(a)}
\KeywordTok{str}\NormalTok{(out1)}
\CommentTok{#> List of 1}
\CommentTok{#>  $ : symbol a}
\end{Highlighting}
\end{Shaded}

In \texttt{exprs(a\ =\ )} the first argument is named \texttt{a}, but then no value is provided. This leads to the output of a named list with the first element named \texttt{a}, which contains the missing argument.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out2 <-}\StringTok{ }\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{a =}\NormalTok{ )}
\KeywordTok{str}\NormalTok{(out2)}
\CommentTok{#> List of 1}
\CommentTok{#>  $ a: symbol}
\KeywordTok{is_missing}\NormalTok{(out2}\OperatorTok{$}\NormalTok{a)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: What are other differences between \texttt{exprs()} and \texttt{alist()}? Read the documentation for the named arguments of \texttt{exprs()} to find out.

\textbf{{A}}: \texttt{exprs()} provides the additional arguments \texttt{.named} (\texttt{=\ FALSE}), \texttt{.ignore\_empty} (\texttt{c("trailing",\ "none",\ "all")}) and \texttt{.unquote\_names} (\texttt{TRUE}). \texttt{.named} allows to ensure that all dots are named. \texttt{ignore\_empty} allows to specify how empty arguments should be handled for dots (\texttt{"trailing"}) or all arguments (\texttt{"none"} and \texttt{"all"}). Further via \texttt{.unquote\_names} one can specify if \texttt{:=} should be treated like \texttt{=}. \texttt{:=} can be useful as it supports unquoting (\texttt{!!}) on the left-hand side.

\textbf{{Q6}}: The documentation for \texttt{substitute()} says:

\begin{quote}
Substitution takes place by examining each component of the parse tree
as follows:

\begin{itemize}
\tightlist
\item
  If it is not a bound symbol in \texttt{env}, it is unchanged.
\item
  If it is a promise object (i.e., a formal argument to a function) the expression slot of the promise replaces the symbol.
\item
  If it is an ordinary variable, its value is substituted, unless \texttt{env} is .GlobalEnv in which case the symbol is left unchanged.
\end{itemize}
\end{quote}

Create examples that illustrate each of the above cases.

\textbf{{A}}: Let's create a new environment \texttt{my\_env}, which contains no objects. In this case \texttt{substitute()} will just return its first argument (\texttt{expr}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_env <-}\StringTok{ }\KeywordTok{env}\NormalTok{()}
\KeywordTok{substitute}\NormalTok{(x, my_env)}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

When we create a function containing an argument, which is directly returned after substitution, this function just returns the provided expression:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{substitute}\NormalTok{(x)}

\KeywordTok{foo}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{*}\StringTok{ }\KeywordTok{sin}\NormalTok{(}\DecValTok{0}\NormalTok{))}
\CommentTok{#> x + y * sin(0)}
\end{Highlighting}
\end{Shaded}

In case \texttt{substitute()} can find (parts of) the expression in \texttt{env}, it will literally substitute. However, unless \texttt{env} is \texttt{.GlobalEnv}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_env}\OperatorTok{$}\NormalTok{x <-}\StringTok{ }\DecValTok{7}
\KeywordTok{substitute}\NormalTok{(x, my_env)}
\CommentTok{#> [1] 7}

\NormalTok{x <-}\StringTok{ }\DecValTok{7}
\KeywordTok{substitute}\NormalTok{(x, .GlobalEnv)}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

\hypertarget{unquoting}{%
\section{Unquoting}\label{unquoting}}

\textbf{{Q1}}: Given the following components:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xy <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)}
\NormalTok{xz <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\NormalTok{yz <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)}
\NormalTok{abc <-}\StringTok{ }\KeywordTok{exprs}\NormalTok{(a, b, c)}
\end{Highlighting}
\end{Shaded}

Use quasiquotation to construct the following calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{/}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)               }\CommentTok{# (1)}
\OperatorTok{-}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{z) }\OperatorTok{^}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z)              }\CommentTok{# (2)}
\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y) }\OperatorTok{+}\StringTok{ }\NormalTok{(y }\OperatorTok{+}\StringTok{ }\NormalTok{z) }\OperatorTok{-}\StringTok{ }\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y)     }\CommentTok{# (3)}
\KeywordTok{atan2}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y, y }\OperatorTok{+}\StringTok{ }\NormalTok{z)             }\CommentTok{# (4)}
\KeywordTok{sum}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y, x }\OperatorTok{+}\StringTok{ }\NormalTok{y, y }\OperatorTok{+}\StringTok{ }\NormalTok{z)        }\CommentTok{# (5)}
\KeywordTok{sum}\NormalTok{(a, b, c)                    }\CommentTok{# (6)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(a, b, c), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)  }\CommentTok{# (7)}
\KeywordTok{foo}\NormalTok{(}\DataTypeTok{a =}\NormalTok{ x }\OperatorTok{+}\StringTok{ }\NormalTok{y, }\DataTypeTok{b =}\NormalTok{ y }\OperatorTok{+}\StringTok{ }\NormalTok{z)       }\CommentTok{# (8)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: We combine and unquote the given quoted expressions to construct the desired calls like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{xy }\OperatorTok{/}\StringTok{ }\OperatorTok{!!}\NormalTok{yz)                    }\CommentTok{# (1)}
\CommentTok{#> (x + y)/(y + z)}

\KeywordTok{expr}\NormalTok{(}\OperatorTok{-}\NormalTok{(}\OperatorTok{!!}\NormalTok{xz)}\OperatorTok{^}\NormalTok{(}\OperatorTok{!!}\NormalTok{yz))                 }\CommentTok{# (2)}
\CommentTok{#> -(x + z)^(y + z)}

\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{xy }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{yz }\OperatorTok{-}\StringTok{ }\OperatorTok{!!}\NormalTok{xz)             }\CommentTok{# (3)}
\CommentTok{#> x + y + (y + z) - (x + z)}

\KeywordTok{expr}\NormalTok{(}\KeywordTok{atan2}\NormalTok{(}\OperatorTok{!!}\NormalTok{xy, }\OperatorTok{!!}\NormalTok{yz))              }\CommentTok{# (4)}
\CommentTok{#> atan2(x + y, y + z)}

\KeywordTok{expr}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\OperatorTok{!!}\NormalTok{xy, }\OperatorTok{!!}\NormalTok{xy, }\OperatorTok{!!}\NormalTok{yz))          }\CommentTok{# (5)}
\CommentTok{#> sum(x + y, x + y, y + z)}

\KeywordTok{expr}\NormalTok{(}\KeywordTok{sum}\NormalTok{(}\OperatorTok{!!!}\NormalTok{abc))                    }\CommentTok{# (6)}
\CommentTok{#> sum(a, b, c)}

\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OperatorTok{!!!}\NormalTok{abc), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))  }\CommentTok{# (7)}
\CommentTok{#> mean(c(a, b, c), na.rm = TRUE)}

\KeywordTok{expr}\NormalTok{(}\KeywordTok{foo}\NormalTok{(}\DataTypeTok{a =} \OperatorTok{!!}\NormalTok{xy, }\DataTypeTok{b =} \OperatorTok{!!}\NormalTok{yz))        }\CommentTok{# (8)}
\CommentTok{#> foo(a = x + y, b = y + z)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: The following two calls print the same, but are actually different:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(1:10)}
\NormalTok{(b <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{))))}
\CommentTok{#> mean(1:10)}
\KeywordTok{identical}\NormalTok{(a, b)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

What's the difference? Which one is more natural?

\textbf{{A}}: It's easiest to see the difference with \texttt{lobstr::ast()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#> o-mean }
\CommentTok{#> \textbackslash{}-o-`:` }
\CommentTok{#>   +-1 }
\CommentTok{#>   \textbackslash{}-10}
\NormalTok{lobstr}\OperatorTok{::}\KeywordTok{ast}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\OperatorTok{!!}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> o-mean }
\CommentTok{#> \textbackslash{}-<inline integer>}
\end{Highlighting}
\end{Shaded}

In the expression \texttt{mean(!!(1:10))} the call \texttt{1:10} is evaluated to an integer vector, while still being a call object in \texttt{mean(1:10)}.

The first version (\texttt{mean(1:10)}) seems more natural. It captures lazy evaluation, with a promise that is evaluated when the function is called. The second version (\texttt{mean(!!(1:10))}) inlines a vector directly into a call.

\stepcounter{section}

\hypertarget{dot-dot-dot-1}{%
\section{\texorpdfstring{\texttt{...} (dot-dot-dot)}{... (dot-dot-dot)}}\label{dot-dot-dot-1}}

\textbf{{Q1}}: One way to implement \texttt{exec()} is shown below. Describe how it works. What are the key ideas?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, ..., }\DataTypeTok{.env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{list2}\NormalTok{(...)}
  \KeywordTok{do.call}\NormalTok{(f, args, }\DataTypeTok{envir =}\NormalTok{ .env)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{exec()} takes a function (\texttt{f}), its arguments (\texttt{...}) and an environment (\texttt{.env}) as input. This allows to construct a call from \texttt{f} and \texttt{...} and evaluate this call in the supplied environment. As the \texttt{...} argument is handled via \texttt{list2()}, \texttt{exec()} supports tidy dots (quasiquotation), which means that arguments and names (on the left-hand side of \texttt{:=}) can be unquoted via \texttt{!!} and \texttt{!!!}.

\textbf{{Q2}}: Carefully read the source code for \texttt{interaction()}, \texttt{expand.grid()}, and \texttt{par()}. Compare and contrast the techniques they use for switching between dots and list behaviour.

\textbf{{A}}: All three functions capture the dots via \texttt{args\ \textless{}-\ list(...)}.

\texttt{interaction()} computes factor interactions between the captured input factors by iterating over the \texttt{args}. When a list is provided this is detected via \texttt{length(args)\ ==\ 1\ \&\&\ is.list(args{[}{[}1{]}{]})} and one level of the list is stripped through \texttt{args\ \textless{}-\ args{[}{[}1{]}{]}}. The rest of the function's code doesn't differentiate further between list and dots behaviour.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Both calls create the same output}
\KeywordTok{interaction}\NormalTok{(     }\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{), }\DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{))   }\CommentTok{# dots}
\CommentTok{#> [1] a.e b.f c.e d.f}
\CommentTok{#> Levels: a.e b.e c.e d.e a.f b.f c.f d.f}
\KeywordTok{interaction}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{), }\DataTypeTok{b =} \KeywordTok{c}\NormalTok{(}\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{)))  }\CommentTok{# list}
\CommentTok{#> [1] a.e b.f c.e d.f}
\CommentTok{#> Levels: a.e b.e c.e d.e a.f b.f c.f d.f}
\end{Highlighting}
\end{Shaded}

\texttt{expand.grid()} uses the same strategy and also assigns \texttt{args\ \textless{}-\ args{[}{[}1{]}{]}} in case of \texttt{length(args)\ ==\ 1\ \&\&\ is.list(args{[}{[}1{]}{]})}.

\texttt{par()} does the most pre-processing to ensure a valid structure of the \texttt{args} argument. When no dots are provided (\texttt{!length(args)}) it creates a list of arguments from an internal character vector (partly depending on its \texttt{no.readonly} argument). Further, given that all elements of \texttt{args} are character vectors (\texttt{all(unlist(lapply(args,\ is.character)))}), \texttt{args} is turned into a list via \texttt{as.list(unlist(args))} (this flattens nested lists). Similar to the other functions, one level of \texttt{args} gets stripped via \texttt{args\ \textless{}-\ args{[}{[}1L{]}{]}}, when \texttt{args} is of length one and its first element is a list.

\textbf{{Q3}}: Explain the problem with this definition of \texttt{set\_attr()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  attr <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{list2}\NormalTok{(...)}
  \KeywordTok{attributes}\NormalTok{(x) <-}\StringTok{ }\NormalTok{attr}
\NormalTok{  x}
\NormalTok{\}}
\KeywordTok{set_attr}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{)}
\CommentTok{#> Error in attributes(x) <- attr: attributes must be named}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{set\_attr()} expects an object named \texttt{x} and its attributes, supplied via the dots. Unfortunately, this prohibits us to provide attributes named \texttt{x} as these would collide with the argument name of our object. Even omitting the object's argument name doesn't help in this case --- as can be seen in the example where the object is consequently treated as an unnamed attribute.

However, we may name the first argument \texttt{.x}, which seems clearer and less likely to invoke errors. In this case \texttt{1:10} will get the (named) attribute \texttt{x\ =\ 10} assigned:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.x, ...) \{}
\NormalTok{  attr <-}\StringTok{ }\NormalTok{rlang}\OperatorTok{::}\KeywordTok{list2}\NormalTok{(...)}
  
  \KeywordTok{attributes}\NormalTok{(.x) <-}\StringTok{ }\NormalTok{attr}
\NormalTok{  .x}
\NormalTok{\}}

\KeywordTok{set_attr}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{x =} \DecValTok{10}\NormalTok{)}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\CommentTok{#> attr(,"x")}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{expr-case-studies}{%
\section{Case studies}\label{expr-case-studies}}

\textbf{{Q1}}: In the linear-model example, we could replace the \texttt{expr()} in \texttt{reduce(summands,\ \textasciitilde{}\ expr(!!.x\ +\ !!.y))} with \texttt{call2()}: \texttt{reduce(summands,\ call2,\ "+")}. Compare and contrast the two approaches. Which do you think is easier to read?

\textbf{{A}}: We would consider the first version to be more readable. There seems to be a little more boilerplate code at first, but the unquoting syntax is very readable. Overall, the whole expression seems more explicit and less complex.

\textbf{{Q2}}: Re-implement the Box-Cox transform defined below using unquoting and \texttt{new\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bc <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda) \{}
  \ControlFlowTok{if}\NormalTok{ (lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{log}\NormalTok{(x)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{function}\NormalTok{(x) (x }\OperatorTok{^}\StringTok{ }\NormalTok{lambda }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{lambda}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Here \texttt{new\_function()} allows us to create a function factory using tidy evaluation.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bc2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(lambda) \{}
\NormalTok{  lambda <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(lambda)}
  
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!!}\NormalTok{lambda }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \KeywordTok{new_function}\NormalTok{(}\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ), }\KeywordTok{expr}\NormalTok{(}\KeywordTok{log}\NormalTok{(x)))}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{new_function}\NormalTok{(}\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ ), }\KeywordTok{expr}\NormalTok{((x }\OperatorTok{^}\StringTok{ }\NormalTok{(}\OperatorTok{!!}\NormalTok{lambda) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{/}\StringTok{ }\OperatorTok{!!}\NormalTok{lambda))}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{bc2}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\CommentTok{#> function (x) }
\CommentTok{#> log(x)}
\CommentTok{#> <environment: 0x00000000194ecbf0>}
\KeywordTok{bc2}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> function (x) }
\CommentTok{#> (x^2 - 1)/2}
\CommentTok{#> <environment: 0x0000000019546e50>}
\KeywordTok{bc2}\NormalTok{(}\DecValTok{2}\NormalTok{)(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 1.5}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Re-implement the simple \texttt{compose()} defined below using quasiquotation and \texttt{new\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compose <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, g) \{}
  \ControlFlowTok{function}\NormalTok{(...) }\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(...))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The implementation is fairly straightforward, even though a lot of parentheses are required:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compose2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(f, g) \{}
\NormalTok{  f <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(f)}
\NormalTok{  g <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(g)}
  
  \KeywordTok{new_function}\NormalTok{(}\KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ), }\KeywordTok{expr}\NormalTok{((}\OperatorTok{!!}\NormalTok{f)((}\OperatorTok{!!}\NormalTok{g)(...))))}
\NormalTok{\}}

\KeywordTok{compose}\NormalTok{(sin, cos)}
\CommentTok{#> function(...) f(g(...))}
\CommentTok{#> <environment: 0x0000000015a953d8>}
\KeywordTok{compose}\NormalTok{(sin, cos)(pi)}
\CommentTok{#> [1] -0.841}

\KeywordTok{compose2}\NormalTok{(sin, cos)}
\CommentTok{#> function (...) }
\CommentTok{#> sin(cos(...))}
\CommentTok{#> <environment: 0x00000000151ea5d8>}
\KeywordTok{compose2}\NormalTok{(sin, cos)(pi)}
\CommentTok{#> [1] -0.841}
\end{Highlighting}
\end{Shaded}

\hypertarget{evaluation}{%
\chapter{Evaluation}\label{evaluation}}

\hypertarget{prerequisites-11}{%
\section*{Prerequisites}\label{prerequisites-11}}


On our journey through R's metaprogramming, we continue to use the functions from the \texttt{\{rlang\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{evaluation-basics}{%
\section{Evaluation basics}\label{evaluation-basics}}

\textbf{{Q1}}: Carefully read the documentation for \texttt{source()}. What environment does it use by default? What if you supply \texttt{local\ =\ TRUE}? How do you provide a custom environment?

\textbf{{A}}: By default, \texttt{source()} uses the global environment (\texttt{local\ =\ FALSE}). A specific evaluation environment may be chosen, by passing it explicitly to the \texttt{local} argument. To use current environment (i.e.~the calling environment of \texttt{source()}) set \texttt{local\ =\ TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a temporary, sourcable R script that prints x}
\NormalTok{tmp_file <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{writeLines}\NormalTok{(}\StringTok{"print(x)"}\NormalTok{, tmp_file)}

\CommentTok{# Set `x` globally}
\NormalTok{x <-}\StringTok{ "global environment"}
\NormalTok{env2 <-}\StringTok{ }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \StringTok{"specified environment"}\NormalTok{)}

\NormalTok{locate_evaluation <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(file, local) \{}
\NormalTok{  x <-}\StringTok{ "local environment"}
  \KeywordTok{source}\NormalTok{(file, }\DataTypeTok{local =}\NormalTok{ local)}
\NormalTok{\}}

\CommentTok{# Where will source() evaluate the code?}
\KeywordTok{locate_evaluation}\NormalTok{(tmp_file, }\DataTypeTok{local =} \OtherTok{FALSE}\NormalTok{)  }\CommentTok{# default}
\CommentTok{#> [1] "global environment"}
\KeywordTok{locate_evaluation}\NormalTok{(tmp_file, }\DataTypeTok{local =}\NormalTok{ env2)}
\CommentTok{#> [1] "specified environment"}
\KeywordTok{locate_evaluation}\NormalTok{(tmp_file, }\DataTypeTok{local =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] "local environment"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Predict the results of the following lines of code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{))))))        }\CommentTok{# (1)}
\KeywordTok{eval}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))  }\CommentTok{# (2)}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))  }\CommentTok{# (3)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let's look at a quote from the \href{http://adv-r.had.co.nz/Computing-on-the-language.html\#subset}{first edition of Advanced R}:

\begin{quote}
``\texttt{expr()} and \texttt{eval()} are opposites. {[}\ldots{]} each \texttt{eval()} peels off one layer of \texttt{expr()}'s''.
\end{quote}

In general, \texttt{eval(expr(x))} evaluates to \texttt{x}. Therefore, (1) evaluates to \(2 + 2 = 4\). Adding another \texttt{eval()} doesn't have impact here. So, also (2) evaluates to \texttt{4}. However, when wrapping (1) into \texttt{expr()} the whole expression will be quoted.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{))))))        }\CommentTok{# (1)}
\CommentTok{#> [1] 4}
\KeywordTok{eval}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))  }\CommentTok{# (2)}
\CommentTok{#> [1] 4}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2}\NormalTok{)))))))  }\CommentTok{# (3)}
\CommentTok{#> eval(expr(eval(expr(eval(expr(2 + 2))))))}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Fill in the function bodies below to re-implement \texttt{get()} using \texttt{sym()} and \texttt{eval()}, and \texttt{assign()} using \texttt{sym()}, \texttt{expr()}, and \texttt{eval()}. Don't worry about the multiple ways of choosing an environment that \texttt{get()} and \texttt{assign()} support; assume that the user supplies it explicitly.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# name is a string}
\NormalTok{get2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, env) \{\}}
\NormalTok{assign2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, value, env) \{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: We reimplement these two functions using tidy evaluation. We turn the string \texttt{name} into a symbol, then evaluate it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{get2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  name_sym <-}\StringTok{ }\KeywordTok{sym}\NormalTok{(name)}
  \KeywordTok{eval}\NormalTok{(name_sym, env)}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\KeywordTok{get2}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

To build the correct expression for the value assignment, we unquote using \texttt{!!}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{assign2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, value, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  name_sym <-}\StringTok{ }\KeywordTok{sym}\NormalTok{(name)}
\NormalTok{  assign_expr <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{name_sym <-}\StringTok{ }\OperatorTok{!!}\NormalTok{value)}
  \KeywordTok{eval}\NormalTok{(assign_expr, env)}
\NormalTok{\}}

\KeywordTok{assign2}\NormalTok{(}\StringTok{"x"}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{x}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Modify \texttt{source2()} so it returns the result of \emph{every} expression, not just the last one. Can you eliminate the for loop?

\textbf{{A}}: The code for \texttt{source2()} was given in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{source2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  file <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{readLines}\NormalTok{(path, }\DataTypeTok{warn =} \OtherTok{FALSE}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  exprs <-}\StringTok{ }\KeywordTok{parse_exprs}\NormalTok{(file)}

\NormalTok{  res <-}\StringTok{ }\OtherTok{NULL}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(exprs)) \{}
\NormalTok{    res <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(exprs[[i]], env)}
\NormalTok{  \}}

  \KeywordTok{invisible}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In order to highlight the modifications in our new \texttt{source2()} function, we've preserved the differing code from the former \texttt{source2()} in a comment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{source2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(path, }\DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  file <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{readLines}\NormalTok{(path, }\DataTypeTok{warn =} \OtherTok{FALSE}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  exprs <-}\StringTok{ }\KeywordTok{parse_exprs}\NormalTok{(file)}
  
  \CommentTok{# res <- NULL}
  \CommentTok{# for (i in seq_along(exprs)) \{}
  \CommentTok{#   res[[i]] <- eval(exprs[[i]], env)}
  \CommentTok{# \}}
  
\NormalTok{  res <-}\StringTok{ }\NormalTok{purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(exprs, eval, env)}
  
  \KeywordTok{invisible}\NormalTok{(res)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's create a file and test \texttt{source2()}. Keep in mind that \texttt{\textless{}-} returns invisibly.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tmp_file <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
\KeywordTok{writeLines}\NormalTok{(}
  \StringTok{"x <- 1}
\StringTok{       x}
\StringTok{       y <- 2}
\StringTok{       y  # some comment"}\NormalTok{,}
\NormalTok{  tmp_file}
\NormalTok{)}

\NormalTok{(}\KeywordTok{source2}\NormalTok{(tmp_file))}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] 2}
\CommentTok{#> }
\CommentTok{#> [[4]]}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: We can make \texttt{base::local()} slightly easier to understand by spreading it over multiple lines:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{local3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{envir =} \KeywordTok{new.env}\NormalTok{()) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(expr), envir))}
  \KeywordTok{eval}\NormalTok{(call, }\DataTypeTok{envir =} \KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Explain how \texttt{local()} works in words. (Hint: you might want to \texttt{print(call)} to help understand what \texttt{substitute()} is doing, and read the documentation to remind yourself what environment \texttt{new.env()} will inherit from.)

\textbf{{A}}: Let's follow the advice and add \texttt{print(call)} inside of \texttt{local3()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{local3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr, }\DataTypeTok{envir =} \KeywordTok{new.env}\NormalTok{()) \{}
\NormalTok{  call <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(expr), envir))}
  \KeywordTok{print}\NormalTok{(call)}
  \KeywordTok{eval}\NormalTok{(call, }\DataTypeTok{envir =} \KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The first line generates a call to \texttt{eval()}, because \texttt{substitute()} operates in the current evaluation argument. However, this doesn't matter here, as both, \texttt{expr} and \texttt{envir} are promises and therefore ``the expression slots of the promises replace the symbols'', from \texttt{?substitute}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{local3}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\})}
\CommentTok{#> eval(quote(\{}
\CommentTok{#>     x <- 10}
\CommentTok{#>     x * 2}
\CommentTok{#> \}), new.env())}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

Next, \texttt{call} will be evaluated in the caller environment (aka the parent frame). Given that \texttt{call} contains another call \texttt{eval()} why does this matter? The answer is subtle: this outer environment determines where the bindings for \texttt{eval}, \texttt{quote}, and \texttt{new.env} are found.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{10}
\NormalTok{  x }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\NormalTok{\}), }\KeywordTok{new.env}\NormalTok{())}
\CommentTok{#> [1] 20}
\KeywordTok{exists}\NormalTok{(}\StringTok{"x"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{quosures}{%
\section{Quosures}\label{quosures}}

\textbf{{Q1}}: Predict what evaluating each of the following quosures will return if evaluated.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q1 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{))}
\NormalTok{q1}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x}
\CommentTok{#> env:  000000001914AAC8}

\NormalTok{q2 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{q1), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{))}
\NormalTok{q2}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + (^x)}
\CommentTok{#> env:  00000000197F8990}

\NormalTok{q3 <-}\StringTok{ }\KeywordTok{new_quosure}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\OperatorTok{!!}\NormalTok{q2), }\KeywordTok{env}\NormalTok{(}\DataTypeTok{x =} \DecValTok{100}\NormalTok{))}
\NormalTok{q3}
\CommentTok{#> <quosure>}
\CommentTok{#> expr: ^x + (^x + (^x))}
\CommentTok{#> env:  00000000199B2210}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Each quosure is evaluated in its own environment, so \texttt{x} is bound to a different value for each time. This leads us to:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{eval_tidy}\NormalTok{(q1)}
\CommentTok{#> [1] 1}
\KeywordTok{eval_tidy}\NormalTok{(q2)}
\CommentTok{#> [1] 11}
\KeywordTok{eval_tidy}\NormalTok{(q3)}
\CommentTok{#> [1] 111}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Write an \texttt{enenv()} function that captures the environment associated with an argument. (Hint: this should only require two function calls.)

\textbf{{A}}: A quosure captures both the expression and the environment. From a quosure, we can access the environment with the help of \texttt{get\_env()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{enenv <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{get_env}\NormalTok{(}\KeywordTok{enquo}\NormalTok{(x))}
\NormalTok{\}}

\CommentTok{# Test}
\KeywordTok{enenv}\NormalTok{(x)}
\CommentTok{#> <environment: R_GlobalEnv>}

\CommentTok{# Test if it also works within functions}
\NormalTok{capture_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{enenv}\NormalTok{(x)}
\NormalTok{\}}
\KeywordTok{capture_env}\NormalTok{(x)}
\CommentTok{#> <environment: 0x000000001960b760>}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-masks}{%
\section{Data masks}\label{data-masks}}

\textbf{{Q1}}: Why did I use a for loop in \texttt{transform2()} instead of \texttt{map()}? Consider \texttt{transform2(df,\ x\ =\ x\ *\ 2,\ x\ =\ x\ *\ 2)}.

\textbf{{A}}: \texttt{transform2()} was defined in Advanced R as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{transform2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.data, ...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)}

  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(dots)) \{}
\NormalTok{    name <-}\StringTok{ }\KeywordTok{names}\NormalTok{(dots)[[i]]}
\NormalTok{    dot <-}\StringTok{ }\NormalTok{dots[[i]]}

\NormalTok{    .data[[name]] <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(dot, .data)}
\NormalTok{  \}}

\NormalTok{  .data}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

A for loop applies the processing steps regarding \texttt{.data} iteratively. This includes updating \texttt{.data} and reusing the same variable names. This makes it possible to apply transformations sequentially, so that subsequent transformations can refer to columns that were just created.

\textbf{{Q2}}: Here's an alternative implementation of \texttt{subset2()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, rows) \{}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(rows)}
  \KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{expr}\NormalTok{(data[}\OperatorTok{!!}\NormalTok{rows, , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{]), }\DataTypeTok{data =}\NormalTok{ data)}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\KeywordTok{subset3}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Compare and contrast \texttt{subset3()} to \texttt{subset2()}. What are its advantages and disadvantages?

\textbf{{A}}: Let's take a closer look at \texttt{subset2()} first:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(data, rows) \{}
\NormalTok{  rows <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(rows)}
\NormalTok{  rows_val <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(rows, data)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.logical}\NormalTok{(rows_val))}
  
\NormalTok{  data[rows_val, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{subset2()} provides an additional logical check, which is missing from \texttt{subset3()}. Here, \texttt{rows} is evaluated in the context of \texttt{data}, which results in a logical vector. Afterwards only \texttt{{[}} needs to be used for subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# subset2() evaluation}
\NormalTok{(rows_val <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{quo}\NormalTok{(x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{), df))}
\CommentTok{#> [1]  TRUE FALSE FALSE}
\NormalTok{df[rows_val, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\CommentTok{#>   x}
\CommentTok{#> 1 1}
\end{Highlighting}
\end{Shaded}

With \texttt{subset3()} both of these steps occur in a single line (which is probably closer to what one would produce by hand). This means, that the subsetting is also evaluated in the context of the data mask.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# subset3() evaluation}
\KeywordTok{eval_tidy}\NormalTok{(}\KeywordTok{expr}\NormalTok{(df[x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{, , }\DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{]), df)}
\CommentTok{#>   x}
\CommentTok{#> 1 1}
\end{Highlighting}
\end{Shaded}

This is shorter (but probably also less readable) because the evaluation and the subsetting take place in the same expression. However, it may introduce unwanted errors, if the data mask contains an element named ``data'', as the objects from the data mask take precedence over arguments of the function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{data =} \DecValTok{1}\NormalTok{)}
\KeywordTok{subset2}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#>   x data}
\CommentTok{#> 1 1    1}
\KeywordTok{subset3}\NormalTok{(df, x }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#> Error in data[~x == 1, , drop = FALSE]: incorrect number of}
\CommentTok{#> dimensions}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: The following function implements the basics of \texttt{dplyr::arrange()}. Annotate each line with a comment explaining what it does. Can you explain why \texttt{!!.na.last} is strictly correct, but omitting the \texttt{!!} is unlikely to cause problems?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arrange2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.df, ..., }\DataTypeTok{.na.last =} \OtherTok{TRUE}\NormalTok{) \{}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)}
  
\NormalTok{  order_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{order}\NormalTok{(}\OperatorTok{!!!}\NormalTok{args, }\DataTypeTok{na.last =} \OperatorTok{!!}\NormalTok{.na.last))}
  
\NormalTok{  ord <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(order_call, .df)}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(ord) }\OperatorTok{==}\StringTok{ }\KeywordTok{nrow}\NormalTok{(.df))}
  
\NormalTok{  .df[ord, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: \texttt{arrange2()} basically reorders a data frame by one or more of its variables. As \texttt{arrange2()} allows to provide the variables as expressions (via \texttt{...}), these need to be quoted first. Afterwards they are used to build up an \texttt{order()} call, which is then evaluated in the context of the data frame. Finally, the data frame is reordered via integer subsetting. Let's take a closer look at the source code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{arrange2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.df, ..., }\DataTypeTok{.na.last =} \OtherTok{TRUE}\NormalTok{) \{}
  \CommentTok{# Capture and quote arguments, which determine the order}
\NormalTok{  args <-}\StringTok{ }\KeywordTok{enquos}\NormalTok{(...)  }
  
  \CommentTok{# `!!!`: unquote-splice arguments into order()}
  \CommentTok{# `!!.na.last`: pass option for treatment of NAs to order()}
  \CommentTok{# return expression-object}
\NormalTok{  order_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{order}\NormalTok{(}\OperatorTok{!!!}\NormalTok{args, }\DataTypeTok{na.last =} \OperatorTok{!!}\NormalTok{.na.last))}
  
  \CommentTok{# Evaluate order_call within .df}
\NormalTok{  ord <-}\StringTok{ }\KeywordTok{eval_tidy}\NormalTok{(order_call, .df)    }
  \CommentTok{# Ensure that no rows are dropped}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(ord) }\OperatorTok{==}\StringTok{ }\KeywordTok{nrow}\NormalTok{(.df))  }
  
  \CommentTok{# Reorder rows via integer subsetting}
\NormalTok{  .df[ord, , drop =}\StringTok{ }\OtherTok{FALSE}\NormalTok{]  }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

By using \texttt{!!.na.last} the \texttt{.na.last} argument is unquoted when the \texttt{order()} call is built. This way, the \texttt{na.last} argument is already correctly specified (typically \texttt{TRUE}, \texttt{FALSE} or \texttt{NA}).

Without the unquoting, the expression would read \texttt{na.last\ =\ .na.last} and the value for \texttt{.na.last} would still need to be looked up and found. Because these computations take place inside of the function's execution environment (which contains \texttt{.na.last}), this is unlikely to cause problems.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# The effect of unquoting .na.last}
\NormalTok{.na.last <-}\StringTok{ }\OtherTok{FALSE}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{order}\NormalTok{(..., }\DataTypeTok{na.last =} \OperatorTok{!!}\NormalTok{.na.last))}
\CommentTok{#> order(..., na.last = FALSE)}
\KeywordTok{expr}\NormalTok{(}\KeywordTok{order}\NormalTok{(..., }\DataTypeTok{na.last =}\NormalTok{ .na.last))}
\CommentTok{#> order(..., na.last = .na.last)}
\end{Highlighting}
\end{Shaded}

\hypertarget{using-tidy-evaluation}{%
\section{Using tidy evaluation}\label{using-tidy-evaluation}}

\textbf{{Q1}}: I've included an alternative implementation of \texttt{threshold\_var()} below. What makes it different to the approach I used above? What makes it harder?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_var2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{ensym}\NormalTok{(var)}
  
  \KeywordTok{subset2}\NormalTok{(df, }\StringTok{`}\DataTypeTok{$}\StringTok{`}\NormalTok{(.data, }\OperatorTok{!!}\NormalTok{var) }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: Let's compare this approach to the original implementation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{threshold_var <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(df, var, val) \{}
\NormalTok{  var <-}\StringTok{ }\KeywordTok{as_string}\NormalTok{(}\KeywordTok{ensym}\NormalTok{(var))}
  \KeywordTok{subset2}\NormalTok{(df, .data[[var]] }\OperatorTok{>=}\StringTok{ }\OperatorTok{!!}\NormalTok{val)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can see that \texttt{threshold\_var2()} no longer coerces the symbol to a string. Therefore \texttt{\$} instead of \texttt{{[}{[}} can be used for subsetting. Initially we suspected partial matching would be introduced by \texttt{\$}, but \texttt{.data} deliberately avoids this problem.

The prefix call to \texttt{\$()} is less common than infix-subsetting using \texttt{{[}{[}}, but ultimately both functions behave the same.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\KeywordTok{threshold_var}\NormalTok{(df, x, }\DecValTok{8}\NormalTok{)}
\CommentTok{#>     x}
\CommentTok{#> 8   8}
\CommentTok{#> 9   9}
\CommentTok{#> 10 10}
\KeywordTok{threshold_var2}\NormalTok{(df, x, }\DecValTok{8}\NormalTok{)}
\CommentTok{#>     x}
\CommentTok{#> 8   8}
\CommentTok{#> 9   9}
\CommentTok{#> 10 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{base-evaluation}{%
\section{Base evaluation}\label{base-evaluation}}

\textbf{{Q1}}: Why does this function fail?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm3a <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ data))}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{lm3a}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> Error in model.frame.default(formula = mpg ~ disp, data = data,}
\CommentTok{#> drop.unused.levels = TRUE): 'data' must be a data.frame,}
\CommentTok{#> environment, or list}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In this function, \texttt{lm\_call} is evaluated in the caller environment, which happens to be the global environment. In this environment, the name \texttt{data} is bound to \texttt{utils::data}. To fix the error, we can either set the evaluation environment to the function's execution environment or unquote the \texttt{data} argument when building the call to \texttt{lm()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Change evaluation environment}
\NormalTok{lm3b <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ data))}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{current_env}\NormalTok{())}
\NormalTok{\}}

\KeywordTok{lm3b}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> lm(formula = mpg ~ disp, data = data)}
\KeywordTok{lm3b}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, data)}\OperatorTok{$}\NormalTok{call  }\CommentTok{#reproduces original error}
\CommentTok{#> Error in model.frame.default(formula = mpg ~ disp, data = data,}
\CommentTok{#> drop.unused.levels = TRUE): 'data' must be a data.frame,}
\CommentTok{#> environment, or list}
\end{Highlighting}
\end{Shaded}

When we want to unquote an argument within a function, we first need to capture the user-input (by \texttt{enexpr()}).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Unquoting data-argument}
\NormalTok{lm3c <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(formula, data) \{}
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
\NormalTok{  data_quo <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{data_quo))}
  \KeywordTok{eval}\NormalTok{(lm_call, }\KeywordTok{caller_env}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{lm3c}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, mtcars)}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> lm(formula = mpg ~ disp, data = mtcars)}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: When model building, typically the response and data are relatively constant while you rapidly experiment with different predictors. Write a small wrapper that allows you to reduce duplication in the code below.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp), }\DataTypeTok{data =}\NormalTok{ mtcars)}
\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{disp }\OperatorTok{*}\StringTok{ }\NormalTok{cyl, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: In our wrapper \texttt{lm\_wrap()}, we provide \texttt{mpg} and \texttt{mtcars} as default response and data. This seems to give us a good mix of usability and flexibility.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lm_wrap <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(pred, }\DataTypeTok{resp =}\NormalTok{ mpg, }\DataTypeTok{data =}\NormalTok{ mtcars, }
                    \DataTypeTok{env =} \KeywordTok{caller_env}\NormalTok{()) \{}
\NormalTok{  pred <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(pred)}
\NormalTok{  resp <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(resp)}
\NormalTok{  data <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(data)}
  
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\OperatorTok{!!}\NormalTok{resp }\OperatorTok{~}\StringTok{ }\OperatorTok{!!}\NormalTok{pred)}
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =} \OperatorTok{!!}\NormalTok{data))}
  \KeywordTok{eval}\NormalTok{(lm_call, }\DataTypeTok{envir =}\NormalTok{ env)}
\NormalTok{\}}

\CommentTok{# Test if the output looks ok}
\KeywordTok{lm_wrap}\NormalTok{(}\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp) }\OperatorTok{+}\StringTok{ }\NormalTok{disp }\OperatorTok{*}\StringTok{ }\NormalTok{cyl)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ I(1/disp) + disp * cyl, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)    I(1/disp)         disp          cyl     disp:cyl  }
\CommentTok{#>   -1.22e+00     1.85e+03     7.68e-02     1.18e+00    -9.14e-03}

\CommentTok{# Test if the result is identical to calling lm() directly}
\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{lm_wrap}\NormalTok{(}\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp) }\OperatorTok{+}\StringTok{ }\NormalTok{disp }\OperatorTok{*}\StringTok{ }\NormalTok{cyl),}
  \KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\KeywordTok{I}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\NormalTok{disp) }\OperatorTok{+}\StringTok{ }\NormalTok{disp }\OperatorTok{*}\StringTok{ }\NormalTok{cyl, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Another way to write \texttt{resample\_lm()} would be to include the resample expression \texttt{(data{[}sample(nrow(data),\ replace\ =\ TRUE),\ ,\ drop\ =\ FALSE{]})} in the data argument. Implement that approach. What are the advantages? What are the disadvantages?

\textbf{{A}}: Different versions of \texttt{resample\_lm()} were given in Advanced R. However, none of them implemented the resampling within the function argument.

Different versions of \texttt{resample\_lm()} (\texttt{resample\_lm0()}, \texttt{resample\_lm1()}, \texttt{resample\_lm2()}) were specified in Advanced R. However, in none of these versions the resampling step was implemented in any of the arguments.

This approach takes advantage of R's lazy evaluation of function arguments, by moving the resampling step into the argument definition. The user passes the data to the function, but only a permutation of this data (\texttt{resample\_data}) will be used.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resample_lm <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}
\NormalTok{  formula, data,}
  \DataTypeTok{resample_data =}\NormalTok{ data[}\KeywordTok{sample}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(data), }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{), ,}
                       \DataTypeTok{drop =} \OtherTok{FALSE}\NormalTok{],}
  \DataTypeTok{env =} \KeywordTok{current_env}\NormalTok{()) \{}
  
\NormalTok{  formula <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(formula)}
  
\NormalTok{  lm_call <-}\StringTok{ }\KeywordTok{expr}\NormalTok{(}\KeywordTok{lm}\NormalTok{(}\OperatorTok{!!}\NormalTok{formula, }\DataTypeTok{data =}\NormalTok{ resample_data))}
  \KeywordTok{expr_print}\NormalTok{(lm_call)}
  \KeywordTok{eval}\NormalTok{(lm_call, env)}
\NormalTok{\}}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{y =} \DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{3} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{round}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{), }\DecValTok{2}\NormalTok{))}
\NormalTok{(lm_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\KeywordTok{resample_lm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x, }\DataTypeTok{data =}\NormalTok{ df))}
\CommentTok{#> lm(y ~ x, data = resample_data)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = y ~ x, data = resample_data)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)            x  }
\CommentTok{#>        4.85         3.02}
\NormalTok{lm_}\DecValTok{1}\OperatorTok{$}\NormalTok{call}
\CommentTok{#> lm(formula = y ~ x, data = resample_data)}
\end{Highlighting}
\end{Shaded}

With this approach the evaluation needs to take place within the function's environment, because the resampled dataset (defined as a default argument) will only be available in the function environment.

Overall, putting an essential part of the pre-processing outside of the functions body is not common practice in R. Compared to the unquoting-implementation (\texttt{resample\_lm1()} in Advanced R), this approach captures the model-call in a more meaningful way. This approach will also lead to a new resample every time you \texttt{update()} the model.

\hypertarget{translating-r-code}{%
\chapter{Translating R code}\label{translating-r-code}}

\hypertarget{prerequisites-12}{%
\section*{Prerequisites}\label{prerequisites-12}}


In this chapter we combine R's metaprogramming and functional programming capabilities and therefore load both the \texttt{\{rlang\}} and the \texttt{\{purrr\}} package.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(rlang)}
\KeywordTok{library}\NormalTok{(purrr)}
\end{Highlighting}
\end{Shaded}

\stepcounter{section}

\hypertarget{html}{%
\section{HTML}\label{html}}

\textbf{{Q1}}: The escaping rules for \texttt{\textless{}script\textgreater{}} tags are different because they contain JavaScript, not HTML. Instead of escaping angle brackets or ampersands, you need to escape \texttt{\textless{}/script\textgreater{}} so that the tag isn't closed too early. For example, \texttt{script("\textquotesingle{}\textless{}/script\textgreater{}\textquotesingle{}")}, shouldn't generate this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script>}\StringTok{'</script>'}\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

But

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<script>}\StringTok{'<}\SpecialCharTok{\textbackslash{}/}\StringTok{script>'}\KeywordTok{</script>}
\end{Highlighting}
\end{Shaded}

Adapt the \texttt{escape()} to follow these rules when a new argument \texttt{script} is set to \texttt{TRUE}.

\textbf{{A}}: We are asked to implement a special case of escaping for the \texttt{\textless{}script\textgreater{}} tag. At first we will revisit the relevant functions provided in Advanced R and confirm that our code reliably escapes for tags like \texttt{\textless{}p\textgreater{}} and \texttt{\textless{}b\textgreater{}} but doesn't escape correctly for the \texttt{\textless{}script\textgreater{}} tag. Then we modify the \texttt{escape()} and \texttt{tag()} functions to redefine the \texttt{\textless{}script\textgreater{}} tag and confirm that all defined tags now escape correctly.

Note that the \texttt{\textless{}style\textgreater{}} tag, which contains styling information in CSS, follows the same escaping rules as the \texttt{\textless{}script\textgreater{}} tag. We therefore implement the desired escaping for the \texttt{\textless{}style\textgreater{}} tag function also.

Let's start by loading the relevant code from Advanced R first.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Escaping}
\NormalTok{html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"advr_html"}\NormalTok{)}

\NormalTok{print.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"<HTML> "}\NormalTok{, x)}
  \KeywordTok{cat}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\KeywordTok{strwrap}\NormalTok{(out), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}

\NormalTok{escape <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"escape"}\NormalTok{)}

\NormalTok{escape.character <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"&"}\NormalTok{, }\StringTok{"&amp;"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"<"}\NormalTok{, }\StringTok{"&lt;"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{">"}\NormalTok{, }\StringTok{"&gt;"}\NormalTok{, x)}
  
  \KeywordTok{html}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{escape.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}

\CommentTok{# Basic tag functions}
\NormalTok{dots_partition <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{list2}\NormalTok{(...)}
  
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{names}\NormalTok{(dots))) \{}
\NormalTok{    is_named <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\KeywordTok{length}\NormalTok{(dots))}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    is_named <-}\StringTok{ }\KeywordTok{names}\NormalTok{(dots) }\OperatorTok{!=}\StringTok{ ""}
\NormalTok{  \}}
  
  \KeywordTok{list}\NormalTok{(}
    \DataTypeTok{named =}\NormalTok{ dots[is_named],}
    \DataTypeTok{unnamed =}\NormalTok{ dots[}\OperatorTok{!}\NormalTok{is_named]}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# html_attributes() function from the GitHub repository of Advanced R}
\CommentTok{# https://github.com/hadley/adv-r/blob/master/dsl-html-attributes.r}

\NormalTok{html_attributes <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(list) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(list) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{return}\NormalTok{(}\StringTok{""}\NormalTok{)}
  
\NormalTok{  attr <-}\StringTok{ }\KeywordTok{map2_chr}\NormalTok{(}\KeywordTok{names}\NormalTok{(list), list, html_attribute)}
  \KeywordTok{paste0}\NormalTok{(}\StringTok{" "}\NormalTok{, }\KeywordTok{unlist}\NormalTok{(attr), }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}

\NormalTok{html_attribute <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(name, }\DataTypeTok{value =} \OtherTok{NULL}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(value) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\KeywordTok{return}\NormalTok{(name) }\CommentTok{# for attributes with no value}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(value) }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{stop}\NormalTok{(}\StringTok{"`value` must be NULL or length 1"}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.logical}\NormalTok{(value)) \{}
    \CommentTok{# Convert T and F to true and false}
\NormalTok{    value <-}\StringTok{ }\KeywordTok{tolower}\NormalTok{(value)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    value <-}\StringTok{ }\KeywordTok{escape_attr}\NormalTok{(value)}
\NormalTok{  \}}
  \KeywordTok{paste0}\NormalTok{(name, }\StringTok{"='"}\NormalTok{, value, }\StringTok{"'"}\NormalTok{)}
\NormalTok{\}}

\NormalTok{escape_attr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{escape.character}\NormalTok{(x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}'}\StringTok{"}\NormalTok{, }\StringTok{'&#39;'}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}"}\StringTok{"}\NormalTok{, }\StringTok{'&quot;'}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}r}\StringTok{"}\NormalTok{, }\StringTok{'&#13;'}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\StringTok{'&#10;'}\NormalTok{, x)}
\NormalTok{  x}
\NormalTok{\}}

\CommentTok{# Tag functions}
\NormalTok{tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape)}
      
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{">"}\NormalTok{,}
        \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
\NormalTok{      ))}
\NormalTok{    \}),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This code escapes the \texttt{\textless{}p\textgreater{}} and \texttt{\textless{}b\textgreater{}} tags correctly, but doesn't achieve the desired behaviour for the \texttt{\textless{}script\textgreater{}} tag yet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"p"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"b"}\NormalTok{)}

\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{p}\NormalTok{(}\StringTok{"&"}\NormalTok{,}\StringTok{"and <"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"& > will be escaped"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{as.character}\NormalTok{(),}
  \StringTok{"<p>&amp;and &lt;<b>&amp; &gt; will be escaped</b></p>"}
\NormalTok{)}
\CommentTok{#> [1] TRUE}

\NormalTok{script <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"script"}\NormalTok{)}

\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{script}\NormalTok{(}\StringTok{"Don't escape &, <, > - escape </script> and </style>"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{as.character}\NormalTok{(),}
  \KeywordTok{paste}\NormalTok{(}\StringTok{"<script>Don't escape &, <, >"}\NormalTok{,}
        \StringTok{"- escape <}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/script> and <}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/style></script>"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

We implement the desired change and add the optional argument \texttt{script} to the \texttt{escape()} and the \texttt{tag()} functions (default: \texttt{script\ =\ FALSE}). The argument has to be added for all methods of the \texttt{escape()} generic.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{escape <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{script =} \OtherTok{FALSE}\NormalTok{) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"escape"}\NormalTok{)}

\NormalTok{escape.character <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{script =} \OtherTok{FALSE}\NormalTok{) \{}
  
  \ControlFlowTok{if}\NormalTok{ (script) \{}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"</script>"}\NormalTok{, }\StringTok{"<}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/script>"}\NormalTok{, x, }\DataTypeTok{fixed =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"</style>"}\NormalTok{,  }\StringTok{"<}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/style>"}\NormalTok{,  x, }\DataTypeTok{fixed =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"&"}\NormalTok{, }\StringTok{"&amp;"}\NormalTok{, x)}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"<"}\NormalTok{, }\StringTok{"&lt;"}\NormalTok{, x)}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{">"}\NormalTok{, }\StringTok{"&gt;"}\NormalTok{, x)}
\NormalTok{  \}}

  \KeywordTok{html}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{escape.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, }\DataTypeTok{script =} \OtherTok{FALSE}\NormalTok{) x}


\NormalTok{tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, }\DataTypeTok{script =} \OtherTok{FALSE}\NormalTok{) \{}
  
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape, }\DataTypeTok{script =} \OperatorTok{!!}\NormalTok{script)}
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{">"}\NormalTok{,}
        \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
\NormalTok{      ))}
\NormalTok{    \}),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Finally, we create new \texttt{\textless{}p\textgreater{}}, \texttt{\textless{}b\textgreater{}} and \texttt{\textless{}script\textgreater{}} tag functions, which now pass their escaping tests.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"p"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"b"}\NormalTok{)}

\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{p}\NormalTok{(}\StringTok{"&"}\NormalTok{,}\StringTok{"and <"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"& > will be escaped"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{as.character}\NormalTok{(),}
  \StringTok{"<p>&amp;and &lt;<b>&amp; &gt; will be escaped</b></p>"}
\NormalTok{)}
\CommentTok{#> [1] TRUE}

\NormalTok{script <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"script"}\NormalTok{, }\DataTypeTok{script =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{style  <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"style"}\NormalTok{ , }\DataTypeTok{script =} \OtherTok{TRUE}\NormalTok{)}

\KeywordTok{identical}\NormalTok{(}
  \KeywordTok{script}\NormalTok{(}\StringTok{"Don't escape &, <, > - escape </script> and </style>"}\NormalTok{) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{as.character}\NormalTok{(),}
  \KeywordTok{paste}\NormalTok{(}\StringTok{"<script>Don't escape &, <, >"}\NormalTok{,}
        \StringTok{"- escape <}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/script> and <}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{/style></script>"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> [1] TRUE}

\KeywordTok{script}\NormalTok{(}\StringTok{"Don't escape &, <, > - escape </script> and </style>"}\NormalTok{)}
\CommentTok{#> <HTML> <script>Don't escape &, <, > - escape <\textbackslash{}/script> and}
\CommentTok{#> <\textbackslash{}/style></script>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: The use of \texttt{...} for all functions has some big downsides. There's no input validation and there will be little information in the documentation or autocomplete about how they are used in the function. Create a new function that, when given a named list of tags and their attribute names (like below), creates tag functions with named arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"href"}\NormalTok{),}
  \DataTypeTok{img =} \KeywordTok{c}\NormalTok{(}\StringTok{"src"}\NormalTok{, }\StringTok{"width"}\NormalTok{, }\StringTok{"height"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

All tags should get \texttt{class} and \texttt{id} attributes.

\textbf{{A}}: This exercise requires a function factory: The named list of attribute names will be extended (by \texttt{class} and \texttt{id}) and mapped to function arguments. These will default to \texttt{NULL}, so that the user isn't forced to provide them.

When creating the tag functions itself we use \texttt{check\_dots\_unnamed()} from the \texttt{\{ellipsis\}} package to ensure named arguments correspond to the expected values (and are not created by some spelling mistake). After that we follow the logic from the \texttt{tag()} function factory above.

To keep the focus on the key ideas, we ignore special cases like \texttt{\textless{}script\textgreater{}}, \texttt{\textless{}style\textgreater{}} and void tags in this solution (even if this leads to an incorrect tag function for the \texttt{\textless{}img\textgreater{}} tag).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag_factory <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag, tag_attrs) \{}
\NormalTok{  attrs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"class"}\NormalTok{, }\StringTok{"id"}\NormalTok{, tag_attrs)}
  
\NormalTok{  attr_args <-}\StringTok{ }\KeywordTok{set_names}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\OtherTok{NULL}\NormalTok{), }\KeywordTok{length}\NormalTok{(attrs)), attrs)}
\NormalTok{  attr_list <-}\StringTok{ }\KeywordTok{call2}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\OperatorTok{!!!}\KeywordTok{syms}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(attrs)))}
  
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ , }\OperatorTok{!!!}\NormalTok{attr_args),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      ellipsis}\OperatorTok{::}\KeywordTok{check_dots_unnamed}\NormalTok{()}
      
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(}\KeywordTok{compact}\NormalTok{(}\OperatorTok{!!}\NormalTok{attr_list))}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{compact}\NormalTok{(}\KeywordTok{list}\NormalTok{(...))}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots, escape)}
      
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{">"}\NormalTok{,}
        \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
\NormalTok{      ))}
\NormalTok{    \})}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To validate our new function factory, we modify the \texttt{with\_html()} example from Advanced R to work with our newly created \texttt{a()} and \texttt{img()} tag functions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"href"}\NormalTok{),}
  \DataTypeTok{img =} \KeywordTok{c}\NormalTok{(}\StringTok{"src"}\NormalTok{, }\StringTok{"width"}\NormalTok{, }\StringTok{"height"}\NormalTok{)}
\NormalTok{)}

\NormalTok{tags <-}\StringTok{ }\KeywordTok{map2}\NormalTok{(}\KeywordTok{names}\NormalTok{(tag_list), }\KeywordTok{unname}\NormalTok{(tag_list), tag_factory) }\OperatorTok{%>%}\StringTok{ }
\StringTok{  }\KeywordTok{set_names}\NormalTok{(}\KeywordTok{names}\NormalTok{(tag_list))}

\NormalTok{with_tags <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  code <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(code)}
  \KeywordTok{eval_tidy}\NormalTok{(code, tags)}
\NormalTok{\}}

\KeywordTok{with_tags}\NormalTok{(}
  \KeywordTok{a}\NormalTok{(}
    \KeywordTok{img}\NormalTok{(}\StringTok{"Correct me if I am wrong"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"second"}\NormalTok{),}
    \DataTypeTok{href =} \StringTok{"https://github.com/Tazinho/Advanced-R-Solutions/issues"}\NormalTok{,}
    \DataTypeTok{id =} \StringTok{"first"}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> <HTML> <a id='first'}
\CommentTok{#> href='https://github.com/Tazinho/Advanced-R-Solutions/issues'><img}
\CommentTok{#> id='second'>Correct me if I am wrong</img></a>}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Reason about the following code that calls \texttt{with\_html()} referencing objects from the environment. Will it work or fail? Why? Run the code to verify your predictions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greeting <-}\StringTok{ "Hello!"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(greeting))}

\NormalTok{p <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\StringTok{"p"}
\NormalTok{address <-}\StringTok{ "123 anywhere street"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(address))}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: First, we rerun the relevant code from Advanced R to define \texttt{with\_html()}. Note that we skip the code for void tags, as none of them appear in the code chunk from this exercise.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"a"}\NormalTok{, }\StringTok{"abbr"}\NormalTok{, }\StringTok{"address"}\NormalTok{, }\StringTok{"article"}\NormalTok{, }\StringTok{"aside"}\NormalTok{, }\StringTok{"audio"}\NormalTok{,}
  \StringTok{"b"}\NormalTok{, }\StringTok{"bdi"}\NormalTok{, }\StringTok{"bdo"}\NormalTok{, }\StringTok{"blockquote"}\NormalTok{, }\StringTok{"body"}\NormalTok{, }\StringTok{"button"}\NormalTok{, }\StringTok{"canvas"}\NormalTok{,}
  \StringTok{"caption"}\NormalTok{, }\StringTok{"cite"}\NormalTok{, }\StringTok{"code"}\NormalTok{, }\StringTok{"colgroup"}\NormalTok{, }\StringTok{"data"}\NormalTok{, }\StringTok{"datalist"}\NormalTok{,}
  \StringTok{"dd"}\NormalTok{, }\StringTok{"del"}\NormalTok{, }\StringTok{"details"}\NormalTok{, }\StringTok{"dfn"}\NormalTok{, }\StringTok{"div"}\NormalTok{, }\StringTok{"dl"}\NormalTok{, }\StringTok{"dt"}\NormalTok{, }\StringTok{"em"}\NormalTok{,}
  \StringTok{"eventsource"}\NormalTok{, }\StringTok{"fieldset"}\NormalTok{, }\StringTok{"figcaption"}\NormalTok{, }\StringTok{"figure"}\NormalTok{, }\StringTok{"footer"}\NormalTok{,}
  \StringTok{"form"}\NormalTok{, }\StringTok{"h1"}\NormalTok{, }\StringTok{"h2"}\NormalTok{, }\StringTok{"h3"}\NormalTok{, }\StringTok{"h4"}\NormalTok{, }\StringTok{"h5"}\NormalTok{, }\StringTok{"h6"}\NormalTok{, }\StringTok{"head"}\NormalTok{, }\StringTok{"header"}\NormalTok{,}
  \StringTok{"hgroup"}\NormalTok{, }\StringTok{"html"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"iframe"}\NormalTok{, }\StringTok{"ins"}\NormalTok{, }\StringTok{"kbd"}\NormalTok{, }\StringTok{"label"}\NormalTok{,}
  \StringTok{"legend"}\NormalTok{, }\StringTok{"li"}\NormalTok{, }\StringTok{"mark"}\NormalTok{, }\StringTok{"map"}\NormalTok{, }\StringTok{"menu"}\NormalTok{, }\StringTok{"meter"}\NormalTok{, }\StringTok{"nav"}\NormalTok{,}
  \StringTok{"noscript"}\NormalTok{, }\StringTok{"object"}\NormalTok{, }\StringTok{"ol"}\NormalTok{, }\StringTok{"optgroup"}\NormalTok{, }\StringTok{"option"}\NormalTok{, }\StringTok{"output"}\NormalTok{,}
  \StringTok{"p"}\NormalTok{, }\StringTok{"pre"}\NormalTok{, }\StringTok{"progress"}\NormalTok{, }\StringTok{"q"}\NormalTok{, }\StringTok{"ruby"}\NormalTok{, }\StringTok{"rp"}\NormalTok{, }\StringTok{"rt"}\NormalTok{, }\StringTok{"s"}\NormalTok{, }\StringTok{"samp"}\NormalTok{,}
  \StringTok{"script"}\NormalTok{, }\StringTok{"section"}\NormalTok{, }\StringTok{"select"}\NormalTok{, }\StringTok{"small"}\NormalTok{, }\StringTok{"span"}\NormalTok{, }\StringTok{"strong"}\NormalTok{,}
  \StringTok{"style"}\NormalTok{, }\StringTok{"sub"}\NormalTok{, }\StringTok{"summary"}\NormalTok{, }\StringTok{"sup"}\NormalTok{, }\StringTok{"table"}\NormalTok{, }\StringTok{"tbody"}\NormalTok{, }\StringTok{"td"}\NormalTok{,}
  \StringTok{"textarea"}\NormalTok{, }\StringTok{"tfoot"}\NormalTok{, }\StringTok{"th"}\NormalTok{, }\StringTok{"thead"}\NormalTok{, }\StringTok{"time"}\NormalTok{, }\StringTok{"title"}\NormalTok{, }\StringTok{"tr"}\NormalTok{,}
  \StringTok{"u"}\NormalTok{, }\StringTok{"ul"}\NormalTok{, }\StringTok{"var"}\NormalTok{, }\StringTok{"video"}
\NormalTok{)}

\NormalTok{html_tags <-}\StringTok{ }\NormalTok{tags }\OperatorTok{%>%}\StringTok{ }\KeywordTok{set_names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(tag)}

\NormalTok{with_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  code <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(code)}
  \KeywordTok{eval_tidy}\NormalTok{(code, html_tags)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, let us briefly repeat, that \texttt{with\_html()} was introduced to evaluate tag functions from within a list. Otherwise, defining some tag functions like \texttt{body()}, \texttt{source()}, \texttt{summary()} etc. within the global environment would collide with base R functions with the same name. To prevent this the DSL code wrapped in \texttt{with\_html()} is evaluated within the ``context'' of \texttt{html\_tags}, which was provided as a data mask to \texttt{eval\_tidy()}. As \texttt{?rlang::as\_data\_mask} mentions: ``Objects in the mask have precedence over objects in the environment''.

Therefore, \texttt{p()} refers to the tag function from \texttt{html\_tags} within both examples from the exercise. However, as \texttt{address} is not only a string within the global environment, but also a tag function within \texttt{html\_tags} (the \texttt{\textless{}address\textgreater{}} HTML tag may be used to provide contact information on an HTML page), \texttt{p()} operates on \texttt{address()} in the second example. This correctly leads to an error as we haven't implemented an \texttt{escape.function()} method.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greeting <-}\StringTok{ "Hello!"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(greeting))}
\CommentTok{#> <HTML> <p>Hello!</p>}

\NormalTok{p <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{() }\StringTok{"p"}
\NormalTok{address <-}\StringTok{ "123 anywhere street"}
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{p}\NormalTok{(address))}
\CommentTok{#> Error in UseMethod("escape"): no applicable method for 'escape'}
\CommentTok{#> applied to an object of class "function"}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: Currently the HTML doesn't look terribly pretty, and it's hard to see the structure. How could you adapt \texttt{tag()} to do indenting and formatting? (You may need to do some research into block and inline tags.)

\textbf{{A}}: First, let us load all relevant functions from Advanced R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{      children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape)}
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{">"}\NormalTok{,}
        \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
\NormalTok{      ))}
\NormalTok{    \}),}
    
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{void_tag <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(tag) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ), }
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed) }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
        \KeywordTok{stop}\NormalTok{(}
          \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag, }\StringTok{"> must not have unnamed arguments"}\NormalTok{),}
          \DataTypeTok{call. =} \OtherTok{FALSE}
\NormalTok{        )}
\NormalTok{      \}}
      
\NormalTok{      attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
      
      \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag), attribs, }\StringTok{" />"}\NormalTok{))}
\NormalTok{    \}),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"a"}\NormalTok{, }\StringTok{"abbr"}\NormalTok{, }\StringTok{"address"}\NormalTok{, }\StringTok{"article"}\NormalTok{, }\StringTok{"aside"}\NormalTok{, }\StringTok{"audio"}\NormalTok{, }\StringTok{"b"}\NormalTok{,}
  \StringTok{"bdi"}\NormalTok{, }\StringTok{"bdo"}\NormalTok{, }\StringTok{"blockquote"}\NormalTok{, }\StringTok{"body"}\NormalTok{, }\StringTok{"button"}\NormalTok{, }\StringTok{"canvas"}\NormalTok{,}
  \StringTok{"caption"}\NormalTok{, }\StringTok{"cite"}\NormalTok{, }\StringTok{"code"}\NormalTok{, }\StringTok{"colgroup"}\NormalTok{, }\StringTok{"data"}\NormalTok{, }\StringTok{"datalist"}\NormalTok{,}
  \StringTok{"dd"}\NormalTok{, }\StringTok{"del"}\NormalTok{, }\StringTok{"details"}\NormalTok{, }\StringTok{"dfn"}\NormalTok{, }\StringTok{"div"}\NormalTok{, }\StringTok{"dl"}\NormalTok{, }\StringTok{"dt"}\NormalTok{, }\StringTok{"em"}\NormalTok{,}
  \StringTok{"eventsource"}\NormalTok{, }\StringTok{"fieldset"}\NormalTok{, }\StringTok{"figcaption"}\NormalTok{, }\StringTok{"figure"}\NormalTok{, }\StringTok{"footer"}\NormalTok{,}
  \StringTok{"form"}\NormalTok{, }\StringTok{"h1"}\NormalTok{, }\StringTok{"h2"}\NormalTok{, }\StringTok{"h3"}\NormalTok{, }\StringTok{"h4"}\NormalTok{, }\StringTok{"h5"}\NormalTok{, }\StringTok{"h6"}\NormalTok{, }\StringTok{"head"}\NormalTok{, }\StringTok{"header"}\NormalTok{,}
  \StringTok{"hgroup"}\NormalTok{, }\StringTok{"html"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"iframe"}\NormalTok{, }\StringTok{"ins"}\NormalTok{, }\StringTok{"kbd"}\NormalTok{, }\StringTok{"label"}\NormalTok{, }\StringTok{"legend"}\NormalTok{,}
  \StringTok{"li"}\NormalTok{, }\StringTok{"mark"}\NormalTok{, }\StringTok{"map"}\NormalTok{, }\StringTok{"menu"}\NormalTok{, }\StringTok{"meter"}\NormalTok{, }\StringTok{"nav"}\NormalTok{, }\StringTok{"noscript"}\NormalTok{, }\StringTok{"object"}\NormalTok{,}
  \StringTok{"ol"}\NormalTok{, }\StringTok{"optgroup"}\NormalTok{, }\StringTok{"option"}\NormalTok{, }\StringTok{"output"}\NormalTok{, }\StringTok{"p"}\NormalTok{, }\StringTok{"pre"}\NormalTok{, }\StringTok{"progress"}\NormalTok{, }\StringTok{"q"}\NormalTok{,}
  \StringTok{"ruby"}\NormalTok{, }\StringTok{"rp"}\NormalTok{, }\StringTok{"rt"}\NormalTok{, }\StringTok{"s"}\NormalTok{, }\StringTok{"samp"}\NormalTok{, }\StringTok{"script"}\NormalTok{, }\StringTok{"section"}\NormalTok{, }\StringTok{"select"}\NormalTok{,}
  \StringTok{"small"}\NormalTok{, }\StringTok{"span"}\NormalTok{, }\StringTok{"strong"}\NormalTok{, }\StringTok{"style"}\NormalTok{, }\StringTok{"sub"}\NormalTok{, }\StringTok{"summary"}\NormalTok{, }\StringTok{"sup"}\NormalTok{,}
  \StringTok{"table"}\NormalTok{, }\StringTok{"tbody"}\NormalTok{, }\StringTok{"td"}\NormalTok{, }\StringTok{"textarea"}\NormalTok{, }\StringTok{"tfoot"}\NormalTok{, }\StringTok{"th"}\NormalTok{, }\StringTok{"thead"}\NormalTok{,}
  \StringTok{"time"}\NormalTok{, }\StringTok{"title"}\NormalTok{, }\StringTok{"tr"}\NormalTok{, }\StringTok{"u"}\NormalTok{, }\StringTok{"ul"}\NormalTok{, }\StringTok{"var"}\NormalTok{, }\StringTok{"video"}
\NormalTok{)}

\NormalTok{void_tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"area"}\NormalTok{, }\StringTok{"base"}\NormalTok{, }\StringTok{"br"}\NormalTok{, }\StringTok{"col"}\NormalTok{, }\StringTok{"command"}\NormalTok{, }\StringTok{"embed"}\NormalTok{, }\StringTok{"hr"}\NormalTok{, }\StringTok{"img"}\NormalTok{,}
  \StringTok{"input"}\NormalTok{, }\StringTok{"keygen"}\NormalTok{, }\StringTok{"link"}\NormalTok{, }\StringTok{"meta"}\NormalTok{, }\StringTok{"param"}\NormalTok{, }\StringTok{"source"}\NormalTok{, }
  \StringTok{"track"}\NormalTok{, }\StringTok{"wbr"}
\NormalTok{)}

\NormalTok{html_tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
\NormalTok{  tags }\OperatorTok{%>%}\StringTok{ }\KeywordTok{set_names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(tag),}
\NormalTok{  void_tags }\OperatorTok{%>%}\StringTok{ }\KeywordTok{set_names}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{map}\NormalTok{(void_tag)}
\NormalTok{)}

\NormalTok{with_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(code) \{}
\NormalTok{  code <-}\StringTok{ }\KeywordTok{enquo}\NormalTok{(code)  }
  \KeywordTok{eval_tidy}\NormalTok{(code, html_tags)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, let's look at the example from above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}
  \KeywordTok{body}\NormalTok{(}
    \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
    \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> <HTML> <body><h1 id='first'>A heading</h1><p>Some text}
\CommentTok{#> &amp;<b>some bold text.</b></p><img src='myimg.png'}
\CommentTok{#> width='100' height='100' /></body>}
\end{Highlighting}
\end{Shaded}

The formatting consists of only one long line of code. This output makes it difficult to check the content of the HTML code and its correctness.

What kind of formatting would we prefer instead? \href{https://google.github.io/styleguide/htmlcssguide.html\#HTML_Formatting_Rules}{Google's HTML style guide} suggests \emph{indentation} by 2 spaces and \emph{new lines} for every block, list, or table element. There are other recommendations, but we will keep things simple and will be satisfied with the following output.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body>}
  \KeywordTok{<h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1>}
  \KeywordTok{<p>}\NormalTok{Some text }\DecValTok{&amp;}\KeywordTok{<b>}\NormalTok{some bold text.}\KeywordTok{</b></p>}
  \KeywordTok{<img}\OtherTok{ src=}\StringTok{'myimg.png'}\ErrorTok{width}\OtherTok{=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

First we adjust the \texttt{print.advr\_html()} method, removing \texttt{strwrap()} function, because this will re-wrap the HTML, making it harder to understand what's happening.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"advr_html"}\NormalTok{)}

\NormalTok{print.advr_html <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \KeywordTok{cat}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\StringTok{"<HTML>"}\NormalTok{, x, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In our desired output we can see that the content of the \texttt{body}-function requires different formatting than the other tag-functions. We will therefore create a new \texttt{format\_code()} function, that allows for optional indentation and line breaks.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{indent <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{paste0}\NormalTok{(}\StringTok{"  "}\NormalTok{, }\KeywordTok{gsub}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{  "}\NormalTok{, x))}
\NormalTok{\}}

\NormalTok{format_code <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(children, }\DataTypeTok{indent =} \OtherTok{FALSE}\NormalTok{) \{}
  \ControlFlowTok{if}\NormalTok{ (indent) \{}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\KeywordTok{paste0}\NormalTok{(}\KeywordTok{indent}\NormalTok{(children), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{)}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{) }
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We adjust the body function to include the \texttt{format\_code()} helper. (This could also be approached programmatically in the tag function factory).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html_tags}\OperatorTok{$}\NormalTok{body <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(...) \{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{dots_partition}\NormalTok{(...)}
\NormalTok{  attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(dots}\OperatorTok{$}\NormalTok{named)}
\NormalTok{  children <-}\StringTok{ }\KeywordTok{map_chr}\NormalTok{(dots}\OperatorTok{$}\NormalTok{unnamed, escape)}
  
  \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"<body"}\NormalTok{, attribs, }\StringTok{">"}\NormalTok{,}
    \KeywordTok{format_code}\NormalTok{(children, }\DataTypeTok{indent =} \OtherTok{TRUE}\NormalTok{),  }
    \StringTok{"</body>"}
\NormalTok{  ))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The resulting output is much more satisfying.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}
  \KeywordTok{body}\NormalTok{(}
    \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
    \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
    \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{  )}
\NormalTok{)}
\CommentTok{#> <HTML>}
\CommentTok{#> <body>}
\CommentTok{#>   <h1 id='first'>A heading</h1>}
\CommentTok{#>   <p>Some text &amp;<b>some bold text.</b></p>}
\CommentTok{#>   <img src='myimg.png' width='100' height='100' />}
\CommentTok{#> </body>}
\end{Highlighting}
\end{Shaded}

\hypertarget{latex}{%
\section{LaTeX}\label{latex}}

\textbf{{Q1}}: Add escaping. The special symbols that should be escaped by adding a backslash in front of them are \texttt{\textbackslash{}}, \texttt{\$}, and \texttt{\%}. Just as with HTML, you'll need to make sure you don't end up double-escaping. So, you'll need to create a small S3 class and then use that in function operators. That will also allow you to embed arbitrary LaTeX if needed.

\textbf{{A}}: Currently our \texttt{to\_math()} function generates the following output:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\DataTypeTok{$}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{f\}($)    # instead of <LATEX> \textbackslash{}$  }
\KeywordTok{to_math}\NormalTok{(a}\OperatorTok{$}\NormalTok{b)}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{$\}(a b)  # instead of <LATEX> \textbackslash{}mathrm\{\textbackslash{}$\}(a b)}
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{f\}(\textbackslash{})    # instead of <LATEX> \textbackslash{}\textbackslash{}  }
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\DataTypeTok{%}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{f\}(%)    # instead of <LATEX> \textbackslash{}%}
\end{Highlighting}
\end{Shaded}

To adjust this behaviour, we need an escape function with methods for the \texttt{character} and \texttt{advr\_latex} classes.

(Note that we must first repeat the underlying code from Advanced R. However, since this would be a bit verbose, and not very meaningful, we will not show this step here.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{escape_latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"escape_latex"}\NormalTok{)}

\NormalTok{escape_latex.character <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"^}\CharTok{\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}}\StringTok{$"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"^}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{$$"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}}\StringTok{$"}\NormalTok{, x)}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"^}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{%$"}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}\textbackslash{}\textbackslash{}}\StringTok{%"}\NormalTok{, x)}
  
  \KeywordTok{latex}\NormalTok{(x)}
\NormalTok{\}}

\NormalTok{escape_latex.advr_latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}
\end{Highlighting}
\end{Shaded}

We apply \texttt{escape\_latex()} within \texttt{latex\_env()} when creating environments for unknown symbols and unknown functions. For the unknown function, we need to modify \texttt{unknown\_op()} first.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unknown_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(op) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      contents <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(..., }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
      \KeywordTok{paste0}\NormalTok{(}
        \OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{mathrm\{"}\NormalTok{, }\KeywordTok{escape_latex}\NormalTok{(op), }\StringTok{"\}("}\NormalTok{), contents, }\StringTok{")"}
\NormalTok{      )}
\NormalTok{    \})}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  calls <-}\StringTok{ }\KeywordTok{all_calls}\NormalTok{(expr)}
\NormalTok{  call_list <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(calls), unknown_op)}
\NormalTok{  call_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(call_list)}
  
  \CommentTok{# Known functions}
\NormalTok{  f_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(f_env, call_env)}
  
  \CommentTok{# Default symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(}\KeywordTok{escape_latex}\NormalTok{(names), names),}
                               \DataTypeTok{parent =}\NormalTok{ f_env)}
  
  \CommentTok{# Known symbols}
\NormalTok{  greek_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{  greek_env}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, we can validate \texttt{to\_math()} on the test cases from above.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\DataTypeTok{$}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}$}
\KeywordTok{to_math}\NormalTok{(a}\OperatorTok{$}\NormalTok{b)}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{\textbackslash{}$\}(a b)}
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}\textbackslash{}}
\KeywordTok{to_math}\NormalTok{(}\StringTok{`}\DataTypeTok{%}\StringTok{`}\NormalTok{)}
\CommentTok{#> <LATEX> \textbackslash{}%}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Complete the DSL to support all the functions that \texttt{plotmath} supports.

\textbf{{A}}: We can look up all functions supported by \texttt{plotmath} via \texttt{?plotmath}. Here we chose to implement a representative subset of \texttt{plotmath} functionality within the \texttt{to\_math()}-DSL. If we wanted to implement more, we would need to be aware of different conversion patterns for symbols and functions and insert the correct conversion in the workflow presented below. Most relevant LaTeX code can be looked up on \href{https://en.wikipedia.org/wiki/Help:Displaying_a_formula}{Wikipedia}.

We will add support for the following hand full of functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%+-%}\StringTok{ }\NormalTok{y)}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%*%}\StringTok{ }\NormalTok{y)}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%->%}\StringTok{ }\NormalTok{y) }
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{bold}\NormalTok{(x))}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{!=}\StringTok{ }\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

To do this, we follow the LaTeX section from Advanced R straight from the beginning. This makes it easier to keep an overview, as we just need to insert the specific changes at the relevant parts.

Let's start and repeat the converter function \texttt{to\_math()} from the textbook.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{to_math <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  expr <-}\StringTok{ }\KeywordTok{enexpr}\NormalTok{(x)}
\NormalTok{  out <-}\StringTok{ }\KeywordTok{eval_bare}\NormalTok{(expr, }\KeywordTok{latex_env}\NormalTok{(expr))}
  
  \KeywordTok{latex}\NormalTok{(out)}
\NormalTok{\}}

\NormalTok{latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"advr_latex"}\NormalTok{)}
\NormalTok{print.advr_latex <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{cat}\NormalTok{(}\StringTok{"<LATEX> "}\NormalTok{, x, }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

One specific property in this setting is that the environment where \texttt{to\_math()} evaluates the expression is not constant, but depends on what we already know about the expression.

Thus, we start building up \texttt{latex\_env()}, which contains a chain of all the necessary environments which \texttt{to\_math()} checks to evaluate the expression in.

The first environment is the one for Greek letters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greek <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"alpha"}\NormalTok{, }\StringTok{"theta"}\NormalTok{, }\StringTok{"tau"}\NormalTok{, }\StringTok{"beta"}\NormalTok{, }\StringTok{"vartheta"}\NormalTok{, }\StringTok{"pi"}\NormalTok{, }\StringTok{"upsilon"}\NormalTok{,}
  \StringTok{"gamma"}\NormalTok{, }\StringTok{"varpi"}\NormalTok{, }\StringTok{"phi"}\NormalTok{, }\StringTok{"delta"}\NormalTok{, }\StringTok{"kappa"}\NormalTok{, }\StringTok{"rho"}\NormalTok{,}
  \StringTok{"varphi"}\NormalTok{, }\StringTok{"epsilon"}\NormalTok{, }\StringTok{"lambda"}\NormalTok{, }\StringTok{"varrho"}\NormalTok{, }\StringTok{"chi"}\NormalTok{, }\StringTok{"varepsilon"}\NormalTok{,}
  \StringTok{"mu"}\NormalTok{, }\StringTok{"sigma"}\NormalTok{, }\StringTok{"psi"}\NormalTok{, }\StringTok{"zeta"}\NormalTok{, }\StringTok{"nu"}\NormalTok{, }\StringTok{"varsigma"}\NormalTok{, }\StringTok{"omega"}\NormalTok{, }\StringTok{"eta"}\NormalTok{,}
  \StringTok{"xi"}\NormalTok{, }\StringTok{"Gamma"}\NormalTok{, }\StringTok{"Lambda"}\NormalTok{, }\StringTok{"Sigma"}\NormalTok{, }\StringTok{"Psi"}\NormalTok{, }\StringTok{"Delta"}\NormalTok{, }\StringTok{"Xi"}\NormalTok{,}
  \StringTok{"Upsilon"}\NormalTok{, }\StringTok{"Omega"}\NormalTok{, }\StringTok{"Theta"}\NormalTok{, }\StringTok{"Pi"}\NormalTok{, }\StringTok{"Phi"}
\NormalTok{)}
\NormalTok{greek_list <-}\StringTok{ }\KeywordTok{set_names}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{, greek), greek)}
\NormalTok{greek_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(greek_list)}

\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  greek_env}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We already know from Advanced R that e.g.~\texttt{to\_math(pi)} now correctly converts to \texttt{\textbackslash{}\textbackslash{}pi}. So, let's move on to the next one.

Here, it'll become a bit more technical. Not every symbol is Greek (and not every part of an expression is a symbol). To find out which symbols are present within the expression, first, we use an approach from \href{https://adv-r.hadley.nz/expressions.html\#ast-funs}{section 5 of the expressions chapter} (walking the AST to find all symbols) where Hadley recursively walks the AST to distinguish between different expression element types.

Let's shortly repeat the helpers defined in that section:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{expr_type <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \ControlFlowTok{if}\NormalTok{ (rlang}\OperatorTok{::}\KeywordTok{is_syntactic_literal}\NormalTok{(x)) \{}
    \StringTok{"constant"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.symbol}\NormalTok{(x)) \{}
    \StringTok{"symbol"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \StringTok{"call"}
\NormalTok{  \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \StringTok{"pairlist"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \KeywordTok{typeof}\NormalTok{(x)}
\NormalTok{  \}}
\NormalTok{\}}

\NormalTok{switch_expr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, ...) \{}
  \ControlFlowTok{switch}\NormalTok{(}\KeywordTok{expr_type}\NormalTok{(x),}
\NormalTok{         ...,}
         \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{,}
              \KeywordTok{typeof}\NormalTok{(x), }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{flat_map_chr <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(.x, .f, ...) \{}
\NormalTok{  purrr}\OperatorTok{::}\KeywordTok{flatten_chr}\NormalTok{(purrr}\OperatorTok{::}\KeywordTok{map}\NormalTok{(.x, .f, ...))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This let's us define \texttt{all\_names()}, which returns the desired symbols, already converted to characters.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_names_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
              \DataTypeTok{constant =} \KeywordTok{character}\NormalTok{(),}
              \DataTypeTok{symbol =}   \KeywordTok{as.character}\NormalTok{(x),}
              \DataTypeTok{call =}     \KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x[}\OperatorTok{-}\DecValTok{1}\NormalTok{]), all_names)}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{all_names <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{unique}\NormalTok{(}\KeywordTok{all_names_rec}\NormalTok{(x))}
\NormalTok{\}}

\KeywordTok{all_names}\NormalTok{(}\KeywordTok{expr}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{y }\OperatorTok{+}\StringTok{ }\KeywordTok{f}\NormalTok{(a, b, c, }\DecValTok{10}\NormalTok{)))}
\CommentTok{#> [1] "x" "y" "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

We use \texttt{all\_names()} now within \texttt{latex\_env()} to create an environment of the symbols which were found within the expression. This environment will be set as the parent environment of \texttt{greek\_env}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \CommentTok{# Unknown symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names))}
  
  \CommentTok{# Known symbols}
  \KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In this way, \texttt{to\_math()} will first convert all known Greek letters (found in \texttt{greek\_env}) and then any other symbols, which are left as is (in this implementation).

We also have to add support for functions. This will give us the opportunity to insert some specific support for \texttt{plotmath} functions.

To support a whole bunch of unary and binary functions within the function environment (\texttt{f\_env}), which will be added next to \texttt{latex\_env}, Hadley defines the following two helpers in Advanced R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unary_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(left, right) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{e1 =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(}
      \KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\NormalTok{left, e1, }\OperatorTok{!!}\NormalTok{right)}
\NormalTok{    ),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{binary_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(sep) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{e1 =}\NormalTok{ , }\DataTypeTok{e2 =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(}
      \KeywordTok{paste0}\NormalTok{(e1, }\OperatorTok{!!}\NormalTok{sep, e2)}
\NormalTok{    ),}
    \KeywordTok{caller_env}\NormalTok{()}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

While defining the function environment, \texttt{f\_env}, we mostly continue to copy the exact code from Advanced R. However, at the bottom we add a short section where we define some extra conversions which are part of \texttt{plotmath} (and selected above in our intro to this solution).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f_env <-}\StringTok{ }\KeywordTok{child_env}\NormalTok{(}
  \CommentTok{# Binary operators}
  \DataTypeTok{.parent =} \KeywordTok{empty_env}\NormalTok{(),}
  \StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" + "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{-}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" - "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" * "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{/}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" / "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{^}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"^"}\NormalTok{),}
  \StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"_"}\NormalTok{),}
  
  \CommentTok{# Grouping}
  \StringTok{`}\DataTypeTok{\{}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left\{ "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right\}"}\NormalTok{),}
  \StringTok{`}\DataTypeTok{(}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left( "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right)"}\NormalTok{),}
  \DataTypeTok{paste =}\NormalTok{ paste,}
  
  \CommentTok{# Other math functions}
  \DataTypeTok{sqrt =} \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sqrt\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  \DataTypeTok{sin =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sin("}\NormalTok{, }\StringTok{")"}\NormalTok{),}
  \DataTypeTok{log =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{log("}\NormalTok{, }\StringTok{")"}\NormalTok{),}
  \DataTypeTok{abs =}  \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left| "}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right| "}\NormalTok{),}
  \DataTypeTok{frac =} \ControlFlowTok{function}\NormalTok{(a, b) \{}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{frac\{"}\NormalTok{, a, }\StringTok{"\}\{"}\NormalTok{, b, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{  \},}
  
  \CommentTok{# Labelling}
  \DataTypeTok{hat =}   \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{hat\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  \DataTypeTok{tilde =} \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{tilde\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  
  \CommentTok{# Plotmath}
  \StringTok{`}\DataTypeTok{%+-%}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{pm "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{%*%}\StringTok{`}\NormalTok{  =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{times "}\NormalTok{),}
  \StringTok{`}\DataTypeTok{%->%}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{rightarrow "}\NormalTok{),}
  \DataTypeTok{bold =} \KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{textbf\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{),}
  \StringTok{`}\DataTypeTok{!=}\StringTok{`}\NormalTok{ =}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{neq "}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Again we extend \texttt{latex\_env()} to include the additional environment, \texttt{f\_env}, which must be the parent of the symbol environment (which is the parent of the Greek symbol environment).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
  \CommentTok{# Known functions}
\NormalTok{  f_env}
  
  \CommentTok{# Default symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names), }\DataTypeTok{parent =}\NormalTok{ f_env)}
  
  \CommentTok{# Known symbols}
\NormalTok{  greek_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
  
\NormalTok{  greek_env}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now, we can finally check if our new functionality works:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# New plotmath functionality}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%+-%}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}pm y}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%*%}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}times y}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%->%}\StringTok{ }\NormalTok{y) }
\CommentTok{#> <LATEX> x \textbackslash{}rightarrow y}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{bold}\NormalTok{(x))}
\CommentTok{#> <LATEX> \textbackslash{}textbf\{x\}}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{!=}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}neq y}

\CommentTok{# Other examples from Advanced R}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{pi))}
\CommentTok{#> <LATEX> \textbackslash{}sin(x + \textbackslash{}pi)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{log}\NormalTok{(x[i]}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\CommentTok{#> <LATEX> \textbackslash{}log(x_i^2)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(sin))}
\CommentTok{#> <LATEX> \textbackslash{}sin(sin)}
\end{Highlighting}
\end{Shaded}

If we wanted, we could include further \texttt{plotmath} functions in this step. If this collides with other functions at some point, we could just create an own \texttt{f\_plotmath\_env} to support more \texttt{plotmath} functions. In that case we would need to add this environment also to \texttt{latex\_env()} (as child environment of the function environment \texttt{f\_env}).

To complete this answer, we will also add the support for unknown functions. Similarly as for the unknown symbols, we use the trick to recursively run the AST and just reuse the code from Advanced R.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_calls_rec <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{switch_expr}\NormalTok{(x,}
              \DataTypeTok{constant =}\NormalTok{ ,}
              \DataTypeTok{symbol =}   \KeywordTok{character}\NormalTok{(),}
              \DataTypeTok{call =}\NormalTok{ \{}
\NormalTok{                fname <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])}
\NormalTok{                children <-}\StringTok{ }\KeywordTok{flat_map_chr}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(x[}\OperatorTok{-}\DecValTok{1}\NormalTok{]), all_calls)}
                \KeywordTok{c}\NormalTok{(fname, children)}
\NormalTok{              \}}
\NormalTok{  )}
\NormalTok{\}}

\NormalTok{all_calls <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{unique}\NormalTok{(}\KeywordTok{all_calls_rec}\NormalTok{(x))}
\NormalTok{\}}

\KeywordTok{all_calls}\NormalTok{(}\KeywordTok{expr}\NormalTok{(}\KeywordTok{f}\NormalTok{(g }\OperatorTok{+}\StringTok{ }\NormalTok{b, c, }\KeywordTok{d}\NormalTok{(a))))}
\CommentTok{#> [1] "f" "+" "d"}

\NormalTok{unknown_op <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(op) \{}
  \KeywordTok{new_function}\NormalTok{(}
    \KeywordTok{exprs}\NormalTok{(}\DataTypeTok{... =}\NormalTok{ ),}
    \KeywordTok{expr}\NormalTok{(\{}
\NormalTok{      contents <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(..., }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
      \KeywordTok{paste0}\NormalTok{(}\OperatorTok{!!}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{mathrm\{"}\NormalTok{, op, }\StringTok{"\}("}\NormalTok{), contents, }\StringTok{")"}\NormalTok{)}
\NormalTok{    \})}
\NormalTok{  )}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Of course, we need to add the new \texttt{call\_env} also to \texttt{latex\_env()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(expr) \{}
\NormalTok{  calls <-}\StringTok{ }\KeywordTok{all_calls}\NormalTok{(expr)}
\NormalTok{  call_list <-}\StringTok{ }\KeywordTok{map}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(calls), unknown_op)}
\NormalTok{  call_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(call_list)}
  
  \CommentTok{# Known functions}
\NormalTok{  f_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(f_env, call_env)}
  
  \CommentTok{# Default symbols}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
\NormalTok{  symbol_env <-}\StringTok{ }\KeywordTok{as_environment}\NormalTok{(}\KeywordTok{set_names}\NormalTok{(names), }\DataTypeTok{parent =}\NormalTok{ f_env)}
  
  \CommentTok{# Known symbols}
\NormalTok{  greek_env <-}\StringTok{ }\KeywordTok{env_clone}\NormalTok{(greek_env, }\DataTypeTok{parent =}\NormalTok{ symbol_env)}
\NormalTok{  greek_env}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Finally, we rerun our tests and double check the newly supported \texttt{plotmath} operators.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# New plotmath functionality}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%+-%}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}pm y}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%*%}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}times y}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{%->%}\StringTok{ }\NormalTok{y) }
\CommentTok{#> <LATEX> x \textbackslash{}rightarrow y}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{bold}\NormalTok{(x))}
\CommentTok{#> <LATEX> \textbackslash{}textbf\{x\}}
\KeywordTok{to_math}\NormalTok{(x }\OperatorTok{!=}\StringTok{ }\NormalTok{y)}
\CommentTok{#> <LATEX> x \textbackslash{}neq y}

\CommentTok{# Other examples from Advanced R}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(x }\OperatorTok{+}\StringTok{ }\NormalTok{pi))}
\CommentTok{#> <LATEX> \textbackslash{}sin(x + \textbackslash{}pi)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{log}\NormalTok{(x[i]}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\CommentTok{#> <LATEX> \textbackslash{}log(x_i^2)}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(sin))}
\CommentTok{#> <LATEX> \textbackslash{}sin(sin)}

\CommentTok{# Unknown functions}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(x)))}
\CommentTok{#> <LATEX> \textbackslash{}mathrm\{f\}(\textbackslash{}mathrm\{g\}(x))}
\end{Highlighting}
\end{Shaded}

\hypertarget{part-techniques}{%
\part{Techniques}\label{part-techniques}}

\stepcounter{chapter}

\hypertarget{measuring-performance}{%
\chapter{Measuring performance}\label{measuring-performance}}

\stepcounter{section}

\hypertarget{profiling}{%
\section{Profiling}\label{profiling}}

\textbf{{Q1}}: Profile the following function with \texttt{torture\ =\ TRUE}. What is surprising? Read the source code of \texttt{rm()} to figure out what's going on.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{n =} \FloatTok{1e5}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, n)}
  \KeywordTok{rm}\NormalTok{(x)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: We expect \texttt{f()} to create a vector (\texttt{x}) of length \texttt{n}, which is then removed so that \texttt{f()} just returns \texttt{NULL}. When we profile this function, it executes too fast for meaningful results.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{profvis}\OperatorTok{::}\KeywordTok{profvis}\NormalTok{(}\KeywordTok{f}\NormalTok{())}
\CommentTok{#> Error in parse_rprof(prof_output, expr_source): No parsing data}
\CommentTok{#> available. Maybe your function was too fast?}
\end{Highlighting}
\end{Shaded}

Setting \texttt{torture\ =\ TRUE} triggers garbage collection after every memory allocation call, which may be useful for more exact memory profiling.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{profvis}\OperatorTok{::}\KeywordTok{profvis}\NormalTok{(}\KeywordTok{f}\NormalTok{(), }\DataTypeTok{torture =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Surprisingly, profiling \texttt{f()} like this takes a very long time. What could be the reason?

We follow the hint in the question and inspect the source code of \texttt{rm()}:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{function}\NormalTok{ (..., }\DataTypeTok{list =} \KeywordTok{character}\NormalTok{(), }\DataTypeTok{pos =} \DecValTok{-1}\NormalTok{,}
          \DataTypeTok{envir =} \KeywordTok{as.environment}\NormalTok{(pos), }
          \DataTypeTok{inherits =} \OtherTok{FALSE}\NormalTok{) }
\NormalTok{\{}
\NormalTok{  dots <-}\StringTok{ }\KeywordTok{match.call}\NormalTok{(}\DataTypeTok{expand.dots =} \OtherTok{FALSE}\NormalTok{)}\OperatorTok{$}\NormalTok{...}
  \ControlFlowTok{if}\NormalTok{ (}
    \KeywordTok{length}\NormalTok{(dots) }\OperatorTok{&&}\StringTok{ }\OperatorTok{!}\KeywordTok{all}\NormalTok{(}
      \KeywordTok{vapply}\NormalTok{(dots, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{is.symbol}\NormalTok{(x) }\OperatorTok{||}\StringTok{ }
\StringTok{             }\KeywordTok{is.character}\NormalTok{(x), }\OtherTok{NA}\NormalTok{, }\DataTypeTok{USE.NAMES =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{    )}
\NormalTok{  ) }
    \KeywordTok{stop}\NormalTok{(}\StringTok{"... must contain names or character strings"}\NormalTok{)}
\NormalTok{  names <-}\StringTok{ }\KeywordTok{vapply}\NormalTok{(dots, as.character, }\StringTok{""}\NormalTok{)}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(names) }\OperatorTok{==}\StringTok{ }\NormalTok{0L) }
\NormalTok{    names <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
\NormalTok{  list <-}\StringTok{ }\KeywordTok{.Primitive}\NormalTok{(}\StringTok{"c"}\NormalTok{)(list, names)}
  \KeywordTok{.Internal}\NormalTok{(}\KeywordTok{remove}\NormalTok{(list, envir, inherits))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{rm()} does a surprising amount of work to get the name of the object to delete because it relies on non-standard evaluation.

We can make the job of \texttt{rm()} considerably simpler by using the \texttt{list} argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(}\DataTypeTok{n =} \FloatTok{1e5}\NormalTok{) \{}
\NormalTok{  x <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, n)}
  \KeywordTok{rm}\NormalTok{(}\DataTypeTok{list =} \StringTok{"x"}\NormalTok{)}
\NormalTok{\}}
\NormalTok{profvis}\OperatorTok{::}\KeywordTok{profvis}\NormalTok{(}\KeywordTok{f2}\NormalTok{(), }\DataTypeTok{torture =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Unfortunately, this still takes too long, and we are literally stuck in profiling.

Anecdotally, one of the authors once finished the profiling under an older R version. But the output seemed to be not very meaningful.

In conclusion, this question appears to be unanswerable for us, even for Hadley.

\hypertarget{microbenchmarking}{%
\section{Microbenchmarking}\label{microbenchmarking}}

\textbf{{Q1}}: Instead of using \texttt{bench::mark()}, you could use the built-in function \texttt{system.time()}. But \texttt{system.time()} is much less precise, so you'll need to repeat each operation many times with a loop, and then divide to find the average time of each operation, as in the code below.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\FloatTok{1e6}
\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) }\KeywordTok{sqrt}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) x }\OperatorTok{^}\StringTok{ }\FloatTok{0.5}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\end{Highlighting}
\end{Shaded}

How do the estimates from \texttt{system.time()} compare to those from \texttt{bench::mark()}? Why are they different?

\textbf{{A}}: We first microbenchmark these two expressions using \texttt{bench::mark()} and observe that the mean is not reported (as it is generally more affected by outliers).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\FloatTok{1e6}
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}

\NormalTok{bench_df <-}\StringTok{ }\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \KeywordTok{sqrt}\NormalTok{(x), }
\NormalTok{  x }\OperatorTok{^}\StringTok{ }\FloatTok{0.5}\NormalTok{,}
  \DataTypeTok{iterations =}\NormalTok{ n}
\NormalTok{)}

\NormalTok{bench_df}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression      min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 sqrt(x)         1µs    1.3µs   433394.      848B     6.93}
\CommentTok{#> 2 x^0.5         6.1µs    8.1µs    99433.      848B     3.38}
\end{Highlighting}
\end{Shaded}

We need to access the raw data, so we can compare the results of both benchmarking approaches.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1_bench <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(bench_df[}\DecValTok{1}\NormalTok{, }\StringTok{"time"}\NormalTok{]))}
\NormalTok{t2_bench <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(bench_df[}\DecValTok{2}\NormalTok{, }\StringTok{"time"}\NormalTok{]))}

\NormalTok{t1_systime <-}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) }\KeywordTok{sqrt}\NormalTok{(x)) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\NormalTok{t2_systime <-}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) x }\OperatorTok{^}\StringTok{ }\FloatTok{0.5}\NormalTok{) }\OperatorTok{/}\StringTok{ }\NormalTok{n}
\end{Highlighting}
\end{Shaded}

We see, that both approaches get the order of magnitude right. We assume, that the \texttt{bench::mark()}-results may be a little more accurate, because of its high precision timer. There may also be overhead introduced by the for loop in the \texttt{system.time()}-approach.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Compare the results}
\NormalTok{t1_systime[}\StringTok{"elapsed"}\NormalTok{]}
\CommentTok{#>  elapsed }
\CommentTok{#> 1.97e-06}
\NormalTok{t1_bench}
\CommentTok{#> [1] 2.7e-06}

\NormalTok{t2_systime[}\StringTok{"elapsed"}\NormalTok{]}
\CommentTok{#>  elapsed }
\CommentTok{#> 9.61e-06}
\NormalTok{t2_bench}
\CommentTok{#> [1] 1.03e-05}
\end{Highlighting}
\end{Shaded}

Side Note: take a look at \texttt{?proc.time} if you want to learn about the differences between ``user'', ``system'' and ``elapsed'' time.

\textbf{{Q2}}: Here are two other ways to compute the square root of a vector. Which do you think will be fastest? Which will be slowest? Use microbenchmarking to test your answers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{^}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\KeywordTok{exp}\NormalTok{(}\KeywordTok{log}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: To compare these approaches, we'll \texttt{bench::mark()} them and sort the result by the median execution time.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}

\NormalTok{bm <-}\StringTok{ }\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \KeywordTok{sqrt}\NormalTok{(x),}
\NormalTok{  x}\OperatorTok{^}\FloatTok{0.5}\NormalTok{,}
\NormalTok{  x}\OperatorTok{^}\NormalTok{(}\DecValTok{1} \OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{),}
  \KeywordTok{exp}\NormalTok{(}\KeywordTok{log}\NormalTok{(x) }\OperatorTok{/}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{)}

\NormalTok{bm[}\KeywordTok{order}\NormalTok{(bm}\OperatorTok{$}\NormalTok{median), ]}
\CommentTok{#> # A tibble: 4 x 6}
\CommentTok{#>   expression         min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>    <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 sqrt(x)          500ns    600ns  1011941.      848B      0  }
\CommentTok{#> 2 x^0.5            3.2µs    3.4µs   260817.      848B      0  }
\CommentTok{#> 3 x^(1/2)          3.4µs    3.7µs   248376.      848B      0  }
\CommentTok{#> 4 exp(log(x)/2)    8.5µs    8.7µs   109440.      848B     10.9}
\end{Highlighting}
\end{Shaded}

As one might expect the idiomatic primitive function \texttt{sqrt()} is the fastest. The approach \texttt{exp(log(x)\ /\ 2)} which builds on two other primitive functions is second, even though already considerably slower. The other calculations are even slower: \texttt{x\ \^{}\ 0.5} is faster than \texttt{x\ \^{}\ (1\ /\ 2)}, because \texttt{0.5} requires less computation than \texttt{(1\ /\ 2)}.

\hypertarget{improving-performance}{%
\chapter{Improving performance}\label{improving-performance}}

\addtocounter{section}{2}

\hypertarget{checking-for-existing-solutions}{%
\section{Checking for existing solutions}\label{checking-for-existing-solutions}}

\textbf{{Q1}}: What are faster alternatives to \texttt{lm}? Which are specifically designed to work with larger datasets?

\textbf{{A}}: The \href{https://cran.rstudio.com/web/views/HighPerformanceComputing.html}{CRAN task view for high-performance computing} provides many recommendations. For this question, we are most interested in the section on ``Large memory and out-of-memory data''. We could for example give \texttt{biglm::biglm()}, \texttt{speedglm::speedlm()} or \texttt{RcppEigen::fastLm()} a try.

For small datasets, we observe only minor performance gains (or even a small cost):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{penguins <-}\StringTok{ }\NormalTok{palmerpenguins}\OperatorTok{::}\NormalTok{penguins}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \StringTok{"lm"}\NormalTok{ =}\StringTok{ }\KeywordTok{lm}\NormalTok{(}
\NormalTok{    body_mass_g }\OperatorTok{~}\StringTok{ }\NormalTok{bill_length_mm }\OperatorTok{+}\StringTok{ }\NormalTok{species, }\DataTypeTok{data =}\NormalTok{ penguins}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"biglm"}\NormalTok{ =}\StringTok{ }\NormalTok{biglm}\OperatorTok{::}\KeywordTok{biglm}\NormalTok{(}
\NormalTok{    body_mass_g }\OperatorTok{~}\StringTok{ }\NormalTok{bill_length_mm }\OperatorTok{+}\StringTok{ }\NormalTok{species, }\DataTypeTok{data =}\NormalTok{ penguins}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"speedglm"}\NormalTok{ =}\StringTok{ }\NormalTok{speedglm}\OperatorTok{::}\KeywordTok{speedlm}\NormalTok{(}
\NormalTok{    body_mass_g }\OperatorTok{~}\StringTok{ }\NormalTok{bill_length_mm }\OperatorTok{+}\StringTok{ }\NormalTok{species, }\DataTypeTok{data =}\NormalTok{ penguins}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"fastLm"}\NormalTok{ =}\StringTok{ }\NormalTok{RcppEigen}\OperatorTok{::}\KeywordTok{fastLm}\NormalTok{(}
\NormalTok{    body_mass_g }\OperatorTok{~}\StringTok{ }\NormalTok{bill_length_mm }\OperatorTok{+}\StringTok{ }\NormalTok{species, }\DataTypeTok{data =}\NormalTok{ penguins}
\NormalTok{  ) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{()}
\NormalTok{)}
\CommentTok{#> # A tibble: 4 x 6}
\CommentTok{#>   expression      min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 lm           1.72ms   1.99ms      492.    1.02MB     2.03}
\CommentTok{#> 2 biglm        1.35ms   1.47ms      633.  405.17KB     2.03}
\CommentTok{#> 3 speedglm     1.96ms   2.14ms      442.   62.01MB     2.03}
\CommentTok{#> 4 fastLm       1.35ms   1.46ms      644.  202.07KB     4.12}
\end{Highlighting}
\end{Shaded}

For larger datasets the selection of the appropriate method is of greater relevance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{eps <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{100000}\NormalTok{)}
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{100000}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{), }\DecValTok{50000}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\DecValTok{7} \OperatorTok{*}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{(x2 }\OperatorTok{==}\StringTok{ "a"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\NormalTok{eps}
\NormalTok{td <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{y =}\NormalTok{ y, }\DataTypeTok{x1 =}\NormalTok{ x1, }\DataTypeTok{x2 =}\NormalTok{ x2, }\DataTypeTok{eps =}\NormalTok{ eps)}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \StringTok{"lm"}\NormalTok{ =}\StringTok{ }\KeywordTok{lm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2, }\DataTypeTok{data =}\NormalTok{ td) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"biglm"}\NormalTok{ =}\StringTok{ }\NormalTok{biglm}\OperatorTok{::}\KeywordTok{biglm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2, }\DataTypeTok{data =}\NormalTok{ td) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"speedglm"}\NormalTok{ =}\StringTok{ }\NormalTok{speedglm}\OperatorTok{::}\KeywordTok{speedlm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2, }\DataTypeTok{data =}\NormalTok{ td) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{(),}
  \StringTok{"fastLm"}\NormalTok{ =}\StringTok{ }\NormalTok{RcppEigen}\OperatorTok{::}\KeywordTok{fastLm}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2, }\DataTypeTok{data =}\NormalTok{ td) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{coef}\NormalTok{()}
\NormalTok{)}
\CommentTok{#> # A tibble: 4 x 6}
\CommentTok{#>   expression      min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 lm           63.4ms   83.8ms      9.44      27MB    17.0 }
\CommentTok{#> 2 biglm        56.8ms   63.2ms     11.5     22.2MB     9.58}
\CommentTok{#> 3 speedglm     47.8ms   53.6ms     18.4     20.4MB     9.21}
\CommentTok{#> 4 fastLm        134ms  148.4ms      6.58    30.2MB     8.23}
\end{Highlighting}
\end{Shaded}

For further speed improvements, you could install a linear algebra library optimised for your system (see \texttt{?speedglm::speedlm}).

\begin{quote}
The functions of class `speedlm' may speed up the fitting of LMs to large data sets. High performances can be obtained especially if R is linked against an optimized BLAS, such as ATLAS.
\end{quote}

Tip: In case your dataset is stored in a database, you might want to check out the \href{https://github.com/tidymodels/modeldb}{\texttt{\{modeldb\}} package} which executes the linear model code in the corresponding database backend.

\textbf{{Q2}}: What package implements a version of \texttt{match()} that's faster for repeated lookups? How much faster is it?

\textbf{{A}}: A web search points us to the \texttt{\{fastmatch\}}-package. We compare it to \texttt{base::match()} and observe an impressive performance gain.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{table <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{100000}
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(table, }\DecValTok{10000}\NormalTok{, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \DataTypeTok{match =} \KeywordTok{match}\NormalTok{(x, table),}
  \DataTypeTok{fastmatch =}\NormalTok{ fastmatch}\OperatorTok{::}\KeywordTok{fmatch}\NormalTok{(x, table)}
\NormalTok{) }
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression      min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 match        36.4ms  40.67ms      24.5    1.46MB        0}
\CommentTok{#> 2 fastmatch   896.6µs   1.01ms     868.   448.95KB        0}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: List four functions (not just those in base R) that convert a string into a date time object. What are their strengths and weaknesses?

\textbf{{A}}: The usual base R way is to use the \texttt{as.POSIXct()} generic and create a date time object of class \texttt{POSIXct} and type integer.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date_ct <-}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{)}
\NormalTok{date_ct}
\CommentTok{#> [1] "2020-01-01 12:30:25 CET"}
\end{Highlighting}
\end{Shaded}

Under the hood \texttt{as.POSIXct()} employs \texttt{as.POSIXlt()} for the character conversion. This creates a date time object of class \texttt{POSIXlt} and type \texttt{list}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date_lt <-}\StringTok{ }\KeywordTok{as.POSIXlt}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{)}
\NormalTok{date_lt}
\CommentTok{#> [1] "2020-01-01 12:30:25 CET"}
\end{Highlighting}
\end{Shaded}

The \texttt{POSIXlt} class has the advantage that it carries the individual time components as attributes. This allows to extract the time components via typical list operators.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attributes}\NormalTok{(date_lt)}
\CommentTok{#> $names}
\CommentTok{#>  [1] "sec"    "min"    "hour"   "mday"   "mon"    "year"   "wday"  }
\CommentTok{#>  [8] "yday"   "isdst"  "zone"   "gmtoff"}
\CommentTok{#> }
\CommentTok{#> $class}
\CommentTok{#> [1] "POSIXlt" "POSIXt"}
\NormalTok{date_lt}\OperatorTok{$}\NormalTok{sec}
\CommentTok{#> [1] 25}
\end{Highlighting}
\end{Shaded}

However, while lists may be practical basic calculations are often faster and require less memory for objects with underlying integer type.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date_lt2 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(date_lt, }\DecValTok{10000}\NormalTok{)}
\NormalTok{date_ct2 <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(date_ct, }\DecValTok{10000}\NormalTok{)}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
\NormalTok{  date_lt2 }\OperatorTok{-}\StringTok{ }\NormalTok{date_lt2, }
\NormalTok{  date_ct2 }\OperatorTok{-}\StringTok{ }\NormalTok{date_ct2,}
\NormalTok{  date_ct2 }\OperatorTok{-}\StringTok{ }\NormalTok{date_lt2}
\NormalTok{)}
\CommentTok{#> # A tibble: 3 x 6}
\CommentTok{#>   expression               min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>          <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 date_lt2 - date_lt2    340ms    371ms      2.69    1.36MB      0  }
\CommentTok{#> 2 date_ct2 - date_ct2    125µs    138µs   6890.    195.45KB     28.9}
\CommentTok{#> 3 date_ct2 - date_lt2    124ms    127ms      7.82  781.95KB      0}
\end{Highlighting}
\end{Shaded}

\texttt{as.POSIXlt()} in turn uses \texttt{strptime()} under the hood, which creates a similar date time object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{date_str <-}\StringTok{ }\KeywordTok{strptime}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{,}
                     \DataTypeTok{format =} \StringTok{"%Y-%m-%d %H:%M:%S"}\NormalTok{)}
\KeywordTok{identical}\NormalTok{(date_lt, date_str)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\texttt{as.POSIXct()} and \texttt{as.POSIXlt()} accept different character inputs by default (e.g.~\texttt{"2001-01-01\ 12:30"} or \texttt{"2001/1/1\ 12:30"}). \texttt{strptime()} requires the format argument to be set explicitly, and provides a performance improvement in return.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \DataTypeTok{as.POSIXct =} \KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{),}
  \DataTypeTok{as.POSIXct_format =} \KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{,}
    \DataTypeTok{format =} \StringTok{"%Y-%m-%d %H:%M:%S"}
\NormalTok{  ),}
  \DataTypeTok{strptime_fomat =} \KeywordTok{strptime}\NormalTok{(}\StringTok{"2020-01-01 12:30:25"}\NormalTok{,}
    \DataTypeTok{format =} \StringTok{"%Y-%m-%d %H:%M:%S"}
\NormalTok{  )}
\NormalTok{)[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{#> # A tibble: 3 x 3}
\CommentTok{#>   expression             min   median}
\CommentTok{#>   <bch:expr>        <bch:tm> <bch:tm>}
\CommentTok{#> 1 as.POSIXct          67.7µs   70.8µs}
\CommentTok{#> 2 as.POSIXct_format   34.1µs   36.4µs}
\CommentTok{#> 3 strptime_fomat      12.9µs   13.8µs}
\end{Highlighting}
\end{Shaded}

A fourth way is to use the converter functions from the \texttt{\{lubridate\}} package, which contains wrapper functions (for the POSIXct approach) with an intuitive syntax. (There is a slight decrease in performance though.)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(lubridate)}
\KeywordTok{ymd_hms}\NormalTok{(}\StringTok{"2013-07-24 23:55:26"}\NormalTok{)}
\CommentTok{#> [1] "2013-07-24 23:55:26 UTC"}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \DataTypeTok{as.POSIXct =} \KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{"2013-07-24 23:55:26"}\NormalTok{, }\DataTypeTok{tz =} \StringTok{"UTC"}\NormalTok{),}
  \DataTypeTok{ymd_hms =} \KeywordTok{ymd_hms}\NormalTok{(}\StringTok{"2013-07-24 23:55:26"}\NormalTok{)}
\NormalTok{)[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{#> # A tibble: 2 x 3}
\CommentTok{#>   expression      min   median}
\CommentTok{#>   <bch:expr> <bch:tm> <bch:tm>}
\CommentTok{#> 1 as.POSIXct   63.4µs   70.2µs}
\CommentTok{#> 2 ymd_hms       6.3ms   7.12ms}
\end{Highlighting}
\end{Shaded}

For additional ways to convert characters into date time objects, have a look at the \texttt{\{chron\}}, the \texttt{\{anytime\}} and the \texttt{\{fasttime\}} packages. The \texttt{\{chron\}} package introduces new classes and stores times as fractions of days in the underlying double type, while it doesn't deal with time zones and daylight savings. The \texttt{\{anytime\}} package aims to convert ``Anything to POSIXct or Date''. The \texttt{\{fasttime\}} package contains only one function (\texttt{fastPOSIXct()}).

\textbf{{Q4}}: Which packages provide the ability to compute a rolling mean?

\textbf{{A}}: A rolling mean is a useful statistic to smooth time-series, spatial and other types of data. The size of the rolling window usually determines the amount of smoothing and the number of missing values at the boundaries of the data.

The general functionality can be found in multiple packages, which vary in speed and flexibility of the computations. Here is a benchmark for several functions that all serve our purpose.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{slider}\OperatorTok{::}\KeywordTok{slide_dbl}\NormalTok{(x, mean, }\DataTypeTok{.before =} \DecValTok{1}\NormalTok{, }\DataTypeTok{.complete =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#>  [1]  NA 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \DataTypeTok{caTools =}\NormalTok{ caTools}\OperatorTok{::}\KeywordTok{runmean}\NormalTok{(x, }\DataTypeTok{k =} \DecValTok{2}\NormalTok{, }\DataTypeTok{endrule =} \StringTok{"NA"}\NormalTok{),}
  \DataTypeTok{data.table =}\NormalTok{ data.table}\OperatorTok{::}\KeywordTok{frollmean}\NormalTok{(x, }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{RcppRoll =}\NormalTok{ RcppRoll}\OperatorTok{::}\KeywordTok{roll_mean}\NormalTok{(x, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{, }\DataTypeTok{fill =} \OtherTok{NA}\NormalTok{, }
                                 \DataTypeTok{align =} \StringTok{"right"}\NormalTok{),}
  \DataTypeTok{slicer =}\NormalTok{ slider}\OperatorTok{::}\KeywordTok{slide_dbl}\NormalTok{(x, mean, }\DataTypeTok{.before =} \DecValTok{1}\NormalTok{, }\DataTypeTok{.complete =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{TTR =}\NormalTok{ TTR}\OperatorTok{::}\KeywordTok{SMA}\NormalTok{(x, }\DecValTok{2}\NormalTok{),}
  \DataTypeTok{zoo_apply =}\NormalTok{ zoo}\OperatorTok{::}\KeywordTok{rollapply}\NormalTok{(x, }\DecValTok{2}\NormalTok{, mean, }\DataTypeTok{fill =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{align =} \StringTok{"right"}\NormalTok{),}
  \DataTypeTok{zoo_rollmean =}\NormalTok{ zoo}\OperatorTok{::}\KeywordTok{rollmean}\NormalTok{(x, }\DecValTok{2}\NormalTok{, }\DataTypeTok{fill =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{align =} \StringTok{"right"}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> # A tibble: 7 x 6}
\CommentTok{#>   expression        min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 caTools        75.9µs   81.2µs    11811.   176.3KB    30.9 }
\CommentTok{#> 2 data.table     60.2µs   65.5µs    14757.    1.61MB    21.4 }
\CommentTok{#> 3 RcppRoll       39.2µs   44.7µs    19595.   63.96KB    24.1 }
\CommentTok{#> 4 slicer           83µs   89.7µs     9780.        0B    23.9 }
\CommentTok{#> 5 TTR           355.4µs  378.8µs     2245.       2MB     8.49}
\CommentTok{#> 6 zoo_apply     479.8µs  524.4µs     1755.  578.79KB    21.6 }
\CommentTok{#> 7 zoo_rollmean  407.8µs  426.2µs     2270.    6.43KB    22.2}
\end{Highlighting}
\end{Shaded}

You may also take a look at an extensive example in the \href{http://adv-r.had.co.nz/Functionals.html}{first edition of Advanced R}, which demonstrates how a rolling mean function can be created.

\textbf{{Q5}}: What are the alternatives to \texttt{optim()}?

\textbf{{A}}: According to its description (see \texttt{?optim}) \texttt{optim()} implements:

\begin{quote}
General-purpose optimization based on Nelder--Mead, quasi-Newton and conjugate-gradient algorithms. It includes an option for box-constrained optimization and simulated annealing.
\end{quote}

\texttt{optim()} allows to optimise a function (\texttt{fn}) on an interval with a specific method (\texttt{method\ =\ c("Nelder-Mead",\ "BFGS",\ "CG",\ "L-BFGS-B",\ "SANN",\ "Brent")}). Many detailed examples are given in the documentation. In the simplest case, we give \texttt{optim()} the starting value \texttt{par\ =\ 0} to calculate the minimum of a quadratic polynomial:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{optim}\NormalTok{(}\DecValTok{0}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{^}\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{100} \OperatorTok{*}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{50}\NormalTok{,}
  \DataTypeTok{method =} \StringTok{"Brent"}\NormalTok{,}
  \DataTypeTok{lower =} \FloatTok{-1e20}\NormalTok{, }\DataTypeTok{upper =} \FloatTok{1e20}
\NormalTok{)}
\CommentTok{#> $par}
\CommentTok{#> [1] 50}
\CommentTok{#> }
\CommentTok{#> $value}
\CommentTok{#> [1] -2450}
\CommentTok{#> }
\CommentTok{#> $counts}
\CommentTok{#> function gradient }
\CommentTok{#>       NA       NA }
\CommentTok{#> }
\CommentTok{#> $convergence}
\CommentTok{#> [1] 0}
\CommentTok{#> }
\CommentTok{#> $message}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

Since this solves a one-dimensional optimization task, we could have also used \texttt{stats::optimize()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{optimize}\NormalTok{(}\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{^}\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{100} \OperatorTok{*}\StringTok{ }\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{50}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\FloatTok{1e20}\NormalTok{, }\FloatTok{1e20}\NormalTok{))}
\CommentTok{#> $minimum}
\CommentTok{#> [1] 50}
\CommentTok{#> }
\CommentTok{#> $objective}
\CommentTok{#> [1] -2450}
\end{Highlighting}
\end{Shaded}

For more general alternatives, the appropriate choice highly depends on the type of optimization you intend to do. The \href{https://cran.r-project.org/web/views/Optimization.html}{CRAN task view on optimization and mathematical modelling} can serve as a useful reference. Here are a couple of examples:

\begin{itemize}
\tightlist
\item
  \texttt{\{optimx\}} extends the \texttt{optim()} function with the same syntax but more \texttt{method} choices.
\item
  \texttt{\{RcppNumerical\}} wraps several open source libraries for numerical computing (written in C++) and integrates them with R via \texttt{\{Rcpp\}}.
\item
  \texttt{\{DEoptim\}} provides a global optimiser based on the Differential Evolution algorithm.
\end{itemize}

\hypertarget{doing-as-little-as-possible}{%
\section{Doing as little as possible}\label{doing-as-little-as-possible}}

\textbf{{Q1}}: What's the difference between \texttt{rowSums()} and \texttt{.rowSums()}?

\textbf{{A}}: When we inspect the source code of the user-facing \texttt{rowSums()}, we see that it is designed as a wrapper around \texttt{.rowSums()} with some input validation, conversions and handling of complex numbers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowSums}
\CommentTok{#> function (x, na.rm = FALSE, dims = 1L) }
\CommentTok{#> \{}
\CommentTok{#>     if (is.data.frame(x)) }
\CommentTok{#>         x <- as.matrix(x)}
\CommentTok{#>     if (!is.array(x) || length(dn <- dim(x)) < 2L) }
\CommentTok{#>         stop("'x' must be an array of at least two dimensions")}
\CommentTok{#>     if (dims < 1L || dims > length(dn) - 1L) }
\CommentTok{#>         stop("invalid 'dims'")}
\CommentTok{#>     p <- prod(dn[-(id <- seq_len(dims))])}
\CommentTok{#>     dn <- dn[id]}
\CommentTok{#>     z <- if (is.complex(x)) }
\CommentTok{#>         .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * }
\CommentTok{#>             .Internal(rowSums(Im(x), prod(dn), p, na.rm))}
\CommentTok{#>     else .Internal(rowSums(x, prod(dn), p, na.rm))}
\CommentTok{#>     if (length(dn) > 1L) \{}
\CommentTok{#>         dim(z) <- dn}
\CommentTok{#>         dimnames(z) <- dimnames(x)[id]}
\CommentTok{#>     \}}
\CommentTok{#>     else names(z) <- dimnames(x)[[1L]]}
\CommentTok{#>     z}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x0000000019a7d8a8>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\texttt{.rowSums()} calls an internal function, which is built into the R interpreter. These compiled functions can be very fast.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{.rowSums}
\CommentTok{#> function (x, m, n, na.rm = FALSE) }
\CommentTok{#> .Internal(rowSums(x, m, n, na.rm))}
\CommentTok{#> <bytecode: 0x0000000022202058>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

However, as our benchmark reveals almost identical computing times, we prefer the safer variant over the internal function for this case.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(}\FloatTok{1e6}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{1000}\NormalTok{)}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \KeywordTok{rowSums}\NormalTok{(m),}
  \KeywordTok{.rowSums}\NormalTok{(m, }\DecValTok{1000}\NormalTok{, }\DecValTok{1000}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression                  min median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>              <bch:t> <bch:>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 rowSums(m)               4.58ms 5.08ms      174.    7.86KB        0}
\CommentTok{#> 2 .rowSums(m, 1000, 1000)  4.06ms 4.25ms      231.    7.86KB        0}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Make a faster version of \texttt{chisq.test()} that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying \texttt{chisq.test()} or by coding from the \href{http://en.wikipedia.org/wiki/Pearson\%27s_chi-squared_test}{mathematical definition}.

\textbf{{A}}: We aim to speed up our reimplementation of \texttt{chisq.test()} by \emph{doing less}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{chisq.test2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y) \{}
\NormalTok{  m <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(x, y)}
\NormalTok{  margin1 <-}\StringTok{ }\KeywordTok{rowSums}\NormalTok{(m)}
\NormalTok{  margin2 <-}\StringTok{ }\KeywordTok{colSums}\NormalTok{(m)}
\NormalTok{  n <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(m)}
\NormalTok{  me <-}\StringTok{ }\KeywordTok{tcrossprod}\NormalTok{(margin1, margin2) }\OperatorTok{/}\StringTok{ }\NormalTok{n}

\NormalTok{  x_stat <-}\StringTok{ }\KeywordTok{sum}\NormalTok{((m }\OperatorTok{-}\StringTok{ }\NormalTok{me)}\OperatorTok{^}\DecValTok{2} \OperatorTok{/}\StringTok{ }\NormalTok{me)}
\NormalTok{  df <-}\StringTok{ }\NormalTok{(}\KeywordTok{length}\NormalTok{(margin1) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{(}\KeywordTok{length}\NormalTok{(margin2) }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\NormalTok{  p.value <-}\StringTok{ }\KeywordTok{pchisq}\NormalTok{(x_stat, }\DataTypeTok{df =}\NormalTok{ df, }\DataTypeTok{lower.tail =} \OtherTok{FALSE}\NormalTok{)}

  \KeywordTok{list}\NormalTok{(}\DataTypeTok{x_stat =}\NormalTok{ x_stat, }\DataTypeTok{df =}\NormalTok{ df, }\DataTypeTok{p.value =}\NormalTok{ p.value)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We check if our new implementation returns the same results and benchmark it afterwards.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{21}\OperatorTok{:}\DecValTok{25}
\NormalTok{b <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{21}\NormalTok{, }\DecValTok{29}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{m <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(a, b)}

\KeywordTok{chisq.test}\NormalTok{(m) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{print}\NormalTok{(}\DataTypeTok{digits=}\DecValTok{5}\NormalTok{)}
\CommentTok{#> }
\CommentTok{#>  Pearson's Chi-squared test}
\CommentTok{#> }
\CommentTok{#> data:  m}
\CommentTok{#> X-squared = 0.162, df = 4, p-value = 1}
\KeywordTok{chisq.test2}\NormalTok{(a, b)}
\CommentTok{#> $x_stat}
\CommentTok{#> [1] 0.162}
\CommentTok{#> }
\CommentTok{#> $df}
\CommentTok{#> [1] 4}
\CommentTok{#> }
\CommentTok{#> $p.value}
\CommentTok{#> [1] 0.997}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \KeywordTok{chisq.test}\NormalTok{(m),}
  \KeywordTok{chisq.test2}\NormalTok{(a, b),}
  \DataTypeTok{check =} \OtherTok{FALSE}
\NormalTok{)}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression             min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>        <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 chisq.test(m)      121.9µs    168µs     4008.        0B     0   }
\CommentTok{#> 2 chisq.test2(a, b)   35.7µs   40.9µs    17434.        0B     2.03}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: Can you make a faster version of \texttt{table()} for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?

\textbf{{A}}: When analysing the source code of \texttt{table()} we aim to omit everything unnecessary and extract the main building blocks. We observe that \texttt{table()} is powered by \texttt{tabulate()} which is a very fast counting function. This leaves us with the challenge to compute the pre-processing as performant as possible.

First, we calculate the dimensions and names of the output table. Then we use \texttt{fastmatch::fmatch()} to map the elements of each vector to their position within the vector itself (i.e.~the smallest value is mapped to \texttt{1L}, the second smallest value to \texttt{2L}, etc.). Following the logic within \texttt{table()} we combine and shift these values to create a mapping of the integer pairs in our data to the index of the output table. After applying these lookups \texttt{tabulate()} counts the values and returns an integer vector with counts for each position in the table. As a last step, we reuse the code from \texttt{table()} to assign the correct dimension and class.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{table2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b)\{}
  
\NormalTok{  a_s <-}\StringTok{ }\KeywordTok{sort}\NormalTok{(}\KeywordTok{unique}\NormalTok{(a))}
\NormalTok{  b_s <-}\StringTok{ }\KeywordTok{sort}\NormalTok{(}\KeywordTok{unique}\NormalTok{(b))}
  
\NormalTok{  a_l <-}\StringTok{ }\KeywordTok{length}\NormalTok{(a_s)}
\NormalTok{  b_l <-}\StringTok{ }\KeywordTok{length}\NormalTok{(b_s)}
  
\NormalTok{  dims <-}\StringTok{ }\KeywordTok{c}\NormalTok{(a_l, b_l)}
\NormalTok{  pr <-}\StringTok{ }\NormalTok{a_l }\OperatorTok{*}\StringTok{ }\NormalTok{b_l}
\NormalTok{  dn <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =}\NormalTok{ a_s, }\DataTypeTok{b =}\NormalTok{ b_s)}
  
\NormalTok{  bin <-}\StringTok{ }\NormalTok{fastmatch}\OperatorTok{::}\KeywordTok{fmatch}\NormalTok{(a, a_s) }\OperatorTok{+}
\StringTok{    }\NormalTok{a_l }\OperatorTok{*}\StringTok{ }\NormalTok{fastmatch}\OperatorTok{::}\KeywordTok{fmatch}\NormalTok{(b, b_s) }\OperatorTok{-}\StringTok{ }\NormalTok{a_l}
\NormalTok{  y <-}\StringTok{ }\KeywordTok{tabulate}\NormalTok{(bin, pr)}
  
\NormalTok{  y <-}\StringTok{ }\KeywordTok{array}\NormalTok{(y, }\DataTypeTok{dim =}\NormalTok{ dims, }\DataTypeTok{dimnames =}\NormalTok{ dn)}
  \KeywordTok{class}\NormalTok{(y) <-}\StringTok{ "table"}
  
\NormalTok{  y}
\NormalTok{\}}

\NormalTok{a <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10000}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10000}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}

\NormalTok{bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
  \KeywordTok{table}\NormalTok{(a, b),}
  \KeywordTok{table2}\NormalTok{(a, b)}
\NormalTok{)}
\CommentTok{#> # A tibble: 2 x 6}
\CommentTok{#>   expression        min   median `itr/sec` mem_alloc `gc/sec`}
\CommentTok{#>   <bch:expr>   <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>}
\CommentTok{#> 1 table(a, b)    1.94ms   2.15ms      450.    1.29MB     15.6}
\CommentTok{#> 2 table2(a, b)    825µs  900.1µs      968.  576.33KB     12.9}
\end{Highlighting}
\end{Shaded}

Since we didn't use \texttt{table()} in our \texttt{chisq.test2()}-implementation, we cannot benefit from the slight performance gain from \texttt{table2()}.

\hypertarget{vectorise}{%
\section{Vectorise}\label{vectorise}}

\textbf{{Q1}}: The density functions, e.g.~\texttt{dnorm()}, have a common interface. Which arguments are vectorised over? What does \texttt{rnorm(10,\ mean\ =\ 10:1)} do?

\textbf{{A}}: We can get an overview of the interface of these functions via \texttt{?dnorm}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dnorm}\NormalTok{(x, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{1}\NormalTok{, }\DataTypeTok{log =} \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{pnorm}\NormalTok{(q, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{1}\NormalTok{, }\DataTypeTok{lower.tail =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{log.p =} \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{qnorm}\NormalTok{(p, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{1}\NormalTok{, }\DataTypeTok{lower.tail =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{log.p =} \OtherTok{FALSE}\NormalTok{)}
\KeywordTok{rnorm}\NormalTok{(n, }\DataTypeTok{mean =} \DecValTok{0}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

These functions are vectorised over their numeric arguments, which includes the first argument (\texttt{x}, \texttt{q}, \texttt{p}, \texttt{n}) as well as \texttt{mean} and \texttt{sd}.

\texttt{rnorm(10,\ mean\ =\ 10:1)} generates ten random numbers from different normal distributions. These normal distributions differ in their means. The first has mean 10, the second mean 9, the third mean 8 and so on.

\textbf{{Q2}}: Compare the speed of \texttt{apply(x,\ 1,\ sum)} with \texttt{rowSums(x)} for varying sizes of \texttt{x}.

\textbf{{A}}: We compare the two functions for square matrices of increasing size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rowsums <-}\StringTok{ }\NormalTok{bench}\OperatorTok{::}\KeywordTok{press}\NormalTok{(}
  \DataTypeTok{p =} \KeywordTok{seq}\NormalTok{(}\DecValTok{500}\NormalTok{, }\DecValTok{5000}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{10}\NormalTok{),}
\NormalTok{  \{}
\NormalTok{    mat <-}\StringTok{ }\KeywordTok{tcrossprod}\NormalTok{(}\KeywordTok{rnorm}\NormalTok{(p), }\KeywordTok{rnorm}\NormalTok{(p))}
\NormalTok{    bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
      \DataTypeTok{rowSums =} \KeywordTok{rowSums}\NormalTok{(mat),}
      \DataTypeTok{apply =} \KeywordTok{apply}\NormalTok{(mat, }\DecValTok{1}\NormalTok{, sum)}
\NormalTok{    )}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> Running with:}
\CommentTok{#>        p}
\CommentTok{#>  1   500}
\CommentTok{#>  2  1000}
\CommentTok{#>  3  1500}
\CommentTok{#>  4  2000}
\CommentTok{#>  5  2500}
\CommentTok{#>  6  3000}
\CommentTok{#>  7  3500}
\CommentTok{#>  8  4000}
\CommentTok{#>  9  4500}
\CommentTok{#> 10  5000}

\KeywordTok{library}\NormalTok{(ggplot2)}

\NormalTok{rowsums }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summary}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Approach =} \KeywordTok{as.character}\NormalTok{(expression)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}
    \KeywordTok{aes}\NormalTok{(p, median, }\DataTypeTok{color =}\NormalTok{ Approach, }\DataTypeTok{group =}\NormalTok{ Approach)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_line}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \StringTok{"Number of Rows and Columns"}\NormalTok{,}
       \DataTypeTok{y =} \StringTok{"Median (s)"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"top"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{24_Improving_performance_files/figure-latex/unnamed-chunk-22-1} \end{center}

We can see that the difference in performance is negligible for small matrices but becomes more and more relevant as the size of the data increases. \texttt{apply()} is a very versatile tool, but it's not ``vectorised for performance'' and not as optimised as \texttt{rowSums()}.

\textbf{{Q3}}: How can you use \texttt{crossprod()} to compute a weighted sum? How much faster is it than the naive \texttt{sum(x\ *\ w)}?

\textbf{{A}}: We can hand the vectors to \texttt{crossprod()}, which converts them to row- and column-vectors and then multiplies these. The result is the dot product, which corresponds to a weighted sum.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{w <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{sum}\NormalTok{(x }\OperatorTok{*}\StringTok{ }\NormalTok{w), }\KeywordTok{crossprod}\NormalTok{(x, w)[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

A benchmark of both approaches for different vector lengths indicates that the \texttt{crossprod()} variant is almost twice as fast as \texttt{sum(x\ *\ w)}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{weightedsum <-}\StringTok{ }\NormalTok{bench}\OperatorTok{::}\KeywordTok{press}\NormalTok{(}
  \DataTypeTok{n =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{,}
\NormalTok{  \{}
\NormalTok{    x <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n }\OperatorTok{*}\StringTok{ }\FloatTok{1e6}\NormalTok{)}
\NormalTok{    bench}\OperatorTok{::}\KeywordTok{mark}\NormalTok{(}
      \DataTypeTok{sum =} \KeywordTok{sum}\NormalTok{(x }\OperatorTok{*}\StringTok{ }\NormalTok{x),}
      \DataTypeTok{crossprod =} \KeywordTok{crossprod}\NormalTok{(x, x)[[}\DecValTok{1}\NormalTok{]]}
\NormalTok{    )}
\NormalTok{  \}}
\NormalTok{)}
\CommentTok{#> Running with:}
\CommentTok{#>        n}
\CommentTok{#>  1     1}
\CommentTok{#>  2     2}
\CommentTok{#>  3     3}
\CommentTok{#>  4     4}
\CommentTok{#>  5     5}
\CommentTok{#>  6     6}
\CommentTok{#>  7     7}
\CommentTok{#>  8     8}
\CommentTok{#>  9     9}
\CommentTok{#> 10    10}

\NormalTok{weightedsum }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{summary}\NormalTok{() }\OperatorTok{%>%}
\StringTok{  }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Approach =} \KeywordTok{as.character}\NormalTok{(expression)) }\OperatorTok{%>%}
\StringTok{  }\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(n, median, }\DataTypeTok{color =}\NormalTok{ Approach, }\DataTypeTok{group =}\NormalTok{ Approach)) }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_line}\NormalTok{() }\OperatorTok{+}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \StringTok{"Vector length (millions)"}\NormalTok{,}
       \DataTypeTok{y =} \StringTok{"Median (s)"}\NormalTok{) }\OperatorTok{+}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"top"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{center}\includegraphics[width=0.7\linewidth]{24_Improving_performance_files/figure-latex/unnamed-chunk-24-1} \end{center}

\hypertarget{rewriting-r-code-in-c}{%
\chapter{Rewriting R code in C++}\label{rewriting-r-code-in-c}}

\stepcounter{section}

\hypertarget{getting-started-with-c}{%
\section{Getting started with C++}\label{getting-started-with-c}}

\textbf{{Q1}}: With the basics of C++ in hand, it's now a great time to practice by reading and writing some simple C++ functions. For each of the following functions, read the code and figure out what the corresponding base R function is. You might not understand every part of the code yet, but you should be able to figure out the basics of what the function does.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ f1(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  \DataTypeTok{double}\NormalTok{ y = }\DecValTok{0}\NormalTok{;}
  
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    y += x[i] / n;}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ y;}
\NormalTok{\}}

\NormalTok{NumericVector f2(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}
  
\NormalTok{  out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = out[i - }\DecValTok{1}\NormalTok{] + x[i];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ f3(LogicalVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \ControlFlowTok{if}\NormalTok{ (x[i]) }\ControlFlowTok{return} \KeywordTok{true}\NormalTok{;}
\NormalTok{  \}}
  \ControlFlowTok{return} \KeywordTok{false}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ f4(Function pred, List x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  
  \ControlFlowTok{for}\NormalTok{(}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    LogicalVector res = pred(x[i]);}
    \ControlFlowTok{if}\NormalTok{ (res[}\DecValTok{0}\NormalTok{]) }\ControlFlowTok{return}\NormalTok{ i + }\DecValTok{1}\NormalTok{;}
\NormalTok{  \}}
  \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\NormalTok{NumericVector f5(NumericVector x, NumericVector y) \{}
  \DataTypeTok{int}\NormalTok{ n = }\BuiltInTok{std::}\NormalTok{max(x.size(), y.size());}
\NormalTok{  NumericVector x1 = rep_len(x, n);}
\NormalTok{  NumericVector y1 = rep_len(y, n);}
  
\NormalTok{  NumericVector out(n);}
  
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = }\BuiltInTok{std::}\NormalTok{min(x1[i], y1[i]);}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{A}}: The code above corresponds to the following base R functions:

\begin{itemize}
\tightlist
\item
  f1: \texttt{mean()}\\
\item
  f2: \texttt{cumsum()}\\
\item
  f3: \texttt{any()}
\item
  f4: \texttt{Position()}
\item
  f5: \texttt{pmin()}
\end{itemize}

\textbf{{Q2}}: To practice your function writing skills, convert the following functions into C++. For now, assume the inputs have no missing values.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{all()}.
\item
  \texttt{cumprod()}, \texttt{cummin()}, \texttt{cummax()}.
\item
  \texttt{diff()}. Start by assuming lag 1, and then generalise for lag \texttt{n}.
\item
  \texttt{range()}.
\item
  \texttt{var()}. Read about the approaches you can take on \href{http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance}{Wikipedia}. Whenever implementing a numerical algorithm, it's always good to check what is already known about the problem.
\end{enumerate}

\textbf{{A}}: Let's port these functions to C++.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{all()}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ allC(LogicalVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \ControlFlowTok{if}\NormalTok{ (!x[i]) }\ControlFlowTok{return} \KeywordTok{false}\NormalTok{;}
\NormalTok{  \}}
  \ControlFlowTok{return} \KeywordTok{true}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{cumprod()}, \texttt{cummin()}, \texttt{cummax()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NumericVector cumprodC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}

\NormalTok{  out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i]  = out[i - }\DecValTok{1}\NormalTok{] * x[i];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\NormalTok{NumericVector cumminC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}

\NormalTok{  out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i]  = }\BuiltInTok{std::}\NormalTok{min(out[i - }\DecValTok{1}\NormalTok{], x[i]);}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\NormalTok{NumericVector cummaxC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}

\NormalTok{  out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i]  = }\BuiltInTok{std::}\NormalTok{max(out[i - }\DecValTok{1}\NormalTok{], x[i]);}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{diff()} (Start by assuming lag 1, and then generalise for lag \texttt{n}.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NumericVector diffC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n - }\DecValTok{1}\NormalTok{);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; i++) \{}
\NormalTok{    out[i - }\DecValTok{1}\NormalTok{] = x[i] - x[i - }\DecValTok{1}\NormalTok{];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out ;}
\NormalTok{\}}

\NormalTok{NumericVector difflagC(NumericVector x, }\DataTypeTok{int}\NormalTok{ lag = }\DecValTok{1}\NormalTok{) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{if}\NormalTok{ (lag >= n) stop(}\StringTok{"`lag` must be less than `length(x)`."}\NormalTok{);}

\NormalTok{  NumericVector out(n - lag);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = lag; i < n; i++) \{}
\NormalTok{    out[i - lag] = x[i] - x[i - lag];}
\NormalTok{  \}}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{range()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{NumericVector rangeC(NumericVector x) \{}
  \DataTypeTok{double}\NormalTok{ omin = x[}\DecValTok{0}\NormalTok{], omax = x[}\DecValTok{0}\NormalTok{];}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{if}\NormalTok{ (n == }\DecValTok{0}\NormalTok{) stop(}\StringTok{"`length(x)` must be greater than 0."}\NormalTok{);}

  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; i++) \{}
\NormalTok{    omin = }\BuiltInTok{std::}\NormalTok{min(x[i], omin);}
\NormalTok{    omax = }\BuiltInTok{std::}\NormalTok{max(x[i], omax);}
\NormalTok{  \}}

\NormalTok{  NumericVector out(}\DecValTok{2}\NormalTok{);}
\NormalTok{  out[}\DecValTok{0}\NormalTok{] = omin;}
\NormalTok{  out[}\DecValTok{1}\NormalTok{] = omax;}
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  \texttt{var()}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double}\NormalTok{ varC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{if}\NormalTok{ (n < }\DecValTok{2}\NormalTok{) \{}
    \ControlFlowTok{return}\NormalTok{ NA_REAL;}
\NormalTok{  \}}

  \DataTypeTok{double}\NormalTok{ mx = }\DecValTok{0}\NormalTok{;}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    mx += x[i] / n;}
\NormalTok{  \}}

  \DataTypeTok{double}\NormalTok{ out = }\DecValTok{0}\NormalTok{;}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out += pow(x[i] - mx, }\DecValTok{2}\NormalTok{);}
\NormalTok{  \}}

  \ControlFlowTok{return}\NormalTok{ out / (n - }\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\stepcounter{section}

\hypertarget{missing-values}{%
\section{Missing values}\label{missing-values}}

\textbf{{Q1}}: Rewrite any of the functions from the first exercise to deal with missing values. If \texttt{na.rm} is true, ignore the missing values. If \texttt{na.rm} is false, return a missing value if the input contains any missing values. Some good functions to practice with are \texttt{min()}, \texttt{max()}, \texttt{range()}, \texttt{mean()}, and \texttt{var()}.

\textbf{{A}}: For this exercise we start with \texttt{minC()} and extend it so it can deal with missing values. We introduce an \texttt{na\_rm} argument to make \texttt{minC()} aware of \texttt{NA}s. In case \texttt{x} contains exclusively \texttt{NA} values \texttt{minC()} should return \texttt{Inf} for \texttt{na\_rm\ =\ TRUE}. For the return values vector data types are used to avoid irregular type conversions.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector minC(NumericVector x, }\DataTypeTok{bool}\NormalTok{ na_rm = }\KeywordTok{false}\NormalTok{) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out = NumericVector::create(R_PosInf);}
  
  \ControlFlowTok{if}\NormalTok{ (na_rm) \{}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (x[i] == NA_REAL) \{}
        \ControlFlowTok{continue}\NormalTok{;}
\NormalTok{      \}}
      \ControlFlowTok{if}\NormalTok{ (x[i] < out[}\DecValTok{0}\NormalTok{]) \{}
\NormalTok{        out[}\DecValTok{0}\NormalTok{] = x[i];}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (NumericVector::is_na(x[i])) \{}
\NormalTok{        out[}\DecValTok{0}\NormalTok{] = NA_REAL;}
        \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{      \}}
      \ControlFlowTok{if}\NormalTok{ (x[i] < out[}\DecValTok{0}\NormalTok{]) \{}
\NormalTok{        out[}\DecValTok{0}\NormalTok{] = x[i];}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{minC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\CommentTok{#> [1] NA}
\KeywordTok{minC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 2}
\KeywordTok{minC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{), }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] Inf}
\end{Highlighting}
\end{Shaded}

We also extend \texttt{anyC()} so it can deal with missing values. Please note that this (again) introduces some code duplication. This could be avoided by moving the check for missing values to the inner loop at the expense of a slight decrease of performance. Here we use \texttt{LogicalVector} as return type. If we would use \texttt{bool} instead, the C++ \texttt{NA\_LOGICAL} would be converted into R's logical \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector anyC(LogicalVector x, }\DataTypeTok{bool}\NormalTok{ na_rm = }\KeywordTok{false}\NormalTok{) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  LogicalVector out = LogicalVector::create(}\KeywordTok{false}\NormalTok{);}

  \ControlFlowTok{if}\NormalTok{ (na_rm == }\KeywordTok{false}\NormalTok{) \{}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (LogicalVector::is_na(x[i])) \{}
\NormalTok{        out[}\DecValTok{0}\NormalTok{] = NA_LOGICAL;}
        \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{if}\NormalTok{ (x[i]) \{}
\NormalTok{          out[}\DecValTok{0}\NormalTok{] = }\KeywordTok{true}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}

  \ControlFlowTok{if}\NormalTok{ (na_rm) \{}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (LogicalVector::is_na(x[i])) \{}
        \ControlFlowTok{continue}\NormalTok{;}
\NormalTok{      \}}
      \ControlFlowTok{if}\NormalTok{ (x[i]) \{}
\NormalTok{        out[}\DecValTok{0}\NormalTok{] = }\KeywordTok{true}\NormalTok{;}
        \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{anyC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{TRUE}\NormalTok{))  }\CommentTok{# any(c(NA, TRUE)) would return TRUE in this case}
\CommentTok{#> [1] NA}
\KeywordTok{anyC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{TRUE}\NormalTok{), }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: Rewrite \texttt{cumsum()} and \texttt{diff()} so they can handle missing values. Note that these functions have slightly more complicated behaviour.

\textbf{{A}}: Our \texttt{NA}-aware \texttt{cumsumC()} function will return a vector of the same length as \texttt{x}. By default (\texttt{na\_rm\ =\ FALSE}) all values following the first \texttt{NA} input value will be set to \texttt{NA}, because they depend on the unknown missing value. In case of \texttt{na\_rm\ =\ FALSE} the \texttt{NA} values are treated like zeros.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector cumsumC(NumericVector x, }\DataTypeTok{bool}\NormalTok{ na_rm = }\KeywordTok{false}\NormalTok{) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  NumericVector out(n);}
\NormalTok{  LogicalVector is_missing = is_na(x);}
  
  \ControlFlowTok{if}\NormalTok{ (!na_rm) \{}
\NormalTok{    out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (is_missing[i - }\DecValTok{1}\NormalTok{]) \{}
\NormalTok{        out[i] = NA_REAL;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{\{}
\NormalTok{        out[i] = out[i - }\DecValTok{1}\NormalTok{] + x[i];}
\NormalTok{      \}}
\NormalTok{    \}}
\NormalTok{  \}}
  
  \ControlFlowTok{if}\NormalTok{ (na_rm) \{}
    \ControlFlowTok{if}\NormalTok{ (is_missing[}\DecValTok{0}\NormalTok{]) \{}
\NormalTok{      out[}\DecValTok{0}\NormalTok{] = }\DecValTok{0}\NormalTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{      out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
\NormalTok{    \} }
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
      \ControlFlowTok{if}\NormalTok{ (is_missing[i]) \{}
\NormalTok{        out[i] = out[i-}\DecValTok{1}\NormalTok{] + }\DecValTok{0}\NormalTok{;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        out[i] = out[i-}\DecValTok{1}\NormalTok{] + x[i];}
\NormalTok{      \} }
\NormalTok{    \}}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cumsumC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\CommentTok{#> [1]  1 NA NA NA}
\KeywordTok{cumsumC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 1 1 3 7}
\end{Highlighting}
\end{Shaded}

The \texttt{diffC()} implementation will return an \texttt{NA} vector of length \texttt{length(x)\ -\ lag}, if the input vector contains a missing value. In case of \texttt{na\_rm\ =\ TRUE}, the function will return an \texttt{NA} for every difference with at least one \texttt{NA} as input.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector diffC(NumericVector x, }\DataTypeTok{int}\NormalTok{ lag = }\DecValTok{1}\NormalTok{,}
                    \DataTypeTok{bool}\NormalTok{ na_rm = }\KeywordTok{false}\NormalTok{) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  
  \ControlFlowTok{if}\NormalTok{ (lag >= n) stop(}\StringTok{"`lag` must be less than `length(x)`."}\NormalTok{);}
  
\NormalTok{  NumericVector out(n - lag);}
  
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = lag; i < n; i++) \{}
    \ControlFlowTok{if}\NormalTok{ (NumericVector::is_na(x[i]) ||}
\NormalTok{        NumericVector::is_na(x[i - lag])) \{}
      \ControlFlowTok{if}\NormalTok{ (!na_rm) \{}
        \ControlFlowTok{return}\NormalTok{ rep(NumericVector::create(NA_REAL), n - lag);}
\NormalTok{      \}}
\NormalTok{      out[i - lag] = NA_REAL;}
      \ControlFlowTok{continue}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{    out[i - lag] = x[i] - x[i - lag];}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{diffC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{10}\NormalTok{))}
\CommentTok{#> [1] NA NA NA}
\KeywordTok{diffC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DataTypeTok{na_rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 2 NA NA}
\end{Highlighting}
\end{Shaded}

\hypertarget{standard-template-library}{%
\section{Standard Template Library}\label{standard-template-library}}

To practice using the STL algorithms and data structures, implement the following using R functions in C++, using the hints provided:

\textbf{{Q1}}: \texttt{median.default()} using \texttt{partial\_sort}.

\textbf{{A}}: The median is computed differently for even or odd vectors, which we allow for in the function below.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<algorithm>}
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ medianC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}

  \ControlFlowTok{if}\NormalTok{ (n % }\DecValTok{2}\NormalTok{ == }\DecValTok{0}\NormalTok{) \{}
    \BuiltInTok{std::}\NormalTok{partial_sort (x.begin(), x.begin() + n / }\DecValTok{2}\NormalTok{ + }\DecValTok{1}\NormalTok{, x.end());}
    \ControlFlowTok{return}\NormalTok{ (x[n / }\DecValTok{2}\NormalTok{ - }\DecValTok{1}\NormalTok{] + x[n / }\DecValTok{2}\NormalTok{]) / }\DecValTok{2}\NormalTok{;}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \BuiltInTok{std::}\NormalTok{partial_sort (x.begin(), x.begin() + (n + }\DecValTok{1}\NormalTok{) / }\DecValTok{2}\NormalTok{, x.end());}
    \ControlFlowTok{return}\NormalTok{ x[(n + }\DecValTok{1}\NormalTok{) / }\DecValTok{2}\NormalTok{ - }\DecValTok{1}\NormalTok{];}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q2}}: \texttt{\%in\%} using \texttt{unordered\_set} and the \texttt{find()} or \texttt{count()} methods.

\textbf{{A}}: We use the \texttt{find()} method and loop through the \texttt{unordered\_set} until we find a match or have scanned the entire set.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\PreprocessorTok{#include }\ImportTok{<unordered_set>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector inC(CharacterVector x, CharacterVector table) \{}
  \BuiltInTok{std::}\NormalTok{unordered_set<String> seen;}
\NormalTok{  seen.insert(table.begin(), table.end());}
  
  \DataTypeTok{int}\NormalTok{ n = x.size();}
\NormalTok{  LogicalVector out(n);}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
\NormalTok{    out[i] = seen.find(x[i]) != seen.end();}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q3}}: \texttt{unique()} using an \texttt{unordered\_set} (challenge: do it in one line!).

\textbf{{A}}: The \texttt{insert()}-method will return if an equivalent element already exists. If a new element is inserted, we will add it to the (unique) return vector of our function.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\PreprocessorTok{#include }\ImportTok{<unordered_set>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector uniqueC(NumericVector x) \{}
  \BuiltInTok{std::}\NormalTok{unordered_set<}\DataTypeTok{int}\NormalTok{> seen;}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  
  \BuiltInTok{std::}\NormalTok{vector<}\DataTypeTok{double}\NormalTok{> out;}
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \ControlFlowTok{if}\NormalTok{ (seen.insert(x[i]).second) out.push_back(x[i]);}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ wrap(out);}
\NormalTok{\}}


\CommentTok{// As a one-liner}
\CommentTok{// [[Rcpp::export]]}
\BuiltInTok{std::}\NormalTok{unordered_set<}\DataTypeTok{double}\NormalTok{> uniqueCC(NumericVector x) \{}
  \ControlFlowTok{return} \BuiltInTok{std::}\NormalTok{unordered_set<}\DataTypeTok{double}\NormalTok{>(x.begin(), x.end());}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q4}}: \texttt{min()} using \texttt{std::min()}, or \texttt{max()} using \texttt{std::max()}.

\textbf{{A}}: We will implement \texttt{min()} by iterating over the vector and recursively comparing each element to the current minimum value.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ minC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ n = x.size();}
  \DataTypeTok{double}\NormalTok{ out = x[}\DecValTok{0}\NormalTok{];}
  
  \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
\NormalTok{    out = }\BuiltInTok{std::}\NormalTok{min(out, x[i]);}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q5}}: \texttt{which.min()} using \texttt{min\_element}, or \texttt{which.max()} using \texttt{max\_element}.

\textbf{{A}}: To implement \texttt{which.min()}, we will first locate the \texttt{min\_element} and then compute the \texttt{distance()} to it (starting from the beginning of the vector).

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\PreprocessorTok{#include }\ImportTok{<algorithm>}
\PreprocessorTok{#include }\ImportTok{<iterator>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double}\NormalTok{ which_minC(NumericVector x) \{}
  \DataTypeTok{int}\NormalTok{ out = }\BuiltInTok{std::}\NormalTok{distance(}
\NormalTok{    x.begin(), }\BuiltInTok{std::}\NormalTok{min_element(x.begin(), x.end())}
\NormalTok{  );}

  \ControlFlowTok{return}\NormalTok{ out + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\textbf{{Q6}}: \texttt{setdiff()}, \texttt{union()}, and \texttt{intersect()} for integers using sorted ranges and \texttt{set\_union}, \texttt{set\_intersection} and \texttt{set\_difference}.

\textbf{{A}}: The structure of the three functions will be very similar.

We first sort both input vectors. Then we apply the respective \texttt{set\_union}, \texttt{set\_intersection} or \texttt{set\_difference} function. After that, the result will be between the iterators \texttt{tmp.begin()} and \texttt{out\_end}. To retrieve the result, we loop once through the range between \texttt{tmp.begin()} and \texttt{out\_end} in the last part of each function.

The set operations in base R will discard duplicated values in the arguments. We achieve a similar behaviour by introducing a deduplication step, which omits values that match their predecessor. For the symmetric set functions \texttt{unionC} and \texttt{intersectC} this step is implemented for the output vector. For \texttt{setdiffC} the deduplication is applied to the first input vector.

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#include }\ImportTok{<Rcpp.h>}
\PreprocessorTok{#include }\ImportTok{<unordered_set>}
\PreprocessorTok{#include }\ImportTok{<algorithm>}
\KeywordTok{using} \KeywordTok{namespace}\NormalTok{ Rcpp;}

\CommentTok{// [[Rcpp::plugins(cpp11)]]}
\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector unionC(IntegerVector x, IntegerVector y) \{}
  \DataTypeTok{int}\NormalTok{ nx = x.size();}
  \DataTypeTok{int}\NormalTok{ ny = y.size();}
  
\NormalTok{  IntegerVector tmp(nx + ny);}
  
  \BuiltInTok{std::}\NormalTok{sort(x.begin(), x.end()); }\CommentTok{// unique}
  \BuiltInTok{std::}\NormalTok{sort(y.begin(), y.end());}
  
\NormalTok{  IntegerVector::iterator out_end = }\BuiltInTok{std::}\NormalTok{set_union(}
\NormalTok{    x.begin(), x.end(), y.begin(), y.end(), tmp.begin()}
\NormalTok{  );}
  
  \DataTypeTok{int}\NormalTok{ prev_value = }\DecValTok{0}\NormalTok{;}
\NormalTok{  IntegerVector out;}
  \ControlFlowTok{for}\NormalTok{ (IntegerVector::iterator it = tmp.begin();}
\NormalTok{       it != out_end; ++it) \{}
    \ControlFlowTok{if}\NormalTok{ ((it != tmp.begin())  && (prev_value == *it)) }\ControlFlowTok{continue}\NormalTok{;}
    
\NormalTok{    out.push_back(*it);}
    
\NormalTok{    prev_value = *it;}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector intersectC(IntegerVector x, IntegerVector y) \{}
  \DataTypeTok{int}\NormalTok{ nx = x.size();}
  \DataTypeTok{int}\NormalTok{ ny = y.size();}
  
\NormalTok{  IntegerVector tmp(}\BuiltInTok{std::}\NormalTok{min(nx, ny));}
  
  \BuiltInTok{std::}\NormalTok{sort(x.begin(), x.end());}
  \BuiltInTok{std::}\NormalTok{sort(y.begin(), y.end());}
  
\NormalTok{  IntegerVector::iterator out_end = }\BuiltInTok{std::}\NormalTok{set_intersection(}
\NormalTok{    x.begin(), x.end(), y.begin(), y.end(), tmp.begin()}
\NormalTok{  );}
  
  \DataTypeTok{int}\NormalTok{ prev_value = }\DecValTok{0}\NormalTok{;  }
\NormalTok{  IntegerVector out;}
  \ControlFlowTok{for}\NormalTok{ (IntegerVector::iterator it = tmp.begin();}
\NormalTok{       it != out_end; ++it) \{}
    \ControlFlowTok{if}\NormalTok{ ((it != tmp.begin()) && (prev_value == *it)) }\ControlFlowTok{continue}\NormalTok{;}
    
\NormalTok{    out.push_back(*it);}
    
\NormalTok{    prev_value = *it;}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector setdiffC(IntegerVector x, IntegerVector y) \{}
  \DataTypeTok{int}\NormalTok{ nx = x.size();}
  \DataTypeTok{int}\NormalTok{ ny = y.size();}
  
\NormalTok{  IntegerVector tmp(nx);}
  
  \BuiltInTok{std::}\NormalTok{sort(x.begin(), x.end());}
  
  \DataTypeTok{int}\NormalTok{ prev_value = }\DecValTok{0}\NormalTok{;}
\NormalTok{  IntegerVector x_dedup;}
  \ControlFlowTok{for}\NormalTok{ (IntegerVector::iterator it = x.begin();}
\NormalTok{       it != x.end(); ++it) \{}
    \ControlFlowTok{if}\NormalTok{ ((it != x.begin()) && (prev_value == *it)) }\ControlFlowTok{continue}\NormalTok{;}
    
\NormalTok{    x_dedup.push_back(*it);}
    
\NormalTok{    prev_value = *it;}
\NormalTok{  \}}
  
  \BuiltInTok{std::}\NormalTok{sort(y.begin(), y.end());}
  
\NormalTok{  IntegerVector::iterator out_end = }\BuiltInTok{std::}\NormalTok{set_difference(}
\NormalTok{    x_dedup.begin(), x_dedup.end(), y.begin(), y.end(), tmp.begin()}
\NormalTok{  );}
  
\NormalTok{  IntegerVector out;}
  \ControlFlowTok{for}\NormalTok{ (IntegerVector::iterator it = tmp.begin();}
\NormalTok{       it != out_end; ++it) \{}
\NormalTok{    out.push_back(*it);}
\NormalTok{  \}}
  
  \ControlFlowTok{return}\NormalTok{ out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Let's verify, that these functions work as intended.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# input vectors include duplicates}
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{)}

\KeywordTok{union}\NormalTok{(x, y)}
\CommentTok{#> [1] 1 2 3 5}
\KeywordTok{unionC}\NormalTok{(x, y)}
\CommentTok{#> [1] 1 2 3 5}

\KeywordTok{intersect}\NormalTok{(x, y)}
\CommentTok{#> [1] 2 3}
\KeywordTok{intersectC}\NormalTok{(x, y)}
\CommentTok{#> [1] 2 3}

\KeywordTok{setdiff}\NormalTok{(x, y)}
\CommentTok{#> [1] 1}
\KeywordTok{setdiffC}\NormalTok{(x, y)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

  \bibliography{book.bib}

\backmatter
\printindex

\end{document}
