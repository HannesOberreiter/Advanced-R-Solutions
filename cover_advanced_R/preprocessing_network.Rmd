# Build network graph for advanced R solutions book cover
Dec 2020
Authors: Henning Bumann, Tobias Stalder

output: edges_df, nodes_df
options:
 - Filter options for "depth" of the network (e.g. hierarchy level)
 - volles Netzwerk vs. selection
 - size (N Aufgaben) und type für jedes Zeile in node_df berechnen

## set working dir and load packages ---------------------------------------
```{r}
packages <- c("tidyverse", "Cairo", "ggpubr",
              # "ggalt",  # läuft bei mir nicht
              "ggbump", "scales", "prismatic", "treemapify","GGally",
              "intergraph", "ggraph", "visNetwork", "threejs", "networkD3",
              #"ndtv",
              "igraph", "gtools")

package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)
```

## load and clean data to long format
```{r}
df_long_raw <- read.csv2(r"(progress_data.csv)", stringsAsFactors = FALSE, 
                     header = TRUE) %>% 
  as_tibble() %>% 
  mutate(status = "finalised") %>% 
  modify_at("status", factor,
            levels = c("open", "started", "solved", "reviewed", "finalised")) %>% 
  tibble::rowid_to_column("id") %>% 
  separate(chapter, "nr", sep = " ", remove = FALSE, extra = "drop") %>% 
  mutate(nr = as.integer(nr), 
         chapter = factor(chapter),
         chapter = fct_reorder(chapter, nr, .desc = FALSE),
         part = case_when(nr < 9 ~ "Foundations",
                          nr < 12 ~ "Functional\nProgramming",
                          nr < 17 ~ "Object Oriented\nProgramming",
                          nr < 22 ~ "Metaprogramming",
                          TRUE    ~ "Techniques"),
         part = factor(part, levels = c("Foundations", "Functional\nProgramming",
                                        "Object Oriented\nProgramming",
                                        "Metaprogramming", "Techniques"))) %>% 
  add_count(chapter)


df_long <- df_long_raw %>% 
  mutate(part = paste0("p_", part),
         chapter = paste0("c_", chapter),
         subchapter = paste0("sc_", subchapter),
         exercise = paste0("ex_", id)) %>% 
  select(id, part, chapter, subchapter, exercise)
```

## create nodes_df
```{r}
nodes_df <- df_long %>% 
  select(part, chapter, subchapter, exercise) %>% 
  modify(as.character) %>% 
  map(unique) %>% 
  reduce(c) %>% 
  tibble(node = .)


# mögliche subsetbildung auf diese Weise :)
nodes_wo_ex_df <- nodes_df %>% 
  filter(!str_starts(node, "ex_"))
```


## create edges_df
```{r}
tidyr::crossing(from = nodes_df$node,
                to = nodes_df$node)

# TODO: connect with everything in one hierarchy and with the parent

# TODO: connect with predecessor and descendant (to reduce number of connections)
```


## test network
```{r}
net_ex <- graph_from_data_frame(d = edges_df, vertices = nodes_df)

plot(net_ex)

ggraph(net_ex, layout = "kk") +
  geom_edge_link(color = "grey") +
  geom_node_point(size = 3) +
  geom_node_text(aes(label = name), color = "blue", nudge_y = .2)

```

## Exkurs: data.tree (falls irgendwo hilfreich)
```{r, eval=FALSE}
library(igraph)
library(ggraph)
library(data.tree)

df_long$pathString <- paste("Book", 
                            df_long$part, 
                            df_long$chapter, 
                            df_long$subchapter, 
                            df_long$exercise,
                            sep = "/")

sum_n_recursively <- function(node) {
  node$n <-
    sum(c(node$n_subchapter, purrr::map_dbl(node$children, sum_n_recursively)), na.rm = TRUE)
}

node_tree <- df_long %>% 
  mutate(n = 1) %>% 
  as.Node()

sum_n_recursively(node_tree)
print(node_tree, "n")  # TODO: not yet working as it already did (didn't save code)...

mygraph <- node_tree %>% 
  as.igraph.Node(directed = TRUE)

plot(mygraph)
```

